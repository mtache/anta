{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#arista-network-test-automation-anta-framework","title":"Arista Network Test Automation (ANTA) Framework","text":"<p>ANTA is Python framework that automates tests for Arista devices.</p> <ul> <li>ANTA provides a set of tests to validate the state of your network</li> <li>ANTA can be used to:<ul> <li>Automate NRFU (Network Ready For Use) test on a preproduction network</li> <li>Automate tests on a live network (periodically or on demand)</li> </ul> </li> <li>ANTA can be used with:<ul> <li>The ANTA CLI</li> <li>As a Python library in your own application</li> </ul> </li> </ul> <p></p> <pre><code># Install ANTA CLI\n$ pip install anta\n\n# Run ANTA CLI\n$ anta --help\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test Automation (ANTA) CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS  [env var:\n                                  ANTA_PASSWORD; required]\n--timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 5]\n--insecure                      Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE]\n--enable                        Add enable mode towards the devices if\nrequired to connect  [env var: ANTA_ENABLE]\n--enable-password TEXT          Enable password if required to connect,\n                                  --enable MUST be set  [env var:\n                                  ANTA_ENABLE_PASSWORD]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre> <p>Info</p> <p><code>username</code>, <code>password</code>, <code>enable</code>, and <code>enable-password</code> values are the same for all devices</p>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is published on ANTA package website</p>"},{"location":"#contribution-guide","title":"Contribution guide","text":"<p>Contributions are welcome. Please refer to the contribution guide</p>"},{"location":"#credits","title":"Credits","text":"<p>Thank you to Ang\u00e9lique Phillipps, Colin MacGiollaE\u00e1in, Khelil Sator, Matthieu Tache, Onur Gashi, Paul Lavelle, Guillaume Mulocher and Thomas Grimonet for their contributions and guidances.</p>"},{"location":"contribution/","title":"Contributions","text":""},{"location":"contribution/#how-to-contribute-to-anta","title":"How to contribute to ANTA","text":"<p>Contribution model is based on a fork-model. Don\u2019t push to arista-netdevops-community/anta directly. Always do a branch in your forked repository and create a PR.</p> <p>To help development, open your PR as soon as possible even in draft mode. It helps other to know on what you are working on and avoid duplicate PRs.</p>"},{"location":"contribution/#create-a-development-environement","title":"Create a development environement","text":"<p>Run the following commands to create an ANTA development environement:</p> <pre><code># Clone repository\n$ git clone https://github.com/arista-netdevops-community/anta.git\n$ cd anta\n\n# Install ANTA in editable mode and its development tools\n$ pip install -e .[dev]\n\n# Verify installation\n$ pip list -e\nPackage Version Editable project location\n------- ------- -------------------------\nanta    0.6.0   /mnt/lab/projects/anta\n</code></pre> <p>Then, <code>tox</code> is configued with few environments to run CI locally:</p> <pre><code>$ tox list -d\ndefault environments:\nclean  -&gt; Erase previous coverage reports\nlint   -&gt; Check the code style\ntype   -&gt; Check typing\npy38   -&gt; Run pytest with py38\npy39   -&gt; Run pytest with py39\npy310  -&gt; Run pytest with py310\npy311  -&gt; Run pytest with py311\nreport -&gt; Generate coverage report\n</code></pre>"},{"location":"contribution/#code-linting","title":"Code linting","text":"<pre><code>tox -e lint\n[...]\nlint: commands[0]&gt; black --check --diff --color .\nAll done! \u2728 \ud83c\udf70 \u2728\n104 files would be left unchanged.\nlint: commands[1]&gt; isort --check --diff --color .\nSkipped 7 files\nlint: commands[2]&gt; flake8 --max-line-length=165 --config=/dev/null anta\nlint: commands[3]&gt; flake8 --max-line-length=165 --config=/dev/null tests\nlint: commands[4]&gt; pylint anta\n\n--------------------------------------------------------------------\nYour code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)\n\n.pkg: _exit&gt; python /Users/guillaumemulocher/.pyenv/versions/3.8.13/envs/anta/lib/python3.8/site-packages/pyproject_api/_backend.py True setuptools.build_meta\n  lint: OK (19.26=setup[5.83]+cmd[1.50,0.76,1.19,1.20,8.77] seconds)\ncongratulations :) (19.56 seconds)\n</code></pre>"},{"location":"contribution/#code-typing","title":"Code Typing","text":"<pre><code>tox -e type\n\n[...]\ntype: commands[0]&gt; mypy --config-file=pyproject.toml anta\nSuccess: no issues found in 52 source files\n.pkg: _exit&gt; python /Users/guillaumemulocher/.pyenv/versions/3.8.13/envs/anta/lib/python3.8/site-packages/pyproject_api/_backend.py True setuptools.build_meta\n  type: OK (46.66=setup[24.20]+cmd[22.46] seconds)\ncongratulations :) (47.01 seconds)\n</code></pre> <p>NOTE: Typing is configured quite strictly, do not hesitate to reach out if you have any questions, struggles, nightmares.</p>"},{"location":"contribution/#unit-tests","title":"Unit tests","text":"<p>To keep high quality code, we require to provide a Pytest for every tests implemented in ANTA.</p> <p>All submodule should have its own pytest section under <code>tests/units/anta_tests/&lt;submodule-name&gt;</code>. In this directory, you should have 3 files:</p> <ul> <li><code>__init__.py</code>: Just because it is used as a python module</li> <li><code>data.py</code>: Where all your parametrize go. So all your test information should be located here</li> <li><code>test_exc.py</code>: Pytest file with test definition.</li> </ul> <p>A pytest definition should be similar to this template:</p> <pre><code>\"\"\"\nTests for anta.tests.hardware.py\n\"\"\"\nfrom __future__ import annotations\n\nimport asyncio\nimport logging\nfrom typing import Any\nfrom unittest.mock import MagicMock\n\nimport pytest\n\nfrom anta.tests.hardware import VerifyAdverseDrops\nfrom tests.lib.utils import generate_test_ids_list\n\nfrom .data import INPUT_&lt;TEST_NAME&gt;\n\n@pytest.mark.parametrize(\"test_data\", INPUT_&lt;TEST_NAME&gt;, ids=generate_test_ids_list(INPUT_&lt;TEST_NAME&gt;))\ndef test_&lt;TEST_CASE&gt;(mocked_device: MagicMock, test_data: Any) -&gt; None:\n\"\"\"Check &lt;TEST_CASE&gt;.\"\"\"\n\n    test = &lt;TEST_CASE&gt;(mocked_device, eos_data=test_data[\"eos_data\"])\n    asyncio.run(test.test())\n\n    logging.debug(f\"test result is: {test.result}\")\n\n    assert str(test.result.name) == mocked_device.name\n    assert test.result.result == test_data[\"expected_result\"]\n</code></pre> <p>The <code>mocked_device</code> object is a fixture defined in Pytest to represent an InventoryDevice and the parametrize <code>test_data</code> is a list of dictionries with structure:</p> <pre><code>INPUT_RUNNING_CONFIG: List[Dict[str, Any]] = [\n  # Test Case #1\n    {\n        \"name\": \"failure\",\n        \"eos_data\": [\"blah blah\"],\n        \"side_effect\": None,\n        \"expected_result\": \"failure\",\n        \"expected_messages\": [\"blah blah\"]\n    },\n    # Test Case #2\n    {\n      ...\n    },\n]\n</code></pre> <p>Where we have:</p> <ul> <li><code>name</code>: Name of the test displayed by Pytest</li> <li><code>eos_data</code>: a list of data coming from EOS.</li> <li><code>side_effect</code>: used to inject template and test parameters (look for some examples in the existing tests)</li> <li><code>expected_result</code>: Result we expect for this test</li> <li><code>expected_messages</code>: Optional messages we expect for the test.</li> </ul> <p>Use Anta CLI to get test data</p> <p>To complete this block, you can use <code>anta debug</code> commands to get <code>AntaCommand</code> output to use in your test.</p>"},{"location":"contribution/#git-pre-commit-hook","title":"Git Pre-commit hook","text":"<pre><code>pip install pre-commit\npre-commit install\n</code></pre> <p>When running a commit or a pre-commit check:</p> <pre><code>\u276f echo \"import foobaz\" &gt; test.py &amp;&amp; git add test.py\n\u276f pre-commit\npylint...................................................................Failed\n- hook id: pylint\n- exit code: 22\n\n************* Module test\ntest.py:1:0: C0114: Missing module docstring (missing-module-docstring)\ntest.py:1:0: E0401: Unable to import 'foobaz' (import-error)\ntest.py:1:0: W0611: Unused import foobaz (unused-import)\n</code></pre> <p>NOTE: It could happen that pre-commit and tox disagree on something, in that case please open an issue on Github so we can take a look.. It is most probably wrong configuration on our side.</p>"},{"location":"contribution/#documentation","title":"Documentation","text":"<p><code>mkdocs</code> is used to generate the documentation. A PR should always update the documentation to avoid documentation debt.</p>"},{"location":"contribution/#install-documentation-requirements","title":"Install documentation requirements","text":"<p>Run pip to install the documentation requirements from the root of the repo:</p> <pre><code>pip install -e .[doc]\n</code></pre>"},{"location":"contribution/#testing-documentation","title":"Testing documentation","text":"<p>You can then check locally the documentation using the following command from the root of the repo:</p> <pre><code>mkdocs serve\n</code></pre> <p>By default, <code>mkdocs</code> listens to http://127.0.0.1:8000/, if you need to expose the documentation to another IP or port (for instance all IPs on port 8080), use the following command:</p> <pre><code>mkdocs serve --dev-addr=0.0.0.0:8080\n</code></pre>"},{"location":"contribution/#checking-links","title":"Checking links","text":"<p>Writing documentation is crucial but managing links can be cumbersome. To be sure there is no dead links, you can use <code>muffet</code> with the following command:</p> <pre><code>muffet -c 2 --color=always http://127.0.0.1:8000 -e fonts.gstatic.com\n</code></pre>"},{"location":"contribution/#continuous-integration","title":"Continuous Integration","text":"<p>GitHub actions is used to test git pushes and pull requests. The workflows are defined in this directory. We can view the results here.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":"<p>This section shows how to use ANTA with basic configuration. All examples are based on Arista Test Drive (ATD) topology you can access by reaching out to your prefered SE.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>The easiest way to intall ANTA package is to run Python (<code>&gt;=3.8</code>) and its pip package to install:</p> <pre><code>pip install anta\n</code></pre> <p>For more details about how to install package, please see the requirements and intallation section.</p>"},{"location":"getting-started/#configure-arista-eos-devices","title":"Configure Arista EOS devices","text":"<p>For ANTA to be able to connect to your target devices, you need to configure your management interface</p> <pre><code>vrf instance MGMT\n!\ninterface Management0\n   description oob_management\n   vrf MGMT\n   ip address 192.168.0.10/24\n!\n</code></pre> <p>Then, configure access to eAPI:</p> <pre><code>!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n   !\n!\n</code></pre>"},{"location":"getting-started/#create-your-inventory","title":"Create your inventory","text":"<p>ANTA uses an inventory to list the target devices for the tests. You can create a file manually with this format:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>You can read more details about how to build your inventory here</p>"},{"location":"getting-started/#test-catalog","title":"Test Catalog","text":"<p>To test your network, ANTA relies on a test catalog to list all the tests to run against your inventory. A test catalog references python functions into a yaml file.</p> <p>The structure to follow is like:</p> <pre><code>&lt;anta_tests_submodule&gt;:\n- &lt;anta_tests_submodule function name&gt;:\n&lt;test function option&gt;:\n&lt;test function option value&gt;\n</code></pre> <p>You can read more details about how to build your catalog here</p> <p>Here is an example for basic tests:</p> <pre><code># Load anta.tests.software\nanta.tests.software:\n- VerifyEOSVersion: # Verifies the device is running one of the allowed EOS version.\nversions: # List of allowed EOS versions.\n- 4.25.4M\n- 4.26.1F\n- '4.28.3M-28837868.4283M (engineering build)'\n- VerifyTerminAttrVersion:\nversions:\n- v1.22.1\n\nanta.tests.system:\n- VerifyUptime: # Verifies the device uptime is higher than a value.\nminimum: 1\n- VerifyNTP:\n- VerifySyslog:\n\nanta.tests.mlag:\n- VerifyMlagStatus:\n- VerifyMlagInterfaces:\n- VerifyMlagConfigSanity:\n\nanta.tests.configuration:\n- VerifyZeroTouch: # Verifies ZeroTouch is disabled.\n- VerifyRunningConfigDiffs:\n</code></pre>"},{"location":"getting-started/#test-your-network","title":"Test your network","text":"<p>ANTA comes with a generic CLI entrypoint to run tests in your network. It requires an inventory file as well as a test catalog.</p> <p>This entrypoint has multiple options to manage test coverage and reporting.</p> <pre><code># Generic ANTA options\n$ anta\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test Automation (ANTA) CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS  [env var:\n                                  ANTA_PASSWORD; required]\n--timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 5]\n--insecure                      Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE]\n--enable                        Add enable mode towards the devices if\nrequired to connect  [env var: ANTA_ENABLE]\n--enable-password TEXT          Enable password if required to connect,\n                                  --enable MUST be set  [env var:\n                                  ANTA_ENABLE_PASSWORD]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre> <pre><code># NRFU part of ANTA\n$ anta nrfu --help\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  -c, --catalog FILE  Path to the tests catalog YAML file  [env var:\n                      ANTA_NRFU_CATALOG; required]\n--help              Show this message and exit.\n\nCommands:\n  json        ANTA command to check network state with JSON result\n  table       ANTA command to check network states with table result\n  text        ANTA command to check network states with text result\n  tpl-report  ANTA command to check network state with templated report\n</code></pre> <p>Currently to be able to run <code>anta nrfu --help</code> you need to have given to ANTA the mandatory input parameters: username, password and inventory otherwise the CLI will report an issue. This is tracked in: https://github.com/arista-netdevops-community/anta/issues/263</p> <p>To run the NRFU, you need to select an output format amongst [\u201cjson\u201d, \u201ctable\u201d, \u201ctext\u201d, \u201ctpl-report\u201d]. For a first usage, <code>table</code> is recommended.  By default all test results for all devices are rendered but it can be changed to a report per test case or per host</p>"},{"location":"getting-started/#default-report-using-table","title":"Default report using table","text":"<pre><code>anta \\\n--username tom \\\n--password arista123 \\\n--enable \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu --catalog .personal/tests-bases.yml table --tags leaf\n\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running ANTA tests:                                  \u2502\n\u2502 - ANTA Inventory contains 6 devices (AsyncEOSDevice) \u2502\n\u2502 - Tests catalog contains 10 tests                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[10:17:24] INFO     Running ANTA tests...                                                                                                           runner.py:75\n  \u2022 Running NRFU Tests...100% \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 40/40 \u2022 0:00:02 \u2022 0:00:00\n\n                                                                       All tests results                                                                        \n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Device IP \u2503 Test Name                \u2503 Test Status \u2503 Message(s)       \u2503 Test description                                                     \u2503 Test category \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 leaf01    \u2502 VerifyEOSVersion         \u2502 success     \u2502                  \u2502 Verifies the device is running one of the allowed EOS version.       \u2502 software      \u2502\n\u2502 leaf01    \u2502 VerifyTerminAttrVersion  \u2502 success     \u2502                  \u2502 Verifies the device is running one of the allowed TerminAttr         \u2502 software      \u2502\n\u2502           \u2502                          \u2502             \u2502                  \u2502 version.                                                             \u2502               \u2502\n\u2502 leaf01    \u2502 VerifyUptime             \u2502 success     \u2502                  \u2502 Verifies the device uptime is higher than a value.                   \u2502 system        \u2502\n\u2502 leaf01    \u2502 VerifyNTP                \u2502 success     \u2502                  \u2502 Verifies NTP is synchronised.                                        \u2502 system        \u2502\n\u2502 leaf01    \u2502 VerifySyslog             \u2502 success     \u2502                  \u2502 Verifies the device had no syslog message with a severity of warning \u2502 system        \u2502\n\u2502           \u2502                          \u2502             \u2502                  \u2502 (or a more severe message) during the last 7 days.                   \u2502               \u2502\n\u2502 leaf01    \u2502 VerifyMlagStatus         \u2502 skipped     \u2502 MLAG is disabled \u2502 This test verifies the health status of the MLAG configuration.      \u2502 mlag          \u2502\n\u2502 leaf01    \u2502 VerifyMlagInterfaces     \u2502 skipped     \u2502 MLAG is disabled \u2502 This test verifies there are no inactive or active-partial MLAG      \u2502 mlag          \u2502\n[...]\n\u2502 leaf04    \u2502 VerifyMlagConfigSanity   \u2502 skipped     \u2502 MLAG is disabled \u2502 This test verifies there are no MLAG config-sanity inconsistencies.  \u2502 mlag          \u2502\n\u2502 leaf04    \u2502 VerifyZeroTouch          \u2502 success     \u2502                  \u2502 Verifies ZeroTouch is disabled.                                      \u2502 configuration \u2502\n\u2502 leaf04    \u2502 VerifyRunningConfigDiffs \u2502 success     \u2502                  \u2502                                                                      \u2502 configuration \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/#report-in-text-mode","title":"Report in text mode","text":"<pre><code>$ anta \\\n--username tom \\\n--password arista123 \\\n--enable \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu --catalog .personal/tests-bases.yml text --tags leaf\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running ANTA tests:                                  \u2502\n\u2502 - ANTA Inventory contains 6 devices (AsyncEOSDevice) \u2502\n\u2502 - Tests catalog contains 10 tests                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[10:20:47] INFO     Running ANTA tests...                                                                                                           runner.py:75\n  \u2022 Running NRFU Tests...100% \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 40/40 \u2022 0:00:01 \u2022 0:00:00\nleaf01 :: VerifyEOSVersion :: SUCCESS\nleaf01 :: VerifyTerminAttrVersion :: SUCCESS\nleaf01 :: VerifyUptime :: SUCCESS\nleaf01 :: VerifyNTP :: SUCCESS\nleaf01 :: VerifySyslog :: SUCCESS\nleaf01 :: VerifyMlagStatus :: SKIPPED (MLAG is disabled)\nleaf01 :: VerifyMlagInterfaces :: SKIPPED (MLAG is disabled)\nleaf01 :: VerifyMlagConfigSanity :: SKIPPED (MLAG is disabled)\n[...]\n</code></pre>"},{"location":"getting-started/#report-per-host","title":"Report per host","text":"<pre><code>$ anta \\\n--username tom \\\n--password arista123 \\\n--enable \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu --catalog .personal/tests-bases.yml json --tags leaf\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running ANTA tests:                                  \u2502\n\u2502 - ANTA Inventory contains 6 devices (AsyncEOSDevice) \u2502\n\u2502 - Tests catalog contains 10 tests                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[10:21:51] INFO     Running ANTA tests...                                                                                                           runner.py:75\n  \u2022 Running NRFU Tests...100% \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 40/40 \u2022 0:00:02 \u2022 0:00:00\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 JSON results of all tests                                                                                                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[\n{\n\"name\": \"leaf01\",\n    \"test\": \"VerifyEOSVersion\",\n    \"categories\": [\n\"software\"\n],\n    \"description\": \"Verifies the device is running one of the allowed EOS version.\",\n    \"result\": \"success\",\n    \"messages\": [],\n    \"custom_field\": \"None\",\n  },\n  {\n\"name\": \"leaf01\",\n    \"test\": \"VerifyTerminAttrVersion\",\n    \"categories\": [\n\"software\"\n],\n    \"description\": \"Verifies the device is running one of the allowed TerminAttr version.\",\n    \"result\": \"success\",\n    \"messages\": [],\n    \"custom_field\": \"None\",\n  },\n[...]\n]\n</code></pre> <p>You can find more information under the usage section of the website</p>"},{"location":"requirements-and-installation/","title":"Installation","text":""},{"location":"requirements-and-installation/#anta-requirements","title":"ANTA Requirements","text":""},{"location":"requirements-and-installation/#python-version","title":"Python version","text":"<p>Python 3 (<code>&gt;=3.8</code>) is required:</p> <pre><code>python --version\nPython 3.9.9\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-package","title":"Install ANTA package","text":"<p>This installation will deploy tests collection, scripts and all their Python requirements.</p> <p>The ANTA package and the cli require some packages that are not part of the Python standard library. They are indicated in the pyproject.toml file, under dependencies.</p>"},{"location":"requirements-and-installation/#install-from-pypi-server","title":"Install from Pypi server","text":"<pre><code>pip install anta\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-from-github","title":"Install ANTA from github","text":"<pre><code>pip install git+https://github.com/arista-netdevops-community/anta.git\n\n# You can even specify the branch, tag or commit:\npip install git+https://github.com/arista-netdevops-community/anta.git@&lt;cool-feature-branch&gt;\npip install git+https://github.com/arista-netdevops-community/anta.git@&lt;cool-tag&gt;\npip install git+https://github.com/arista-netdevops-community/anta.git@&lt;more-or-less-cool-hash&gt;\n</code></pre>"},{"location":"requirements-and-installation/#check-installation","title":"Check installation","text":"<p>Run these commands to verify:</p> <pre><code># Check ANTA has been installed in your python path\npip list | grep anta\n\n# Check scripts are in your $PATH\n# Path may differ but it means CLI is in your path\nwhich anta\n/home/tom/.pyenv/shims/anta\n\n# Chck ANTA version\nanta --version\nanta, version v0.6.0\n</code></pre>"},{"location":"requirements-and-installation/#eos-requirements","title":"EOS Requirements","text":"<p>To get ANTA working, the targetted Arista EOS devices must have the following configuration (assuming you connect to the device using Management interface in MGMT VRF):</p> <pre><code>configure\n!\nvrf instance MGMT\n!\ninterface Management1\n   description oob_management\n   vrf MGMT\n   ip address 10.73.1.105/24\n!\nend\n</code></pre> <p>Enable eAPI on the MGMT vrf:</p> <pre><code>configure\n!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n!\nend\n</code></pre> <p>Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands.</p> <p>Run these EOS commands to verify:</p> <pre><code>show management http-server\nshow management api http-commands\n</code></pre>"},{"location":"usage-inventory-catalog/","title":"Inventory & Tests catalog","text":""},{"location":"usage-inventory-catalog/#inventory-and-catalog-definition","title":"Inventory and Catalog definition","text":"<p>This page describes how to create an inventory and a tests catalog.</p>"},{"location":"usage-inventory-catalog/#create-an-inventory-file","title":"Create an inventory file","text":"<p><code>anta</code> cli needs an inventory file to list all devices to tests. This inventory is a YAML file with the folowing keys:</p> <pre><code>anta_inventory:\nhosts:\n- host: &lt; ip address value &gt;\nport: &lt; TCP port for eAPI. Default is 443 (Optional)&gt;\nname: &lt; name to display in report. Default is host:port (Optional) &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nnetworks:\n- network: &lt; network using CIDR notation &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nranges:\n- start: &lt; first ip address value of the range &gt;\nend: &lt; last ip address value of the range &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\n</code></pre> <p>Your inventory file can be based on any of these 3 keys and MUST start with <code>anta_inventory</code> key. A full description of the inventory model is available in API documentation</p> <p>An inventory example:</p> <pre><code>---\nanta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\nnetworks:\n- network: '192.168.110.0/24'\ntags: ['fabric', 'leaf']\nranges:\n- start: 10.0.0.9\nend: 10.0.0.11\ntags: ['fabric', 'l2leaf']\n</code></pre>"},{"location":"usage-inventory-catalog/#test-catalog","title":"Test Catalog","text":"<p>In addition to your inventory file, you also have to define a catalog of tests to execute against all your devices. This catalog list all your tests and their parameters. Its format is a YAML file and keys are tests functions inherited from the python path.</p>"},{"location":"usage-inventory-catalog/#default-tests-catalog","title":"Default tests catalog","text":"<p>All tests are located under <code>anta.tests</code> module and are categorised per family (one submodule). So to run test for software version, you can do:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n</code></pre> <p>It will load the test <code>VerifyEosVersion</code> located in <code>anta.tests.software</code>. But since this function has parameters, we will create a catalog with the following structure:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n</code></pre> <p>To get a list of all available tests and their respective parameters, you can read the tests section of this website.</p> <p>The following example gives a very minimal tests catalog you can use in almost any situation</p> <pre><code>---\n# Load anta.tests.software\nanta.tests.software:\n# Verifies the device is running one of the allowed EOS version.\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n\n# Load anta.tests.system\nanta.tests.system:\n# Verifies the device uptime is higher than a value.\n- VerifyUptime:\nminimum: 1\n\n# Load anta.tests.configuration\nanta.tests.configuration:\n# Verifies ZeroTouch is disabled.\n- VerifyZeroTouch:\n- VerifyRunningConfigDiffs:\n</code></pre>"},{"location":"usage-inventory-catalog/#catalog-with-antatemplate","title":"Catalog with AntaTemplate","text":"<p>If your test is based on <code>AntaTemplate</code>, you have to provide inputs for EOS CLI template by using <code>template_params</code> list:</p> <pre><code>anta.tests.routing.bgp:\n- VerifyBGPIPv4UnicastCount:\nnumber: 3\ntemplate_params:\n- vrf: default\n- vrf: customer-01\n</code></pre> <p>Which is required for the following test definition:</p> <pre><code>class VerifyBGPIPv4UnicastCount(AntaTest):\n\"\"\"\n    ...\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastCount\"\n    description = \"...\"\n    categories = [\"routing\", \"bgp\"]\n    template = AntaTemplate(template=\"show bgp ipv4 unicast summary vrf {vrf}\")\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n        pass\n</code></pre> <p>If you need to run the same test but with a different number of neighbors, you can write it as follow:</p> <pre><code>anta.tests.routing.bgp:\n- VerifyBGPIPv4UnicastCount:\nnumber: 2\ntemplate_params:\n- vrf: default\nanta.tests.routing.bgp:\n- VerifyBGPIPv4UnicastCount:\nnumber: 3\ntemplate_params:\n- vrf: customer-01\n</code></pre>"},{"location":"usage-inventory-catalog/#custom-tests-catalog","title":"Custom tests catalog","text":"<p>In case you want to leverage your own tests collection, you can use the following syntax:</p> <pre><code>&lt;your package name&gt;:\n- &lt;your test in your package name&gt;:\n</code></pre> <p>So for instance, it could be:</p> <pre><code>titom73.tests.system:\n- VerifyPlatform:\ntype: ['cEOS-LAB']\n</code></pre> <p>How to create custom tests</p> <p>To create your custom tests, you should refer to this following documentation</p>"},{"location":"usage-inventory-catalog/#customize-test-description-and-categories","title":"Customize test description and categories","text":"<p>It might be interesting to use your own categories and customized test description to build a better report for your environment. ANTA comes with a handy feature to define your own <code>categories</code> and <code>description</code> in the report.</p> <p>In your test catalog, use <code>result_overwrite</code> dictionary with <code>categories</code> and <code>description</code> to just overwrite this values in your report:</p> <pre><code>anta.tests.configuration:\n- VerifyZeroTouch: # Verifies ZeroTouch is disabled.\nresult_overwrite:\ncategories: ['demo', 'pr296']\ndescription: A custom test\n- VerifyRunningConfigDiffs:\nanta.tests.interfaces:\n- VerifyInterfaceUtilization:\n</code></pre> <p>Once you run <code>anta nrfu table</code>, you will see following output:</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Device IP \u2503 Test Name                  \u2503 Test Status \u2503 Message(s) \u2503 Test description                              \u2503 Test category \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 spine01   \u2502 VerifyZeroTouch            \u2502 success     \u2502            \u2502 A custom test                                 \u2502 demo, pr296   \u2502\n\u2502 spine01   \u2502 VerifyRunningConfigDiffs   \u2502 success     \u2502            \u2502                                               \u2502 configuration \u2502\n\u2502 spine01   \u2502 VerifyInterfaceUtilization \u2502 success     \u2502            \u2502 Verifies interfaces utilization is below 75%. \u2502 interfaces    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced_usages/as-python-lib/","title":"ANTA as a Python Library","text":"<p>ANTA is a Python library that can be used in user applications. This section describes how you can leverage ANTA Python modules to help you create your own NRFU solution.</p> <p>Tip</p> <p>If you are unfamiliar with asyncio, refer to the Python documentation relevant to your Python version - https://docs.python.org/3/library/asyncio.html</p>"},{"location":"advanced_usages/as-python-lib/#antadevice-abstract-class","title":"AntaDevice Abstract Class","text":"<p>A device is represented in ANTA as a instance of a subclass of the AntaDevice abstract class. There are few abstract methods that needs to be implemented by child classes:</p> <ul> <li>The collect() coroutine is in charge of collecting outputs of AntaCommand instances.</li> <li>The refresh() coroutine is in charge of updating attributes of the AntaDevice instance. These attributes are used by AntaInventory to filter out unreachable devices or by AntaTest to skip devices based on their hardware models.</li> </ul> <p>The copy() coroutine is used to copy files to and from the device. It does not need to be implemented if tests are not using it.</p>"},{"location":"advanced_usages/as-python-lib/#asynceosdevice-class","title":"AsyncEOSDevice Class","text":"<p>The AsyncEOSDevice class is an implementation of AntaDevice for Arista EOS. It uses the aio-eapi eAPI client and the AsyncSSH library.</p> <ul> <li>The collect() coroutine collects AntaCommand outputs using eAPI.</li> <li>The refresh() coroutine tries to open a TCP connection on the eAPI port and update the <code>is_online</code> attribute accordingly. If the TCP connection succeeds, it sends a <code>show version</code> command to gather the hardware model of the device and updates the <code>established</code> and <code>hw_model</code> attributes.</li> <li>The copy() coroutine copies files to and from the device using the SCP protocol.</li> </ul>"},{"location":"advanced_usages/as-python-lib/#antainventory-class","title":"AntaInventory Class","text":"<p>The AntaInventory class is a subclass of the standard Python type dict. The keys of this dictionary are the device names, the values are AntaDevice instances.</p> <p>AntaInventory provides methods to interact with the ANTA inventory:</p> <ul> <li>The add_device() method adds an AntaDevice instance to the inventory. Adding an entry to AntaInventory with a key different from the device name is not allowed.</li> <li>The get_inventory() returns a new AntaInventory instance with filtered out devices based on the method inputs.</li> <li>The connect_inventory() coroutine will execute the refresh() coroutines of all the devices in the inventory.</li> <li>The parse() static method creates an AntaInventory instance from a YAML file and returns it. The devices are AsyncEOSDevice instances.</li> </ul> <p>To parse a YAML inventory file and print the devices connection status:</p> <pre><code>\"\"\"\nExample\n\"\"\"\nimport asyncio\n\nfrom anta.inventory import AntaInventory\n\n\nasync def main(inv: AntaInventory) -&gt; None:\n\"\"\"\n    Take an AntaInventory and:\n    1. try to connect to every device in the inventory\n    2. print a message for every device connection status\n    \"\"\"\n    await inv.connect_inventory()\n\n    for device in inv.values():\n        if device.established:\n            print(f\"Device {device.name} is online\")\n        else:\n            print(f\"Could not connect to device {device.name}\")\n\nif __name__ == \"__main__\":\n    # Create the AntaInventory instance\n    inventory = AntaInventory.parse(\n        inventory_file=\"inv.yml\",\n        username=\"arista\",\n        password=\"@rista123\",\n        timeout=15,\n    )\n\n    # Run the main coroutine\n    res = asyncio.run(main(inventory))\n</code></pre> How to create your inventory file <p>Please visit this dedicated section for how to use inventory and catalog files.</p> <p>To run an EOS commands list on the reachable devices from the inventory: <pre><code>\"\"\"\nExample\n\"\"\"\n# This is needed to run the script for python &lt; 3.10 for typing annotations\nfrom __future__ import annotations\n\nimport asyncio\nfrom pprint import pprint\n\nfrom anta.inventory import AntaInventory\nfrom anta.models import AntaCommand\n\n\nasync def main(inv: AntaInventory, commands: list[str]) -&gt; dict[str, list[AntaCommand]]:\n\"\"\"\n    Take an AntaInventory and a list of commands as string and:\n    1. try to connect to every device in the inventory\n    2. collect the results of the commands from each device\n\n    Returns:\n      a dictionary where key is the device name and the value is the list of AntaCommand ran towards the device\n    \"\"\"\n    await inv.connect_inventory()\n\n    # Make a list of coroutine to run commands towards each connected device\n    coros = []\n    # dict to keep track of the commands per device\n    result_dict = {}\n    for name, device in inv.get_inventory(established_only=True).items():\n        anta_commands = [AntaCommand(command=command, ofmt=\"json\") for command in commands]\n        result_dict[name] = anta_commands\n        coros.append(device.collect_commands(anta_commands))\n\n    # Run the coroutines\n    await asyncio.gather(*coros)\n\n    return result_dict\n\n\nif __name__ == \"__main__\":\n    # Create the AntaInventory instance\n    inventory = AntaInventory.parse(\n        inventory_file=\"inv.yml\",\n        username=\"arista\",\n        password=\"@rista123\",\n        timeout=15,\n    )\n\n    # Create a list of commands with json output\n    commands = [\"show version\", \"show ip bgp summary\"]\n\n    # Run the main asyncio  entry point\n    res = asyncio.run(main(inventory, commands))\n\n    pprint(res)\n</code></pre></p>"},{"location":"advanced_usages/as-python-lib/#use-tests-from-anta","title":"Use tests from ANTA","text":"<p>All the test classes inherit from the same abstract Base Class AntaTest. The Class definition indicates which commands are required for the test and the user should focus only on writing the <code>test</code> function with optional keywords argument. The instance of the class upon creation instantiates a TestResult object that can be accessed later on to check the status of the test ([unset, skipped, success, failure, error]).</p>"},{"location":"advanced_usages/as-python-lib/#test-structure","title":"Test structure","text":"<p>All tests are built on a class named <code>AntaTest</code> which provides a complete toolset for a test:</p> <ul> <li>Object creation</li> <li>Test definition</li> <li>TestResult definition</li> <li>Abstracted method to collect data</li> </ul> <p>This approach means each time you create a test it will be based on this <code>AntaTest</code> class. Besides that, you will have to provide some elements:</p> <ul> <li><code>name</code>: Name of the test</li> <li><code>description</code>: A human readable description of your test</li> <li><code>categories</code>: a list of categories to sort test.</li> <li><code>commands</code>: a list of command to run. This list must be a list of <code>AntaCommand</code> which is described in the next part of this document.</li> </ul> <p>Here is an example of a hardware test related to device temperature:</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n\n    # The test name\n    name = \"VerifyTemperature\"\n    # A small description of the test, usually the first line of the class docstring\n    description = \"Verifies device temparture is currently OK\"\n    # The category of the test, usually the module name\n    categories = [\"hardware\"]\n    # The command(s) used for the test. Could be a template instead\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    # Decorator\n    @AntaTest.anta_test\n    # abstract method that must be defined by the child Test class\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre> <p>When you run the test, object will automatically call its <code>anta.models.AntaTest.collect()</code> method to get device output for each command if no pre-collected data was given to the test. This method does a loop to call <code>anta.inventory.models.InventoryDevice.collect()</code> methods which is in charge of managing device connection and how to get data.</p> run test offline <p>You can also pass eos data directly to your test if you want to validate data collected in a different workflow. An example is provided below just for information:</p> <pre><code>test = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\n</code></pre> <p>The <code>test</code> function is always the same and must be defined with the <code>@AntaTest.anta_test</code> decorator. This function takes at least one argument which is a <code>anta.inventory.models.InventoryDevice</code> object. In some cases a test would rely on some additional inputs from the user, for instance the number of expected peers or some expected numbers. All parameters must come with a default value and the test function should validate the parameters values (at this stage this is the only place where validation can be done but there are future plans to make this better).</p> <pre><code>class VerifyTemperature(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n\nclass VerifyTransceiversManufacturers(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n        # validate the manufactures parameter\n        pass\n</code></pre> <p>The test itself does not return any value, but the result is directly availble from your AntaTest object and exposes a <code>anta.result_manager.models.TestResult</code> object with result, name of the test and optional messages:</p> <ul> <li><code>name</code> (str): Device name where the test has run.</li> <li><code>test</code> (str): Test name runs on the device.</li> <li><code>categories</code> (List[str]): List of categories the TestResult belongs to, by default the AntaTest categories.</li> <li><code>description</code> (str): TestResult description, by default the AntaTest description.</li> <li><code>results</code> (str): Result of the test. Can be one of [\u201cunset\u201d, \u201csuccess\u201d, \u201cfailure\u201d, \u201cerror\u201d, \u201cskipped\u201d].</li> <li><code>message</code> (str, optional): Message to report after the test if any.</li> <li><code>custom_field</code> (str, optional): Custom field to store a string for flexibility in integrating with ANTA</li> </ul> <pre><code>from anta.tests.hardware import VerifyTemperature\n\ntest = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\nassert test.result.result == \"success\"\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#commands-for-test","title":"Commands for test","text":"<p>To make it easier to get data, ANTA defines 2 different classes to manage commands to send to device:</p>"},{"location":"advanced_usages/as-python-lib/#antamodelsantacommand","title":"<code>anta.models.AntaCommand</code>","text":"<p>Abstract a command with following information:</p> <ul> <li>Command to run,</li> <li>Ouput format expected</li> <li>eAPI version</li> <li>Output of the command</li> </ul> <p>Usage example:</p> <pre><code>from anta.models import AntaCommand\n\ncmd1 = AntaCommand(command=\"show zerotouch\")\ncmd2 = AntaCommand(command=\"show running-config diffs\", ofmt=\"text\")\n</code></pre> <p>Command revision and version</p> <ul> <li>Most of EOS commands return a JSON structure according to a model (some commands may not be modeled hence the necessity to use <code>text</code> outformat sometimes.</li> <li>The model can change across time (adding feature, \u2026 ) and when the model is changed in a non backward-compatible way, the revision number is bumped. The initial model starts with revision 1.</li> <li>A revision applies to a particular CLI command whereas a version is global to an eAPI call. The version is internally translated to a specific revision for each CLI command in the RPC call. The currently supported version vaues  are <code>1</code> and <code>latest</code>.</li> <li>A revision takes precedence over a version (e.g. if a command is run with version=\u201dlatest\u201d and revision=1, the first revision of the model is returned)</li> <li>By default eAPI returns the first revision of each model to ensure that when upgrading, intergation with existing tools is not broken. This is done by using by default <code>version=1</code> in eAPI calls.</li> </ul> <p>ANTA uses by default <code>version=\"latest\"</code> in AntaCommand. For some commands, you may want to run them with a different revision or version. </p> <p>For instance the <code>VerifyRoutingTableSize</code> test leverages the first revision of <code>show bfd peers</code>:</p> <pre><code># revision 1 as later revision introduce additional nesting for type\ncommands = [AntaCommand(command=\"show bfd peers\", revision=1)]\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#antamodelsantatemplate","title":"<code>anta.models.AntaTemplate</code>","text":"<p>Because some command can require more dynamic than just a command with no parameter provided by user, ANTA supports command template: you define a template in your test class and user provide parameters when creating test object.</p> <p>Warning on AntaTemplate</p> <ul> <li>In its current versiom, an AntaTest class supports only ONE AntaTemplate.</li> <li>The current interface to pass template parameter to a template is an area of future improvements. Feedbacks are welcome.</li> </ul> <pre><code>class RunArbitraryTemplateCommand(AntaTest):\n\"\"\"\n    Run an EOS command and return result\n    Based on AntaTest to build relevant output for pytest\n    \"\"\"\n\n    name = \"Run aributrary EOS command\"\n    description = \"To be used only with anta debug commands\"\n    template = AntaTemplate(template=\"show interfaces {ifd}\")\n    categories = [\"debug\"]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        errdisabled_interfaces = [interface for interface, value in response[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n        ...\n\n\nparams = [{\"ifd\": \"Ethernet2\"}, {\"ifd\": \"Ethernet49/1\"}]\nrun_command1 = RunArbitraryTemplateCommand(device_anta, params)\n</code></pre> <p>In this example, test waits for interfaces to check from user setup and will only check for interfaces in <code>params</code></p>"},{"location":"advanced_usages/custom-tests/","title":"Create your own Library","text":""},{"location":"advanced_usages/custom-tests/#create-your-own-custom-tests","title":"Create your own custom tests","text":"<p>This documentation applies for both create tests in ANTA package or your custom package.</p> <p>ANTA is not only a CLI with a collection of built-in tests, it is also a framework you can extend by building your own tests library.</p> <p>For that, you need to create your own Python package as described in this hitchhiker\u2019s guide to package Python code. We assume it is well known and we won\u2019t focus on this aspect. Thus, your package must be impartable by ANTA hence available in <code>$PYTHONPATH</code> by any method.</p>"},{"location":"advanced_usages/custom-tests/#generic-approach","title":"Generic approach","text":"<p>ANTA comes with a class to use to build test. This class provides all the toolset required to define, collect and test data. The next code is an example of how to use ANTA to build a test</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"advanced_usages/custom-tests/#python-imports","title":"Python imports","text":""},{"location":"advanced_usages/custom-tests/#mandatory-imports","title":"Mandatory imports","text":"<p>The following elements have to be imported:</p> <ul> <li>anta.models.AntaTest: class that gives you all the tooling for your test</li> <li>anta.models.AntaCommand: A class to abstract an Arista EOS command</li> </ul> <pre><code>from anta.models import AntaTest, AntaCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n    ...\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#optional-anta-imports","title":"Optional ANTA imports","text":"<p>Besides these 3 main imports, anta provides some additional and optional decorators:</p> <ul> <li><code>anta.decorators.skip_on_platforms</code>: To skip a test for a function not available for some platform</li> <li><code>anta.decorators.check_bgp_family_enable</code>: To run tests only if specific BGP family is active.</li> </ul> <pre><code>from anta.decorators import skip_on_platforms\n\n\nclass VerifyTransceiversManufacturers(AntaTest):\n    ...\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#optional-python-imports","title":"Optional python imports","text":"<p>And finally, you are free to import any other python library you may want to use in your package.</p> <p>logging function</p> <p>It is strongly recommended to import <code>logging</code> to help development process and being able to log some outputs usefull for test development.</p> <p>If your test development is part of a pull request for ANTA, it is stringly advised to also import <code>typing</code> since our code testing requires to be compatible with Mypy.</p>"},{"location":"advanced_usages/custom-tests/#code-for-a-test","title":"Code for a test","text":"<p>A test is a python class where a test function is defined and will be run by the framework. So first you need to declare your class and then define your test function.</p>"},{"location":"advanced_usages/custom-tests/#create-test-class","title":"Create Test Class","text":"<p>To create class, you have to provide 4 elements:</p> <p>Metadata information</p> <ul> <li><code>name</code>: Name of the test</li> <li><code>description</code>: A human readable description of your test</li> <li><code>categories</code>: a list of categories to sort test.</li> </ul> <p>Commands to run</p> <ul> <li><code>commands</code>: a list of command to run. This list must be a list of <code>AntaCommand</code> which is described in the next part of this document.</li> <li><code>template</code>: a command template (<code>AntaTemplate</code>) to run where variables are provided during test execution.</li> </ul> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaCommand\n\n\nclass &lt;YourTestName&gt;(AntaTest):\n\"\"\"\n    &lt;a docstring description of your test&gt;\n    \"\"\"\n\n    name = \"YourTestName\"                                           # should be your class name\n    description = \"&lt;test description in human reading format&gt;\"\n    categories = [\"&lt;a list of arbitrary categories&gt;\"]\n    commands = [\n        AntaCommand(\n            command=\"&lt;eos command to run&gt;\",\n            ofmt=\"&lt;command format output&gt;\",\n            version=\"&lt;eapi version to use&gt;\",\n            revision=\"&lt;revision to use for the command&gt;\",           # revision has precedence over version\n        )\n    ]\n</code></pre> <p>This class will inherit methods from AntaTest and specfically the <code>__init__(self,...)</code> method to build your object. This function takes following arguments when you instantiate an object:</p> <ul> <li><code>device (InventoryDevice)</code>: Device object where to test happens.</li> <li><code>template_params</code>: If template is used in the test definition, then we provide data to build list of commands.</li> <li><code>eos_data</code>: Potential EOS data to pass if we don\u2019t want to connect to device to grab data.</li> <li><code>labels</code>: a list of labels. It is not used yet and it is for futur use.</li> </ul>"},{"location":"advanced_usages/custom-tests/#function-definition","title":"Function definition","text":"<p>The code here can be very simple as well as very complex and will depend of what you expect to do. But in all situation, the same baseline can be leverage:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n</code></pre> <p>If you want to support option in your test, just declare your options in your test method:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self, my_param1: Optional[str] = None) -&gt; None:\n        pass\n</code></pre> <p>The options must be optional keyword arguments.</p>"},{"location":"advanced_usages/custom-tests/#check-inputs","title":"Check inputs","text":"<p>If your test has some user inputs, you first have to validate the supplied values are valid. If it is not valid, we expect <code>TestResult</code> to return <code>skipped</code> with a custom message.</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None) -&gt; None:\n        # Check if test option is correct\n        if not minimum:\n            self.result.is_skipped(\"verify_dynamic_vlan was run without minimum value set\")\n            return\n        # continue test..\n        ...\n</code></pre>"},{"location":"advanced_usages/custom-tests/#implement-your-logic","title":"Implement your logic","text":"<p>Here you implement your own logic. In general, the first action is to send command to devices and capture its response.</p> <p>In the example below, we request the list of vlans configured on device and then count all the vlans marked as dynamic</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None) -&gt; None:\n        # Check if test option is correct\n        if not minimum:\n            self.result.is_skipped(\"verify_dynamic_vlan was run without minimum value set\")\n            return\n\n        # Grab data for your command\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        # Do your test: In this example we count number of vlans with field dynamic set to true\n        num_dyn_vlan = len([ vlan for vlan,data in command_output['vlans'].items() if command_output['dynamic'] is True])\n        if num_dyn_vlan &gt;= minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device has {num_dyn_vlan} configured, we expect at least {minimum}\")\n</code></pre> <p>As you can see there is no error management to do in your code. Everything is packaged in <code>anta_tests</code> and below is a simple example of error captured with an incorrect JSON key in the code above:</p> <pre><code>ERROR    Exception raised for test verify_dynamic_vlan (on device 192.168.0.10) - KeyError ('vlans')\n</code></pre> <p>Get stack trace for debugging</p> <p>If you want to access to the full exception stack, you can run your test with logging level set to <code>DEBUG</code>. With ANTA cli, it is available with following option: <pre><code>$ ANTA_DEBUG=True anta nrfu text --catalog test_custom.yml --log-level debug\n</code></pre></p>"},{"location":"advanced_usages/custom-tests/#create-your-catalog","title":"Create your catalog","text":"<p>This section is required only if you are not merging your development into ANTA. Otherwise, just follow contribution guide.</p> <p>It is very similar to what is documented in catalog section but you have to use your own package name.</p> <p>Let say the custom catalog is <code>anta_titom73</code> and the test is configured in <code>anta_titom73.dc_project</code>, the test catalog would look like:</p> <p><pre><code>anta_titom73.dc_project:\n- VerifyFeatureX:\nminimum: 1\n</code></pre> And now you can run your NRFU tests with the CLI:</p> <pre><code>anta nrfu text --catalog test_custom.yml\nspine01 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nspine02 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nleaf01 :: verify_dynamic_vlan :: SUCCESS\nleaf02 :: verify_dynamic_vlan :: SUCCESS\nleaf03 :: verify_dynamic_vlan :: SUCCESS\nleaf04 :: verify_dynamic_vlan :: SUCCESS\n</code></pre> <p>Install your python package</p> <p>Anta uses Python path to access to your test. So it is critical to have your tests library installed correctly as explained at the begining of this page (in short, your module should be in your <code>PYTHONPATH</code> to be able to be loaded).</p>"},{"location":"api/device/","title":"Device models","text":""},{"location":"api/device/#anta.device.AntaDevice","title":"AntaDevice","text":"<pre><code>AntaDevice(name: str, tags: Optional[List[str]] = None)\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>Abstract class representing a device in ANTA. An implementation of this class needs must override the abstract coroutines <code>collect()</code> and <code>refresh()</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name</p> <code>is_online</code> <code>bool</code> <p>True if the device IP is reachable and a port can be open</p> <code>established</code> <code>bool</code> <p>True if remote command execution succeeds</p> <code>hw_model</code> <code>Optional[str]</code> <p>Hardware model of the device</p> <code>tags</code> <code>List[str]</code> <p>List of tags for this device</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Device name</p> required <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for this device</p> <code>None</code> Source code in <code>anta/device.py</code> <pre><code>def __init__(self, name: str, tags: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Constructor of AntaDevice\n\n    Args:\n        name: Device name\n        tags: List of tags for this device\n    \"\"\"\n    self.name: str = name\n    self.hw_model: Optional[str] = None\n    self.tags: List[str] = tags if tags is not None else []\n    self.is_online: bool = False\n    self.established: bool = False\n\n    # Ensure tag 'all' is always set\n    if DEFAULT_TAG not in self.tags:\n        self.tags.append(DEFAULT_TAG)\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.collect","title":"collect  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>collect(command: AntaCommand) -&gt; None\n</code></pre> <p>Collect device command output. This abstract coroutine can be used to implement any command collection method for a device in ANTA.</p> <p>The <code>collect()</code> implementation needs to populate the <code>output</code> attribute of the <code>AntaCommand</code> object passed as argument.</p> <p>If a failure occurs, the <code>collect()</code> implementation is expected to catch the exception and implement proper logging, the <code>output</code> attribute of the <code>AntaCommand</code> object passed as argument would be <code>None</code> in this case.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>AntaCommand</code> <p>the command to collect</p> required Source code in <code>anta/device.py</code> <pre><code>@abstractmethod\nasync def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n    Collect device command output.\n    This abstract coroutine can be used to implement any command collection method\n    for a device in ANTA.\n\n    The `collect()` implementation needs to populate the `output` attribute\n    of the `AntaCommand` object passed as argument.\n\n    If a failure occurs, the `collect()` implementation is expected to catch the\n    exception and implement proper logging, the `output` attribute of the\n    `AntaCommand` object passed as argument would be `None` in this case.\n\n    Args:\n        command: the command to collect\n    \"\"\"\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.collect_commands","title":"collect_commands  <code>async</code>","text":"<pre><code>collect_commands(commands: List[AntaCommand]) -&gt; None\n</code></pre> <p>Collect multiple commands.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[AntaCommand]</code> <p>the commands to collect</p> required Source code in <code>anta/device.py</code> <pre><code>async def collect_commands(self, commands: List[AntaCommand]) -&gt; None:\n\"\"\"\n    Collect multiple commands.\n\n    Args:\n        commands: the commands to collect\n    \"\"\"\n    await asyncio.gather(*(self.collect(command=command) for command in commands))\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.copy","title":"copy  <code>async</code>","text":"<pre><code>copy(sources: List[Path], destination: Path, direction: Literal['to', 'from'] = 'from') -&gt; None\n</code></pre> <p>Copy files to and from the device, usually through SCP. It is not mandatory to implement this for a valid AntaDevice subclass.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[Path]</code> <p>List of files to copy to or from the device.</p> required <code>destination</code> <code>Path</code> <p>Local or remote destination when copying the files. Can be a folder.</p> required <code>direction</code> <code>Literal['to', 'from']</code> <p>Defines if this coroutine copies files to or from the device.</p> <code>'from'</code> Source code in <code>anta/device.py</code> <pre><code>async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n    Copy files to and from the device, usually through SCP.\n    It is not mandatory to implement this for a valid AntaDevice subclass.\n\n    Args:\n        sources: List of files to copy to or from the device.\n        destination: Local or remote destination when copying the files. Can be a folder.\n        direction: Defines if this coroutine copies files to or from the device.\n    \"\"\"\n    raise NotImplementedError(f\"copy() method has not been implemented in {self.__class__.__name__} definition\")\n</code></pre>"},{"location":"api/device/#anta.device.AntaDevice.refresh","title":"refresh  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Update attributes of an AntaDevice instance.</p> This coroutine must update the following attributes of AntaDevice <ul> <li><code>is_online</code>: When the device IP is reachable and a port can be open</li> <li><code>established</code>: When a command execution succeeds</li> <li><code>hw_model</code>: The hardware model of the device</li> </ul> Source code in <code>anta/device.py</code> <pre><code>@abstractmethod\nasync def refresh(self) -&gt; None:\n\"\"\"\n    Update attributes of an AntaDevice instance.\n\n    This coroutine must update the following attributes of AntaDevice:\n        - `is_online`: When the device IP is reachable and a port can be open\n        - `established`: When a command execution succeeds\n        - `hw_model`: The hardware model of the device\n    \"\"\"\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice","title":"AsyncEOSDevice","text":"<pre><code>AsyncEOSDevice(host: str, username: str, password: str, name: Optional[str] = None, enable: bool = False, enable_password: Optional[str] = None, port: Optional[int] = None, ssh_port: Optional[int] = 22, tags: Optional[List[str]] = None, timeout: Optional[float] = None, insecure: bool = False, proto: Literal['http', 'https'] = 'https')\n</code></pre> <p>             Bases: <code>AntaDevice</code></p> <p>Implementation of AntaDevice for EOS using aio-eapi.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>Device name</p> <code>is_online</code> <p>True if the device IP is reachable and a port can be open</p> <code>established</code> <p>True if remote command execution succeeds</p> <code>hw_model</code> <p>Hardware model of the device</p> <code>tags</code> <p>List of tags for this device</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Device FQDN or IP</p> required <code>username</code> <code>str</code> <p>Username to connect to eAPI and SSH</p> required <code>password</code> <code>str</code> <p>Password to connect to eAPI and SSH</p> required <code>name</code> <code>Optional[str]</code> <p>Device name</p> <code>None</code> <code>enable</code> <code>bool</code> <p>Device needs privileged access</p> <code>False</code> <code>enable_password</code> <code>Optional[str]</code> <p>Password used to gain privileged access on EOS</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>eAPI port. Defaults to 80 is proto is \u2018http\u2019 or 443 if proto is \u2018https\u2019.</p> <code>None</code> <code>ssh_port</code> <code>Optional[int]</code> <p>SSH port</p> <code>22</code> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags for this device</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout value in seconds for outgoing connections. Default to 10 secs.</p> <code>None</code> <code>insecure</code> <code>bool</code> <p>Disable SSH Host Key validation</p> <code>False</code> <code>proto</code> <code>Literal['http', 'https']</code> <p>eAPI protocol. Value can be \u2018http\u2019 or \u2018https\u2019</p> <code>'https'</code> Source code in <code>anta/device.py</code> <pre><code>def __init__(  # pylint: disable=R0913\n    self,\n    host: str,\n    username: str,\n    password: str,\n    name: Optional[str] = None,\n    enable: bool = False,\n    enable_password: Optional[str] = None,\n    port: Optional[int] = None,\n    ssh_port: Optional[int] = 22,\n    tags: Optional[List[str]] = None,\n    timeout: Optional[float] = None,\n    insecure: bool = False,\n    proto: Literal[\"http\", \"https\"] = \"https\",\n) -&gt; None:\n\"\"\"\n    Constructor of AsyncEOSDevice\n\n    Args:\n        host: Device FQDN or IP\n        username: Username to connect to eAPI and SSH\n        password: Password to connect to eAPI and SSH\n        name: Device name\n        enable: Device needs privileged access\n        enable_password: Password used to gain privileged access on EOS\n        port: eAPI port. Defaults to 80 is proto is 'http' or 443 if proto is 'https'.\n        ssh_port: SSH port\n        tags: List of tags for this device\n        timeout: Timeout value in seconds for outgoing connections. Default to 10 secs.\n        insecure: Disable SSH Host Key validation\n        proto: eAPI protocol. Value can be 'http' or 'https'\n    \"\"\"\n    if name is None:\n        name = f\"{host}{f':{port}' if port else ''}\"\n    super().__init__(name, tags)\n    self.enable = enable\n    self._enable_password = enable_password\n    self._session: Device = Device(host=host, port=port, username=username, password=password, proto=proto, timeout=timeout)\n    ssh_params: Dict[str, Any] = {}\n    if insecure:\n        ssh_params.update({\"known_hosts\": None})\n    self._ssh_opts: SSHClientConnectionOptions = SSHClientConnectionOptions(host=host, port=ssh_port, username=username, password=password, **ssh_params)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.collect","title":"collect  <code>async</code>","text":"<pre><code>collect(command: AntaCommand) -&gt; None\n</code></pre> <p>Collect device command output from EOS using aio-eapi.</p> <p>Supports outformat <code>json</code> and <code>text</code> as output structure. Gain privileged access using the <code>enable_password</code> attribute of the <code>AntaDevice</code> instance if populated.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>AntaCommand</code> <p>the command to collect</p> required Source code in <code>anta/device.py</code> <pre><code>async def collect(self, command: AntaCommand) -&gt; None:\n\"\"\"\n    Collect device command output from EOS using aio-eapi.\n\n    Supports outformat `json` and `text` as output structure.\n    Gain privileged access using the `enable_password` attribute\n    of the `AntaDevice` instance if populated.\n\n    Args:\n        command: the command to collect\n    \"\"\"\n    try:\n        commands = []\n        if self.enable and self._enable_password is not None:\n            commands.append(\n                {\n                    \"cmd\": \"enable\",\n                    \"input\": str(self._enable_password),\n                }\n            )\n        elif self.enable:\n            # No password\n            commands.append({\"cmd\": \"enable\"})\n        if command.revision:\n            commands.append({\"cmd\": command.command, \"revision\": command.revision})\n        else:\n            commands.append({\"cmd\": command.command})\n        response = await self._session.cli(\n            commands=commands,\n            ofmt=command.ofmt,\n            version=command.version,\n        )\n        # remove first dict related to enable command\n        # only applicable to json output\n        if command.ofmt in [\"json\", \"text\"]:\n            # selecting only our command output\n            response = response[-1]\n        command.output = response\n        logger.debug(f\"{self.name}: {command}\")\n\n    except EapiCommandError as e:\n        message = f\"Command '{command.command}' failed on {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n    except (HTTPError, ConnectError) as e:\n        message = f\"Cannot connect to device {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        message = f\"Exception raised while collecting command '{command.command}' on device {self.name}\"\n        anta_log_exception(e, message, logger)\n        command.failed = e\n        logger.debug(command)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.copy","title":"copy  <code>async</code>","text":"<pre><code>copy(sources: List[Path], destination: Path, direction: Literal['to', 'from'] = 'from') -&gt; None\n</code></pre> <p>Copy files to and from the device using asyncssh.scp().</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[Path]</code> <p>List of files to copy to or from the device.</p> required <code>destination</code> <code>Path</code> <p>Local or remote destination when copying the files. Can be a folder.</p> required <code>direction</code> <code>Literal['to', 'from']</code> <p>Defines if this coroutine copies files to or from the device.</p> <code>'from'</code> Source code in <code>anta/device.py</code> <pre><code>async def copy(self, sources: List[Path], destination: Path, direction: Literal[\"to\", \"from\"] = \"from\") -&gt; None:\n\"\"\"\n    Copy files to and from the device using asyncssh.scp().\n\n    Args:\n        sources: List of files to copy to or from the device.\n        destination: Local or remote destination when copying the files. Can be a folder.\n        direction: Defines if this coroutine copies files to or from the device.\n    \"\"\"\n    async with asyncssh.connect(\n        host=self._ssh_opts.host,\n        port=self._ssh_opts.port,\n        tunnel=self._ssh_opts.tunnel,\n        family=self._ssh_opts.family,\n        local_addr=self._ssh_opts.local_addr,\n        options=self._ssh_opts,\n    ) as conn:\n        src: Union[List[Tuple[SSHClientConnection, Path]], List[Path]]\n        dst: Union[Tuple[SSHClientConnection, Path], Path]\n        if direction == \"from\":\n            src = [(conn, file) for file in sources]\n            dst = destination\n            for file in sources:\n                logger.info(f\"Copying '{file}' from device {self.name} to '{destination}' locally\")\n        elif direction == \"to\":\n            src = sources\n            dst = (conn, destination)\n            for file in sources:\n                logger.info(f\"Copying '{file}' to device {self.name} to '{destination}' remotely\")\n        else:\n            logger.critical(f\"'direction' argument to copy() fonction is invalid: {direction}\")\n            return\n        await asyncssh.scp(src, dst)\n</code></pre>"},{"location":"api/device/#anta.device.AsyncEOSDevice.refresh","title":"refresh  <code>async</code>","text":"<pre><code>refresh() -&gt; None\n</code></pre> <p>Update attributes of an AsyncEOSDevice instance.</p> <p>This coroutine must update the following attributes of AsyncEOSDevice: - is_online: When a device IP is reachable and a port can be open - established: When a command execution succeeds - hw_model: The hardware model of the device</p> Source code in <code>anta/device.py</code> <pre><code>async def refresh(self) -&gt; None:\n\"\"\"\n    Update attributes of an AsyncEOSDevice instance.\n\n    This coroutine must update the following attributes of AsyncEOSDevice:\n    - is_online: When a device IP is reachable and a port can be open\n    - established: When a command execution succeeds\n    - hw_model: The hardware model of the device\n    \"\"\"\n    # Refresh command\n    COMMAND: str = \"show version\"\n    # Hardware model definition in show version\n    HW_MODEL_KEY: str = \"modelName\"\n    logger.debug(f\"Refreshing device {self.name}\")\n    self.is_online = await self._session.check_connection()\n    if self.is_online:\n        try:\n            response = await self._session.cli(command=COMMAND)\n        except EapiCommandError as e:\n            logger.warning(f\"Cannot get hardware information from device {self.name}: {e.errmsg}\")\n        except (HTTPError, ConnectError) as e:\n            logger.warning(f\"Cannot get hardware information from device {self.name}: {exc_to_str(e)}\")\n        else:\n            if HW_MODEL_KEY in response:\n                self.hw_model = response[HW_MODEL_KEY]\n            else:\n                logger.warning(f\"Cannot get hardware information from device {self.name}: cannot parse '{COMMAND}'\")\n    else:\n        logger.warning(f\"Could not connect to device {self.name}: cannot open eAPI port\")\n    self.established = bool(self.is_online and self.hw_model)\n</code></pre>"},{"location":"api/inventory/","title":"Inventory module","text":""},{"location":"api/inventory/#anta.inventory.AntaInventory","title":"AntaInventory","text":"<p>             Bases: <code>dict</code></p> <p>Inventory abstraction for ANTA framework.</p>"},{"location":"api/inventory/#anta.inventory.AntaInventory.add_device","title":"add_device","text":"<pre><code>add_device(device: AntaDevice) -&gt; None\n</code></pre> <p>Add a device to final inventory.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>AntaDevice</code> <p>Device object to be added</p> required Source code in <code>anta/inventory/__init__.py</code> <pre><code>def add_device(self, device: AntaDevice) -&gt; None:\n\"\"\"Add a device to final inventory.\n\n    Args:\n        device: Device object to be added\n    \"\"\"\n    self[device.name] = device\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.connect_inventory","title":"connect_inventory  <code>async</code>","text":"<pre><code>connect_inventory() -&gt; None\n</code></pre> <p>Run <code>refresh()</code> coroutines for all AntaDevice objects in this inventory.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>async def connect_inventory(self) -&gt; None:\n\"\"\"Run `refresh()` coroutines for all AntaDevice objects in this inventory.\"\"\"\n    logger.debug(\"Refreshing devices...\")\n    results = await asyncio.gather(\n        *(device.refresh() for device in self.values()),\n        return_exceptions=True,\n    )\n    for r in results:\n        if isinstance(r, Exception):\n            message = \"Error when refreshing inventory\"\n            anta_log_exception(r, message, logger)\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_inventory","title":"get_inventory","text":"<pre><code>get_inventory(established_only: bool = False, tags: Optional[List[str]] = None) -&gt; AntaInventory\n</code></pre> <p>Returns a filtered inventory.</p> <p>Parameters:</p> Name Type Description Default <code>established_only</code> <code>bool</code> <p>Whether or not to include only established devices. Default False.</p> <code>False</code> <code>tags</code> <code>Optional[List[str]]</code> <p>List of tags to filter devices.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AntaInventory</code> <code>AntaInventory</code> <p>An inventory with filtered AntaDevice objects.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>def get_inventory(self, established_only: bool = False, tags: Optional[List[str]] = None) -&gt; AntaInventory:\n\"\"\"\n    Returns a filtered inventory.\n\n    Args:\n        established_only: Whether or not to include only established devices. Default False.\n        tags: List of tags to filter devices.\n\n    Returns:\n        AntaInventory: An inventory with filtered AntaDevice objects.\n    \"\"\"\n\n    def _filter_devices(device: AntaDevice) -&gt; bool:\n\"\"\"\n        Helper function to select the devices based on the input tags\n        and the requirement for an established connection.\n        \"\"\"\n        if tags is not None and all(tag not in tags for tag in device.tags):\n            return False\n        return bool(not established_only or device.established)\n\n    devices: List[AntaDevice] = list(filter(_filter_devices, self.values()))\n    result = AntaInventory()\n    for device in devices:\n        result.add_device(device)\n    return result\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.parse","title":"parse  <code>staticmethod</code>","text":"<pre><code>parse(inventory_file: str, username: str, password: str, enable: bool = False, enable_password: Optional[str] = None, timeout: Optional[float] = None, insecure: bool = False) -&gt; AntaInventory\n</code></pre> <p>Create an AntaInventory instance from an inventory file. The inventory devices are AsyncEOSDevice instances.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_file</code> <code>str</code> <p>Path to inventory YAML file where user has described his inputs</p> required <code>username</code> <code>str</code> <p>Username to use to connect to devices</p> required <code>password</code> <code>str</code> <p>Password to use to connect to devices</p> required <code>enable</code> <code>bool</code> <p>Whether or not the commands need to be run in enable mode towards the devices</p> <code>False</code> <code>timeout</code> <code>float</code> <p>timeout in seconds for every API call.</p> <code>None</code> <p>Raises:</p> Type Description <code>InventoryRootKeyError</code> <p>Root key of inventory is missing.</p> <code>InventoryIncorrectSchema</code> <p>Inventory file is not following AntaInventory Schema.</p> <code>InventoryUnknownFormat</code> <p>Output format is not supported.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>@staticmethod\ndef parse(\n    inventory_file: str,\n    username: str,\n    password: str,\n    enable: bool = False,\n    enable_password: Optional[str] = None,\n    timeout: Optional[float] = None,\n    insecure: bool = False,\n) -&gt; AntaInventory:\n    # pylint: disable=too-many-arguments\n\"\"\"\n    Create an AntaInventory instance from an inventory file.\n    The inventory devices are AsyncEOSDevice instances.\n\n    Args:\n        inventory_file (str): Path to inventory YAML file where user has described his inputs\n        username (str): Username to use to connect to devices\n        password (str): Password to use to connect to devices\n        enable (bool): Whether or not the commands need to be run in enable mode towards the devices\n        timeout (float, optional): timeout in seconds for every API call.\n\n    Raises:\n        InventoryRootKeyError: Root key of inventory is missing.\n        InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema.\n        InventoryUnknownFormat: Output format is not supported.\n    \"\"\"\n\n    inventory = AntaInventory()\n    kwargs: Dict[str, Any] = {\n        \"username\": username,\n        \"password\": password,\n        \"enable\": enable,\n        \"enable_password\": enable_password,\n        \"timeout\": timeout,\n        \"insecure\": insecure,\n    }\n    kwargs = {k: v for k, v in kwargs.items() if v is not None}\n\n    with open(inventory_file, \"r\", encoding=\"UTF-8\") as file:\n        data = safe_load(file)\n\n    # Load data using Pydantic\n    try:\n        inventory_input = AntaInventoryInput(**data[AntaInventory.INVENTORY_ROOT_KEY])\n    except KeyError as exc:\n        logger.error(f\"Inventory root key is missing: {AntaInventory.INVENTORY_ROOT_KEY}\")\n        raise InventoryRootKeyError(f\"Inventory root key ({AntaInventory.INVENTORY_ROOT_KEY}) is not defined in your inventory\") from exc\n    except ValidationError as exc:\n        logger.error(\"Inventory data are not compliant with inventory models\")\n        raise InventoryIncorrectSchema(f\"Inventory is not following the schema: {str(exc)}\") from exc\n\n    # Read data from input\n    AntaInventory._parse_hosts(inventory_input, inventory, **kwargs)\n    AntaInventory._parse_networks(inventory_input, inventory, **kwargs)\n    AntaInventory._parse_ranges(inventory_input, inventory, **kwargs)\n\n    return inventory\n</code></pre>"},{"location":"api/inventory/#anta.inventory.exceptions","title":"exceptions","text":"<p>Manage Exception in Inventory module.</p>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryIncorrectSchema","title":"InventoryIncorrectSchema","text":"<p>             Bases: <code>Exception</code></p> <p>Error when user data does not follow ANTA schema.</p>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryRootKeyError","title":"InventoryRootKeyError","text":"<p>             Bases: <code>Exception</code></p> <p>Error raised when inventory root key is not found.</p>"},{"location":"api/inventory.models.input/","title":"Inventory models","text":""},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryInput","title":"AntaInventoryInput","text":"<p>             Bases: <code>BaseModel</code></p> <p>User\u2019s inventory model.</p> <p>Attributes:</p> Name Type Description <code>networks</code> <code>(List[AntaInventoryNetwork], Optional)</code> <p>List of AntaInventoryNetwork objects for networks.</p> <code>hosts</code> <code>(List[AntaInventoryHost], Optional)</code> <p>List of AntaInventoryHost objects for hosts.</p> <code>range</code> <code>(List[AntaInventoryRange], Optional)</code> <p>List of AntaInventoryRange objects for ranges.</p>"},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryHost","title":"AntaInventoryHost","text":"<p>             Bases: <code>BaseModel</code></p> <p>Host definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address of the device</p> <code>port</code> <code>int</code> <p>(Optional) eAPI port to use Default is 443.</p> <code>name</code> <code>str</code> <p>(Optional) Name to display during tests report. Default is hostname:port</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p>"},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryNetwork","title":"AntaInventoryNetwork","text":"<p>             Bases: <code>BaseModel</code></p> <p>Network definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>network</code> <code>IPvAnyNetwork</code> <p>Subnet to use for testing.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p>"},{"location":"api/inventory.models.input/#anta.inventory.models.AntaInventoryRange","title":"AntaInventoryRange","text":"<p>             Bases: <code>BaseModel</code></p> <p>IP Range definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the begining of the range.</p> <code>stop</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the end of the range.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p>"},{"location":"api/models/","title":"Test models","text":""},{"location":"api/models/#anta.models.AntaTest","title":"AntaTest","text":"<pre><code>AntaTest(device: AntaDevice, template_params: list[dict[str, Any]] | None = None, result_description: str | None = None, result_categories: list[str] | None = None, result_custom_field: str | None = None, eos_data: list[dict[Any, Any] | str] | None = None, labels: list[str] | None = None)\n</code></pre> <p>             Bases: <code>ABC</code></p> <p>Abstract class defining a test for Anta</p> <p>The goal of this class is to handle the heavy lifting and make writing a test as simple as possible.</p> <p>TODO - complete doctstring with example</p> <p>Doc to be completed</p> <p>Parameters:</p> Name Type Description Default <code>result_custom_field</code> <code>str</code> <p>a free string that is included in the TestResult object</p> <code>None</code> Source code in <code>anta/models.py</code> <pre><code>def __init__(\n    self,\n    device: AntaDevice,\n    template_params: list[dict[str, Any]] | None = None,\n    result_description: str | None = None,\n    result_categories: list[str] | None = None,\n    result_custom_field: str | None = None,\n    # TODO document very well the order of eos_data\n    eos_data: list[dict[Any, Any] | str] | None = None,\n    labels: list[str] | None = None,\n):\n\"\"\"\n    AntaTest Constructor\n\n    Doc to be completed\n\n    Arguments:\n        result_custom_field (str): a free string that is included in the TestResult object\n    \"\"\"\n    # Accept 6 input arguments\n    # pylint: disable=R0913\n    self.logger: logging.Logger = logging.getLogger(f\"{self.__module__}.{self.__class__.__name__}\")\n    self.device: AntaDevice = device\n    self.result: TestResult = TestResult(\n        name=device.name,\n        test=self.name,\n        categories=result_categories or self.categories,\n        description=result_description or self.description,\n        custom_field=result_custom_field,\n    )\n    self.labels: List[str] = labels or []\n    self.instance_commands: List[AntaCommand] = []\n\n    # TODO - check optimization for deepcopy\n    # Generating instance_commands from list of commands and template\n    if hasattr(self.__class__, \"commands\") and (cmds := self.__class__.commands) is not None:\n        self.instance_commands.extend(deepcopy(cmds))\n    if hasattr(self.__class__, \"template\") and (tpl := self.__class__.template) is not None:\n        if template_params is None:\n            self.result.is_error(\"Command has template but no params were given\")\n            return\n        self.template_params = template_params\n        for param in template_params:\n            try:\n                self.instance_commands.append(tpl.render(param))\n            except KeyError:\n                self.result.is_error(f\"Cannot render template '{tpl.template}': wrong parameters\")\n                return\n\n    if eos_data is not None:\n        self.logger.debug(\"Test initialized with input data\")\n        self.save_commands_data(eos_data)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.all_data_collected","title":"all_data_collected","text":"<pre><code>all_data_collected() -&gt; bool\n</code></pre> <p>returns True if output is populated for every command</p> Source code in <code>anta/models.py</code> <pre><code>def all_data_collected(self) -&gt; bool:\n\"\"\"returns True if output is populated for every command\"\"\"\n    return all(command.collected for command in self.instance_commands)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.anta_test","title":"anta_test  <code>staticmethod</code>","text":"<pre><code>anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]\n</code></pre> <p>Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing</p> Source code in <code>anta/models.py</code> <pre><code>@staticmethod\ndef anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]:\n\"\"\"\n    Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing\n    \"\"\"\n\n    @wraps(function)\n    async def wrapper(\n        self: AntaTest,\n        eos_data: list[dict[Any, Any] | str] | None = None,\n        **kwargs: Any,\n    ) -&gt; TestResult:\n\"\"\"\n        Wraps the test function and implement (in this order):\n        1. Instantiate the command outputs if `eos_data` is provided\n        2. Collect missing command outputs from the device\n        3. Run the test function\n        4. Catches and set the result if the test function raises an exception\n\n        Returns:\n            TestResult: self.result, populated with the correct exit status\n        \"\"\"\n        if self.result.result != \"unset\":\n            return self.result\n\n        # TODO maybe_skip decorators\n\n        # Data\n        if eos_data is not None:\n            self.save_commands_data(eos_data)\n            self.logger.debug(f\"Test {self.name} initialized with input data {eos_data}\")\n\n        # If some data is missing, try to collect\n        if not self.all_data_collected():\n            await self.collect()\n            if self.result.result != \"unset\":\n                return self.result\n\n        try:\n            if cmds := self.get_failed_commands():\n                self.result.is_error(\n                    \"\\n\".join([f\"{cmd.command} has failed: {exc_to_str(cmd.failed)}\" if cmd.failed else f\"{cmd.command} has failed\" for cmd in cmds])\n                )\n                return self.result\n            function(self, **kwargs)\n        except Exception as e:  # pylint: disable=broad-exception-caught\n            message = f\"Exception raised for test {self.name} (on device {self.device.name})\"\n            anta_log_exception(e, message, self.logger)\n            self.result.is_error(exc_to_str(e))\n\n        AntaTest.update_progress()\n        return self.result\n\n    return wrapper\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.collect","title":"collect  <code>async</code>","text":"<pre><code>collect() -&gt; None\n</code></pre> <p>Method used to collect outputs of all commands of this test class from the device of this test instance.</p> Source code in <code>anta/models.py</code> <pre><code>async def collect(self) -&gt; None:\n\"\"\"\n    Method used to collect outputs of all commands of this test class from the device of this test instance.\n    \"\"\"\n    try:\n        await self.device.collect_commands(self.instance_commands)\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        message = f\"Exception raised while collecting commands for test {self.name} (on device {self.device.name})\"\n        anta_log_exception(e, message, self.logger)\n        self.result.is_error(exc_to_str(e))\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.get_failed_commands","title":"get_failed_commands","text":"<pre><code>get_failed_commands() -&gt; List[AntaCommand]\n</code></pre> <p>returns a list of all the commands that have a populated failed field</p> Source code in <code>anta/models.py</code> <pre><code>def get_failed_commands(self) -&gt; List[AntaCommand]:\n\"\"\"returns a list of all the commands that have a populated failed field\"\"\"\n    return [command for command in self.instance_commands if command.failed is not None]\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.save_commands_data","title":"save_commands_data","text":"<pre><code>save_commands_data(eos_data: list[dict[Any, Any] | str]) -&gt; None\n</code></pre> <p>Called at init or at test execution time</p> Source code in <code>anta/models.py</code> <pre><code>def save_commands_data(self, eos_data: list[dict[Any, Any] | str]) -&gt; None:\n\"\"\"Called at init or at test execution time\"\"\"\n    if len(eos_data) != len(self.instance_commands):\n        self.result.is_error(\"Test initialization error: Trying to save more data than there are commands for the test\")\n        return\n    for index, data in enumerate(eos_data or []):\n        self.instance_commands[index].output = data\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.test","title":"test  <code>abstractmethod</code>","text":"<pre><code>test() -&gt; Coroutine[Any, Any, TestResult]\n</code></pre> <p>This abstract method is the core of the test. It MUST set the correct status of self.result with the appropriate error messages</p> <p>it must be implemented as follow</p> <p>@AntaTest.anta_test def test(self) -&gt; None:    \u2018\u2019\u2019    assert code    \u2018\u2019\u2018</p> Source code in <code>anta/models.py</code> <pre><code>@abstractmethod\ndef test(self) -&gt; Coroutine[Any, Any, TestResult]:\n\"\"\"\n    This abstract method is the core of the test.\n    It MUST set the correct status of self.result with the appropriate error messages\n\n    it must be implemented as follow\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n       '''\n       assert code\n       '''\n    \"\"\"\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.update_progress","title":"update_progress  <code>classmethod</code>","text":"<pre><code>update_progress() -&gt; None\n</code></pre> <p>Update progress bar for all AntaTest objects if it exists</p> Source code in <code>anta/models.py</code> <pre><code>@classmethod\ndef update_progress(cls) -&gt; None:\n\"\"\"\n    Update progress bar for all AntaTest objects if it exists\n    \"\"\"\n    if cls.progress and (cls.nrfu_task is not None):\n        cls.progress.update(cls.nrfu_task, advance=1)\n</code></pre>"},{"location":"api/models/#anta.models.AntaCommand","title":"AntaCommand","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to define a test command with its API version</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>Device command</p> <code>version</code> <code>Literal[1, 'latest']</code> <p>eAPI version - valid values are 1 or \u201clatest\u201d - default is \u201clatest\u201d</p> <code>revision</code> <code>Optional[conint(ge=1, le=99)]</code> <p>Revision of the command. Valid values are 1 to 99. Revision has precedence over version.</p> <code>ofmt</code> <code>Literal['json', 'text']</code> <p>eAPI output - json or text - default is json</p> <code>template</code> <code>Optional[AntaTemplate]</code> <p>AntaTemplate object used to render this command</p> <code>params</code> <code>Optional[Dict[str, Any]]</code> <p>dictionary of variables with string values to render the template</p> <code>failed</code> <code>Optional[Exception]</code> <p>If the command execution fails, the Exception object is stored in this field</p>"},{"location":"api/models/#anta.models.AntaCommand.collected","title":"collected  <code>property</code>","text":"<pre><code>collected: bool\n</code></pre> <p>Return True if the command has been collected</p>"},{"location":"api/models/#anta.models.AntaCommand.json_output","title":"json_output  <code>property</code>","text":"<pre><code>json_output: Dict[str, Any]\n</code></pre> <p>Get the command output as JSON</p>"},{"location":"api/models/#anta.models.AntaCommand.text_output","title":"text_output  <code>property</code>","text":"<pre><code>text_output: str\n</code></pre> <p>Get the command output as a string</p>"},{"location":"api/models/#anta.models.AntaTemplate","title":"AntaTemplate","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class to define a test command with its API version</p> <p>Attributes:</p> Name Type Description <code>template</code> <code>str</code> <p>Python f-string. Example: \u2018show vlan {vlan_id}\u2019</p> <code>version</code> <code>Literal[1, 'latest']</code> <p>eAPI version - valid values are 1 or \u201clatest\u201d - default is \u201clatest\u201d</p> <code>revision</code> <code>Optional[conint(ge=1, le=99)]</code> <p>Revision of the command. Valid values are 1 to 99. Revision has precedence over version.</p> <code>ofmt</code> <code>Literal['json', 'text']</code> <p>eAPI output - json or text - default is json</p>"},{"location":"api/models/#anta.models.AntaTemplate.render","title":"render","text":"<pre><code>render(params: Dict[str, Any]) -&gt; AntaCommand\n</code></pre> <p>Render an AntaCommand from an AntaTemplate instance. Keep the parameters used in the AntaTemplate instance.</p> <p>Args:      params: dictionary of variables with string values to render the Python f-string</p> <p>Returns:      AntaCommand: The rendered AntaCommand.                   This AntaCommand instance have a template attribute that references this                   AntaTemplate instance.</p> Source code in <code>anta/models.py</code> <pre><code>def render(self, params: Dict[str, Any]) -&gt; AntaCommand:\n\"\"\"Render an AntaCommand from an AntaTemplate instance.\n    Keep the parameters used in the AntaTemplate instance.\n\n     Args:\n         params: dictionary of variables with string values to render the Python f-string\n\n     Returns:\n         AntaCommand: The rendered AntaCommand.\n                      This AntaCommand instance have a template attribute that references this\n                      AntaTemplate instance.\n    \"\"\"\n    return AntaCommand(command=self.template.format(**params), ofmt=self.ofmt, version=self.version, revision=self.revision, template=self, params=params)\n</code></pre>"},{"location":"api/report_manager/","title":"Report Manager module","text":""},{"location":"api/report_manager/#anta.reporter.ReportTable","title":"ReportTable","text":"<pre><code>ReportTable()\n</code></pre> <p>TableReport Generate a Table based on TestResult.</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    __init__ Class constructor\n    \"\"\"\n    self.colors = []\n    self.colors.append(ColorManager(level=\"success\", color=RICH_COLOR_PALETTE.SUCCESS))\n    self.colors.append(ColorManager(level=\"failure\", color=RICH_COLOR_PALETTE.FAILURE))\n    self.colors.append(ColorManager(level=\"error\", color=RICH_COLOR_PALETTE.ERROR))\n    self.colors.append(ColorManager(level=\"skipped\", color=RICH_COLOR_PALETTE.SKIPPED))\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_all","title":"report_all","text":"<pre><code>report_all(result_manager: ResultManager, host: Optional[str] = None, testcase: Optional[str] = None, title: str = 'All tests results') -&gt; Table\n</code></pre> <p>Create a table report with all tests for one or all devices.</p> <p>Create table with full output: Host / Test / Status / Message</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'All tests results'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_all(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    testcase: Optional[str] = None,\n    title: str = \"All tests results\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with all tests for one or all devices.\n\n    Create table with full output: Host / Test / Status / Message\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\"Device IP\", \"Test Name\", \"Test Status\", \"Message(s)\", \"Test description\", \"Test category\"]\n    table = self._build_headers(headers=headers, table=table)\n\n    for result in result_manager.get_results(output_format=\"list\"):\n        # pylint: disable=R0916\n        if (host is None and testcase is None) or (host is not None and str(result.name) == host) or (testcase is not None and testcase == str(result.test)):\n            state = self._color_result(status=str(result.result), output_type=\"str\")\n            message = self._split_list_to_txt_list(result.messages) if len(result.messages) &gt; 0 else \"\"\n            categories = \", \".join(result.categories)\n            table.add_row(str(result.name), result.test, state, message, result.description, categories)\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_hosts","title":"report_summary_hosts","text":"<pre><code>report_summary_hosts(result_manager: ResultManager, host: Optional[str] = None, title: str = 'Summary per host') -&gt; Table\n</code></pre> <p>Create a table report with result agregated per host.</p> <p>Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per host'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_hosts(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    title: str = \"Summary per host\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per host.\n\n    Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\n        \"Host IP\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed or error test cases\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for host_read in result_manager.get_hosts():\n        if host is None or str(host_read) == host:\n            results = result_manager.get_result_by_host(host_read)\n            logger.debug(\"data to use for computation\")\n            logger.debug(f\"{host}: {results}\")\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.test) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                str(host_read),\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_tests","title":"report_summary_tests","text":"<pre><code>report_summary_tests(result_manager: ResultManager, testcase: Optional[str] = None, title: str = 'Summary per test case') -&gt; Table\n</code></pre> <p>Create a table report with result agregated per test.</p> <p>Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per test case'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_tests(\n    self,\n    result_manager: ResultManager,\n    testcase: Optional[str] = None,\n    title: str = \"Summary per test case\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per test.\n\n    Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    # sourcery skip: class-extract-method\n    table = Table(title=title)\n    headers = [\n        \"Test Case\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed or error nodes\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for testcase_read in result_manager.get_testcases():\n        if testcase is None or str(testcase_read) == testcase:\n            results = result_manager.get_result_by_test(testcase_read)\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.name) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                testcase_read,\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager_models/","title":"Report Manager models","text":""},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager","title":"ColorManager","text":"<p>             Bases: <code>BaseModel</code></p> <p>Color management for status report.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>str</code> <p>Test result value.</p> <code>color</code> <code>str</code> <p>Associated color.</p>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.name_must_be_in","title":"name_must_be_in","text":"<pre><code>name_must_be_in(v: str) -&gt; str\n</code></pre> <p>Status validator</p> <p>Validate status is a supported one</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>User defined level</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If level is unsupported</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>level value</p> Source code in <code>anta/reporter/models.py</code> <pre><code>@validator(\"level\", allow_reuse=True)\ndef name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n    Status validator\n\n    Validate status is a supported one\n\n    Args:\n        v (str): User defined level\n\n    Raises:\n        ValueError: If level is unsupported\n\n    Returns:\n        str: level value\n    \"\"\"\n    if v not in RESULT_OPTIONS:\n        raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n    return v\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.string","title":"string","text":"<pre><code>string() -&gt; str\n</code></pre> <p>Build an str with color code</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with level and its associated color</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def string(self) -&gt; str:\n\"\"\"\n    Build an str with color code\n\n    Returns:\n        str: String with level and its associated color\n    \"\"\"\n    return f\"[{self.color}]{self.level}\"\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.style_rich","title":"style_rich","text":"<pre><code>style_rich() -&gt; Text\n</code></pre> <p>Build a rich Text syntax with color</p> <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>object with level string and its associated color.</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def style_rich(self) -&gt; Text:\n\"\"\"\n    Build a rich Text syntax with color\n\n    Returns:\n        Text: object with level string and its associated color.\n    \"\"\"\n    return Text(self.level, style=self.color)\n</code></pre>"},{"location":"api/result_manager/","title":"Result Manager module","text":""},{"location":"api/result_manager/#anta.result_manager.ResultManager","title":"ResultManager","text":"<pre><code>ResultManager()\n</code></pre> <p>Helper to manage Test Results and generate reports.</p> <p>Examples:</p> <p>Create Inventory:</p> <pre><code>inventory_anta = AntaInventory.parse(\n    inventory_file='examples/inventory.yml',\n    username='ansible',\n    password='ansible',\n    timeout=0.5\n)\n</code></pre> <p>Create Result Manager:</p> <pre><code>manager = ResultManager()\n</code></pre> <p>Run tests for all connected devices:</p> <pre><code>for device in inventory_anta.get_inventory():\n    manager.add_test_result(\nVerifyNTP(device=device).test()\n)\nmanager.add_test_result(\nVerifyEOSVersion(device=device).test(version='4.28.3M')\n)\n</code></pre> <p>Print result in native format:</p> <pre><code>manager.get_results()\n[\n    TestResult(\n        host=IPv4Address('192.168.0.10'),\n        test='VerifyNTP',\n        result='failure',\n        message=\"device is not running NTP correctly\"\n    ),\n    TestResult(\n        host=IPv4Address('192.168.0.10'),\n        test='VerifyEOSVersion',\n        result='success',\n        message=None\n    ),\n]\n</code></pre> <p>The status of the class is initialized to \u201cunset\u201d</p> <p>Then when adding a test with a status that is NOT \u2018error\u2019 the following table shows the updated status:</p> Current Status Added test Status Updated Status unset Any Any skipped unset, skipped skipped skipped success success skipped failure failure success unset, skipped, success success success failure failure failure unset, skipped success, failure failure <p>If the status of the added test is error, the status is untouched and the error_status is set to True.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    Class constructor.\n\n    The status of the class is initialized to \"unset\"\n\n    Then when adding a test with a status that is NOT 'error' the following\n    table shows the updated status:\n\n    | Current Status |         Added test Status       | Updated Status |\n    | -------------- | ------------------------------- | -------------- |\n    |      unset     |              Any                |       Any      |\n    |     skipped    |         unset, skipped          |     skipped    |\n    |     skipped    |            success              |     success    |\n    |     skipped    |            failure              |     failure    |\n    |     success    |     unset, skipped, success     |     success    |\n    |     success    |            failure              |     failure    |\n    |     failure    | unset, skipped success, failure |     failure    |\n\n    If the status of the added test is error, the status is untouched and the\n    error_status is set to True.\n    \"\"\"\n    logger.debug(\"Instantiate result-manager\")\n    self._result_entries = ListResult()\n    # Initialize status\n    self.status = \"unset\"\n    self.error_status = False\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_result","title":"add_test_result","text":"<pre><code>add_test_result(entry: TestResult) -&gt; None\n</code></pre> <p>Add a result to the list</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TestResult</code> <p>TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_result(self, entry: TestResult) -&gt; None:\n\"\"\"Add a result to the list\n\n    Args:\n        entry (TestResult): TestResult data to add to the report\n    \"\"\"\n    logger.debug(entry)\n    self._result_entries.append(entry)\n    self._update_status(entry.result)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_results","title":"add_test_results","text":"<pre><code>add_test_results(entries: List[TestResult]) -&gt; None\n</code></pre> <p>Add a list of results to the list</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TestResult]</code> <p>list of TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_results(self, entries: List[TestResult]) -&gt; None:\n\"\"\"Add a list of results to the list\n\n    Args:\n        entries (List[TestResult]): list of TestResult data to add to the report\n    \"\"\"\n    for e in entries:\n        self.add_test_result(e)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_hosts","title":"get_hosts","text":"<pre><code>get_hosts() -&gt; List[str]\n</code></pre> <p>Get list of IP addresses in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of IP addresses.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_hosts(self) -&gt; List[str]:\n\"\"\"\n    Get list of IP addresses in current manager.\n\n    Returns:\n        List[str]: List of IP addresses.\n    \"\"\"\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.name) not in result_list:\n            result_list.append(str(testcase.name))\n    return result_list\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_host","title":"get_result_by_host","text":"<pre><code>get_result_by_host(host_ip: str, output_format: str = 'native') -&gt; Any\n</code></pre> <p>Get list of test result for a given host.</p> <p>Parameters:</p> Name Type Description Default <code>host_ip</code> <code>str</code> <p>IP Address of the host to use to filter results.</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>List of results related to the host.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_host(self, host_ip: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given host.\n\n    Args:\n        host_ip (str): IP Address of the host to use to filter results.\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        Any: List of results related to the host.\n    \"\"\"\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.name) == host_ip]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if str(result.name) == host_ip:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_test","title":"get_result_by_test","text":"<pre><code>get_result_by_test(test_name: str, output_format: str = 'native') -&gt; Any\n</code></pre> <p>Get list of test result for a given test.</p> <p>Parameters:</p> Name Type Description Default <code>test_name</code> <code>str</code> <p>Test name to use to filter results</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Type Description <code>Any</code> <p>list[TestResult]: List of results related to the test.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_test(self, test_name: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given test.\n\n    Args:\n        test_name (str): Test name to use to filter results\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        list[TestResult]: List of results related to the test.\n    \"\"\"\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.test) == test_name]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if result.test == test_name:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_results","title":"get_results","text":"<pre><code>get_results(output_format: str = 'native') -&gt; Any\n</code></pre> <p>Expose list of all test results in different format</p> Support multiple format <ul> <li>native: ListResults format</li> <li>list: a list of TestResult</li> <li>json: a native JSON format</li> </ul> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list/json. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>any</code> <code>Any</code> <p>List of results.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_results(self, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Expose list of all test results in different format\n\n    Support multiple format:\n      - native: ListResults format\n      - list: a list of TestResult\n      - json: a native JSON format\n\n    Args:\n        output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'.\n\n    Returns:\n        any: List of results.\n    \"\"\"\n    if output_format == \"list\":\n        return list(self._result_entries)\n\n    if output_format == \"json\":\n        return json.dumps(pydantic_to_dict(self._result_entries), indent=4)\n\n    if output_format == \"native\":\n        # Default return for native format.\n        return self._result_entries\n    raise ValueError(f\"{output_format} is not a valid value ['list', 'json', 'native']\")\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_status","title":"get_status","text":"<pre><code>get_status(ignore_error: bool = False) -&gt; str\n</code></pre> <p>Returns the current status including error_status if ignore_error is False</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_status(self, ignore_error: bool = False) -&gt; str:\n\"\"\"\n    Returns the current status including error_status if ignore_error is False\n    \"\"\"\n    return \"error\" if self.error_status and not ignore_error else self.status\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_testcases","title":"get_testcases","text":"<pre><code>get_testcases() -&gt; List[str]\n</code></pre> <p>Get list of name of all test cases in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of names for all tests.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_testcases(self) -&gt; List[str]:\n\"\"\"\n    Get list of name of all test cases in current manager.\n\n    Returns:\n        List[str]: List of names for all tests.\n    \"\"\"\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.test) not in result_list:\n            result_list.append(str(testcase.test))\n    return result_list\n</code></pre>"},{"location":"api/result_manager_models/","title":"Result Manager models","text":""},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult","title":"TestResult","text":"<p>             Bases: <code>BaseModel</code></p> <p>Describe the result of a test from a single device.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name where the test has run.</p> <code>test</code> <code>str</code> <p>Test name runs on the device.</p> <code>categories</code> <code>List[str]</code> <p>List of categories the TestResult belongs to, by default the AntaTest categories.</p> <code>description</code> <code>str</code> <p>TestResult description, by default the AntaTest description.</p> <code>results</code> <code>str</code> <p>Result of the test. Can be one of [\u201cunset\u201d, \u201csuccess\u201d, \u201cfailure\u201d, \u201cerror\u201d, \u201cskipped\u201d].</p> <code>message</code> <code>str</code> <p>Message to report after the test if any.</p> <code>custom_field</code> <code>str</code> <p>Custom field to store a string for flexibility in integrating with ANTA</p>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_error","title":"is_error","text":"<pre><code>is_error(message: str = '') -&gt; bool\n</code></pre> <p>Helper to set status to error</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_error(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to error\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"error\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_failure","title":"is_failure","text":"<pre><code>is_failure(message: str = '') -&gt; bool\n</code></pre> <p>Helper to set status to failure</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_failure(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to failure\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"failure\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_skipped","title":"is_skipped","text":"<pre><code>is_skipped(message: str = '') -&gt; bool\n</code></pre> <p>Helper to set status to skipped</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_skipped(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to skipped\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"skipped\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_success","title":"is_success","text":"<pre><code>is_success(message: str = '') -&gt; bool\n</code></pre> <p>Helper to set status to success</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_success(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to success\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"success\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.name_must_be_in","title":"name_must_be_in  <code>classmethod</code>","text":"<pre><code>name_must_be_in(v: str) -&gt; str\n</code></pre> <p>Status validator</p> <p>Validate status is a supported one</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>User defined status</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If status is unsupported</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>status value</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>@classmethod\n@field_validator(\"result\")\ndef name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n    Status validator\n\n    Validate status is a supported one\n\n    Args:\n        v (str): User defined status\n\n    Raises:\n        ValueError: If status is unsupported\n\n    Returns:\n        str: status value\n    \"\"\"\n    if v not in RESULT_OPTIONS:\n        raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n    return v\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult","title":"ListResult","text":"<p>             Bases: <code>RootModel[List[TestResult]]</code></p> <p>List result for all tests on all devices.</p> <p>Attributes:</p> Name Type Description <code>__root__</code> <code>List[TestResult]</code> <p>A list of TestResult objects.</p>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.append","title":"append","text":"<pre><code>append(value: TestResult) -&gt; None\n</code></pre> <p>Add support for append method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def append(self, value: TestResult) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n    self.root.append(value)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.extend","title":"extend","text":"<pre><code>extend(values: List[TestResult]) -&gt; None\n</code></pre> <p>Add support for extend method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def extend(self, values: List[TestResult]) -&gt; None:\n\"\"\"Add support for extend method.\"\"\"\n    self.root.extend(values)\n</code></pre>"},{"location":"api/tests.aaa/","title":"AAA","text":""},{"location":"api/tests.aaa/#anta-catalog-for-interfaces-tests","title":"ANTA catalog for interfaces tests","text":"<p>Test functions related to the EOS various AAA settings</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods","title":"VerifyAcctConsoleMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.</li> <li>skipped: The test will be skipped if the AAA accounting console method list or accounting type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctConsoleMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.\n        * skipped: The test will be skipped if the AAA accounting console method list or accounting type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAcctConsoleMethods\"\n    description = \"Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods accounting\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAcctConsoleMethods validation.\n\n        Args:\n            methods: List of AAA accounting console methods. Methods should be in the right order.\n            auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n        not_configured = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AcctMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if not command_output[auth_type_key][method_key].get(\"consoleAction\"):\n                not_configured.append(auth_type)\n\n            if command_output[auth_type_key][method_key][\"consoleMethods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not_configured:\n            self.result.is_failure(f\"AAA console accounting is not configured for {not_configured}\")\n            return\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting console methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods.test","title":"test","text":"<pre><code>test(methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyAcctConsoleMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA accounting console methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of accounting types to verify. List elements must be: commands, exec, system, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAcctConsoleMethods validation.\n\n    Args:\n        methods: List of AAA accounting console methods. Methods should be in the right order.\n        auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n    not_configured = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AcctMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if not command_output[auth_type_key][method_key].get(\"consoleAction\"):\n            not_configured.append(auth_type)\n\n        if command_output[auth_type_key][method_key][\"consoleMethods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not_configured:\n        self.result.is_failure(f\"AAA console accounting is not configured for {not_configured}\")\n        return\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA accounting console methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods","title":"VerifyAcctDefaultMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.</li> <li>skipped: The test will be skipped if the AAA accounting default method list or accounting type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctDefaultMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.\n        * skipped: The test will be skipped if the AAA accounting default method list or accounting type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAcctDefaultMethods\"\n    description = \"Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods accounting\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAcctDefaultMethods validation.\n\n        Args:\n            methods: List of AAA accounting default methods. Methods should be in the right order.\n            auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n        not_configured = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AcctMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if not command_output[auth_type_key][method_key].get(\"defaultAction\"):\n                not_configured.append(auth_type)\n\n            if command_output[auth_type_key][method_key][\"defaultMethods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not_configured:\n            self.result.is_failure(f\"AAA default accounting is not configured for {not_configured}\")\n            return\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting default methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods.test","title":"test","text":"<pre><code>test(methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyAcctDefaultMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA accounting default methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of accounting types to verify. List elements must be: commands, exec, system, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAcctDefaultMethods validation.\n\n    Args:\n        methods: List of AAA accounting default methods. Methods should be in the right order.\n        auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n    not_configured = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AcctMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if not command_output[auth_type_key][method_key].get(\"defaultAction\"):\n            not_configured.append(auth_type)\n\n        if command_output[auth_type_key][method_key][\"defaultMethods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not_configured:\n        self.result.is_failure(f\"AAA default accounting is not configured for {not_configured}\")\n        return\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA accounting default methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods","title":"VerifyAuthenMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.</li> <li>failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.</li> <li>skipped: The test will be skipped if the AAA authentication method list or authentication type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthenMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.\n        * failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.\n        * skipped: The test will be skipped if the AAA authentication method list or authentication type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAuthenMethods\"\n    description = \"Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods authentication\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAuthenMethods validation.\n\n        Args:\n            methods: List of AAA authentication methods. Methods should be in the right order.\n            auth_types: List of authentication types to verify. List elements must be: login, enable, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"login\", \"enable\", \"dot1x\"])\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AuthenMethods\"\n\n            if auth_type_key == \"loginAuthenMethods\":\n                if not command_output[auth_type_key].get(\"login\"):\n                    self.result.is_failure(\"AAA authentication methods are not configured for login console\")\n                    return\n\n                if command_output[auth_type_key][\"login\"][\"methods\"] != methods_with_group:\n                    self.result.is_failure(f\"AAA authentication methods {methods} are not matching for login console\")\n                    return\n\n            if command_output[auth_type_key][\"default\"][\"methods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authentication methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods.test","title":"test","text":"<pre><code>test(methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyAuthenMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA authentication methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of authentication types to verify. List elements must be: login, enable, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAuthenMethods validation.\n\n    Args:\n        methods: List of AAA authentication methods. Methods should be in the right order.\n        auth_types: List of authentication types to verify. List elements must be: login, enable, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"login\", \"enable\", \"dot1x\"])\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AuthenMethods\"\n\n        if auth_type_key == \"loginAuthenMethods\":\n            if not command_output[auth_type_key].get(\"login\"):\n                self.result.is_failure(\"AAA authentication methods are not configured for login console\")\n                return\n\n            if command_output[auth_type_key][\"login\"][\"methods\"] != methods_with_group:\n                self.result.is_failure(f\"AAA authentication methods {methods} are not matching for login console\")\n                return\n\n        if command_output[auth_type_key][\"default\"][\"methods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA authentication methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods","title":"VerifyAuthzMethods","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the AAA authorization method lists for different authorization types (commands, exec).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.</li> <li>failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.</li> <li>skipped: The test will be skipped if the AAA authentication method list or authorization type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthzMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authorization method lists for different authorization types (commands, exec).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.\n        * failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.\n        * skipped: The test will be skipped if the AAA authentication method list or authorization type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAuthzMethods\"\n    description = \"Verifies the AAA authorization method lists for different authorization types (commands, exec).\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show aaa methods authorization\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAuthzMethods validation.\n\n        Args:\n            methods: List of AAA authorization methods. Methods should be in the right order.\n            auth_types: List of authorization types to verify. List elements must be: commands, exec.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        _check_auth_type(auth_types, [\"commands\", \"exec\"])\n\n        methods_with_group = _check_group_methods(methods)\n\n        command_output = self.instance_commands[0].json_output\n\n        not_matching = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AuthzMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if command_output[auth_type_key][method_key][\"methods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authorization methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods.test","title":"test","text":"<pre><code>test(methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyAuthzMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA authorization methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of authorization types to verify. List elements must be: commands, exec.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAuthzMethods validation.\n\n    Args:\n        methods: List of AAA authorization methods. Methods should be in the right order.\n        auth_types: List of authorization types to verify. List elements must be: commands, exec.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    _check_auth_type(auth_types, [\"commands\", \"exec\"])\n\n    methods_with_group = _check_group_methods(methods)\n\n    command_output = self.instance_commands[0].json_output\n\n    not_matching = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AuthzMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if command_output[auth_type_key][method_key][\"methods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA authorization methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups","title":"VerifyTacacsServerGroups","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the provided TACACS server group(s) are configured.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS server group(s) are configured.</li> <li>failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.</li> <li>skipped: The test will be skipped if TACACS server group(s) are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServerGroups(AntaTest):\n\"\"\"\n    Verifies if the provided TACACS server group(s) are configured.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS server group(s) are configured.\n        * failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.\n        * skipped: The test will be skipped if TACACS server group(s) are not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsServerGroups\"\n    description = \"Verifies if the provided TACACS server group(s) are configured.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, groups: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTacacsServerGroups validation.\n\n        Args:\n            groups: List of TACACS server group.\n        \"\"\"\n        if not groups:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because groups were not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        tacacs_groups = command_output[\"groups\"]\n\n        if not tacacs_groups:\n            self.result.is_failure(\"No TACACS server group(s) are configured\")\n            return\n\n        not_configured = [group for group in groups if group not in tacacs_groups]\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS server group(s) {not_configured} are not configured\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups.test","title":"test","text":"<pre><code>test(groups: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyTacacsServerGroups validation.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>Optional[List[str]]</code> <p>List of TACACS server group.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, groups: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTacacsServerGroups validation.\n\n    Args:\n        groups: List of TACACS server group.\n    \"\"\"\n    if not groups:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because groups were not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    tacacs_groups = command_output[\"groups\"]\n\n    if not tacacs_groups:\n        self.result.is_failure(\"No TACACS server group(s) are configured\")\n        return\n\n    not_configured = [group for group in groups if group not in tacacs_groups]\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"TACACS server group(s) {not_configured} are not configured\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers","title":"VerifyTacacsServers","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies TACACS servers are configured for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if TACACS servers or VRF are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServers(AntaTest):\n\"\"\"\n    Verifies TACACS servers are configured for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS servers are configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.\n        * skipped: The test will be skipped if TACACS servers or VRF are not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsServers\"\n    description = \"Verifies TACACS servers are configured for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, servers: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyTacacsServers validation.\n\n        Args:\n            servers: List of TACACS servers IP addresses.\n            vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n        \"\"\"\n        if not servers or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because servers or vrf were not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        tacacs_servers = command_output[\"tacacsServers\"]\n\n        if not tacacs_servers:\n            self.result.is_failure(\"No TACACS servers are configured\")\n            return\n\n        not_configured = [\n            server\n            for server in servers\n            if not any(server == tacacs_server[\"serverInfo\"][\"hostname\"] and vrf == tacacs_server[\"serverInfo\"][\"vrf\"] for tacacs_server in tacacs_servers)\n        ]\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers.test","title":"test","text":"<pre><code>test(servers: Optional[List[str]] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifyTacacsServers validation.</p> <p>Parameters:</p> Name Type Description Default <code>servers</code> <code>Optional[List[str]]</code> <p>List of TACACS servers IP addresses.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport TACACS messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, servers: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyTacacsServers validation.\n\n    Args:\n        servers: List of TACACS servers IP addresses.\n        vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n    \"\"\"\n    if not servers or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because servers or vrf were not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    tacacs_servers = command_output[\"tacacsServers\"]\n\n    if not tacacs_servers:\n        self.result.is_failure(\"No TACACS servers are configured\")\n        return\n\n    not_configured = [\n        server\n        for server in servers\n        if not any(server == tacacs_server[\"serverInfo\"][\"hostname\"] and vrf == tacacs_server[\"serverInfo\"][\"vrf\"] for tacacs_server in tacacs_servers)\n    ]\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"TACACS servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf","title":"VerifyTacacsSourceIntf","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies TACACS source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if source-interface or VRF is not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsSourceIntf(AntaTest):\n\"\"\"\n    Verifies TACACS source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.\n        * skipped: The test will be skipped if source-interface or VRF is not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsSourceIntf\"\n    description = \"Verifies TACACS source-interface for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyTacacsSourceIntf validation.\n\n        Args:\n            intf: Source-interface to use as source IP of TACACS messages.\n            vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n        \"\"\"\n        if not intf or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        try:\n            if command_output[\"srcIntf\"][vrf] == intf:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"Wrong source-interface configured in VRF {vrf}\")\n\n        except KeyError:\n            self.result.is_failure(f\"Source-interface {intf} is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf.test","title":"test","text":"<pre><code>test(intf: Optional[str] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifyTacacsSourceIntf validation.</p> <p>Parameters:</p> Name Type Description Default <code>intf</code> <code>Optional[str]</code> <p>Source-interface to use as source IP of TACACS messages.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport TACACS messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyTacacsSourceIntf validation.\n\n    Args:\n        intf: Source-interface to use as source IP of TACACS messages.\n        vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n    \"\"\"\n    if not intf or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    try:\n        if command_output[\"srcIntf\"][vrf] == intf:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Wrong source-interface configured in VRF {vrf}\")\n\n    except KeyError:\n        self.result.is_failure(f\"Source-interface {intf} is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.configuration/","title":"Configuration","text":""},{"location":"api/tests.configuration/#anta-catalog-for-configuration-tests","title":"ANTA catalog for configuration tests","text":"<p>Test functions related to the device configuration</p>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyRunningConfigDiffs","title":"VerifyRunningConfigDiffs","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no difference between the running-config and the startup-config.</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyRunningConfigDiffs(AntaTest):\n\"\"\"\n    Verifies there is no difference between the running-config and the startup-config.\n    \"\"\"\n\n    name = \"VerifyRunningConfigDiffs\"\n    description = \"\"\n    categories = [\"configuration\"]\n    commands = [AntaCommand(command=\"show running-config diffs\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyRunningConfigDiffs validation\"\"\"\n        command_output = self.instance_commands[0].output\n        if command_output is None or command_output == \"\":\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            self.result.is_failure(str(command_output))\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyRunningConfigDiffs.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyRunningConfigDiffs validation</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyRunningConfigDiffs validation\"\"\"\n    command_output = self.instance_commands[0].output\n    if command_output is None or command_output == \"\":\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        self.result.is_failure(str(command_output))\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyZeroTouch","title":"VerifyZeroTouch","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies ZeroTouch is disabled.</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyZeroTouch(AntaTest):\n\"\"\"\n    Verifies ZeroTouch is disabled.\n    \"\"\"\n\n    name = \"VerifyZeroTouch\"\n    description = \"Verifies ZeroTouch is disabled.\"\n    categories = [\"configuration\"]\n    commands = [AntaCommand(command=\"show zerotouch\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyZeroTouch validation\"\"\"\n\n        command_output = self.instance_commands[0].output\n\n        assert isinstance(command_output, dict)\n        if command_output[\"mode\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"ZTP is NOT disabled\")\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyZeroTouch.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyZeroTouch validation</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyZeroTouch validation\"\"\"\n\n    command_output = self.instance_commands[0].output\n\n    assert isinstance(command_output, dict)\n    if command_output[\"mode\"] == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"ZTP is NOT disabled\")\n</code></pre>"},{"location":"api/tests.connectivity/","title":"Connectivity","text":""},{"location":"api/tests.connectivity/#anta-catalog-for-connectivity-tests","title":"ANTA catalog for connectivity tests","text":"<p>Test functions related to various connectivity checks</p>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability","title":"VerifyReachability","text":"<p>             Bases: <code>AntaTest</code></p> <p>Test network reachability to one or many destination IP(s).</p> Expected Results <ul> <li>success: The test will pass if all destination IP(s) are reachable.</li> <li>failure: The test will fail if one or many destination IP(s) are unreachable.</li> <li>error: The test will give an error if the destination IP(s) or the source interface/IP(s) are not provided as template_params.</li> </ul> Source code in <code>anta/tests/connectivity.py</code> <pre><code>class VerifyReachability(AntaTest):\n\"\"\"\n    Test network reachability to one or many destination IP(s).\n\n    Expected Results:\n        * success: The test will pass if all destination IP(s) are reachable.\n        * failure: The test will fail if one or many destination IP(s) are unreachable.\n        * error: The test will give an error if the destination IP(s) or the source interface/IP(s) are not provided as template_params.\n    \"\"\"\n\n    name = \"VerifyReachability\"\n    description = \"Test the network reachability to one or many destination IP(s).\"\n    categories = [\"connectivity\"]\n    template = AntaTemplate(template=\"ping {dst} source {src} repeat 2\")\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyReachability validation.\n        \"\"\"\n\n        failures = []\n\n        for command in self.instance_commands:\n            if command.params and (\"src\" and \"dst\") in command.params:\n                src, dst = command.params[\"src\"], command.params[\"dst\"]\n            else:\n                self.result.is_error(\"The destination IP(s) or the source interface/IP(s) are not provided as template_params\")\n                return\n\n            if \"2 received\" not in command.json_output[\"messages\"][0]:\n                failures.append((src, dst))\n\n        if not failures:\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"Connectivity test failed for the following source-destination pairs: {failures}\")\n</code></pre>"},{"location":"api/tests.connectivity/#anta.tests.connectivity.VerifyReachability.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyReachability validation.</p> Source code in <code>anta/tests/connectivity.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyReachability validation.\n    \"\"\"\n\n    failures = []\n\n    for command in self.instance_commands:\n        if command.params and (\"src\" and \"dst\") in command.params:\n            src, dst = command.params[\"src\"], command.params[\"dst\"]\n        else:\n            self.result.is_error(\"The destination IP(s) or the source interface/IP(s) are not provided as template_params\")\n            return\n\n        if \"2 received\" not in command.json_output[\"messages\"][0]:\n            failures.append((src, dst))\n\n    if not failures:\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"Connectivity test failed for the following source-destination pairs: {failures}\")\n</code></pre>"},{"location":"api/tests.field_notices/","title":"Field Notices","text":""},{"location":"api/tests.field_notices/#anta-catalog-for-field-notices-tests","title":"ANTA catalog for Field Notices tests","text":"<p>Test functions to flag field notices</p>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice44Resolution","title":"VerifyFieldNotice44Resolution","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization).</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice44Resolution(AntaTest):\n\"\"\"\n    Verifies the device is using an Aboot version that fix the bug discussed\n    in the field notice 44 (Aboot manages system settings prior to EOS initialization).\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44\n    \"\"\"\n\n    name = \"VerifyFieldNotice44Resolution\"\n    description = (\n        \"Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization)\"\n    )\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice44Resolution validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        devices = [\n            \"DCS-7010T-48\",\n            \"DCS-7010T-48-DC\",\n            \"DCS-7050TX-48\",\n            \"DCS-7050TX-64\",\n            \"DCS-7050TX-72\",\n            \"DCS-7050TX-72Q\",\n            \"DCS-7050TX-96\",\n            \"DCS-7050TX2-128\",\n            \"DCS-7050SX-64\",\n            \"DCS-7050SX-72\",\n            \"DCS-7050SX-72Q\",\n            \"DCS-7050SX2-72Q\",\n            \"DCS-7050SX-96\",\n            \"DCS-7050SX2-128\",\n            \"DCS-7050QX-32S\",\n            \"DCS-7050QX2-32S\",\n            \"DCS-7050SX3-48YC12\",\n            \"DCS-7050CX3-32S\",\n            \"DCS-7060CX-32S\",\n            \"DCS-7060CX2-32S\",\n            \"DCS-7060SX2-48YC6\",\n            \"DCS-7160-48YC6\",\n            \"DCS-7160-48TC6\",\n            \"DCS-7160-32CQ\",\n            \"DCS-7280SE-64\",\n            \"DCS-7280SE-68\",\n            \"DCS-7280SE-72\",\n            \"DCS-7150SC-24-CLD\",\n            \"DCS-7150SC-64-CLD\",\n            \"DCS-7020TR-48\",\n            \"DCS-7020TRA-48\",\n            \"DCS-7020SR-24C2\",\n            \"DCS-7020SRG-24C2\",\n            \"DCS-7280TR-48C6\",\n            \"DCS-7280TRA-48C6\",\n            \"DCS-7280SR-48C6\",\n            \"DCS-7280SRA-48C6\",\n            \"DCS-7280SRAM-48C6\",\n            \"DCS-7280SR2K-48C6-M\",\n            \"DCS-7280SR2-48YC6\",\n            \"DCS-7280SR2A-48YC6\",\n            \"DCS-7280SRM-40CX2\",\n            \"DCS-7280QR-C36\",\n            \"DCS-7280QRA-C36S\",\n        ]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n\n        model = command_output[\"modelName\"]\n        # TODO this list could be a regex\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"device is not impacted by FN044\")\n            return\n\n        for component in command_output[\"details\"][\"components\"]:\n            if component[\"name\"] == \"Aboot\":\n                aboot_version = component[\"version\"].split(\"-\")[2]\n        self.result.is_success()\n        if aboot_version.startswith(\"4.0.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"4.1.\") and int(aboot_version.split(\".\")[2]) &lt; 1:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.0.\") and int(aboot_version.split(\".\")[2]) &lt; 9:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.1.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice44Resolution.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyFieldNotice44Resolution validation</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice44Resolution validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    devices = [\n        \"DCS-7010T-48\",\n        \"DCS-7010T-48-DC\",\n        \"DCS-7050TX-48\",\n        \"DCS-7050TX-64\",\n        \"DCS-7050TX-72\",\n        \"DCS-7050TX-72Q\",\n        \"DCS-7050TX-96\",\n        \"DCS-7050TX2-128\",\n        \"DCS-7050SX-64\",\n        \"DCS-7050SX-72\",\n        \"DCS-7050SX-72Q\",\n        \"DCS-7050SX2-72Q\",\n        \"DCS-7050SX-96\",\n        \"DCS-7050SX2-128\",\n        \"DCS-7050QX-32S\",\n        \"DCS-7050QX2-32S\",\n        \"DCS-7050SX3-48YC12\",\n        \"DCS-7050CX3-32S\",\n        \"DCS-7060CX-32S\",\n        \"DCS-7060CX2-32S\",\n        \"DCS-7060SX2-48YC6\",\n        \"DCS-7160-48YC6\",\n        \"DCS-7160-48TC6\",\n        \"DCS-7160-32CQ\",\n        \"DCS-7280SE-64\",\n        \"DCS-7280SE-68\",\n        \"DCS-7280SE-72\",\n        \"DCS-7150SC-24-CLD\",\n        \"DCS-7150SC-64-CLD\",\n        \"DCS-7020TR-48\",\n        \"DCS-7020TRA-48\",\n        \"DCS-7020SR-24C2\",\n        \"DCS-7020SRG-24C2\",\n        \"DCS-7280TR-48C6\",\n        \"DCS-7280TRA-48C6\",\n        \"DCS-7280SR-48C6\",\n        \"DCS-7280SRA-48C6\",\n        \"DCS-7280SRAM-48C6\",\n        \"DCS-7280SR2K-48C6-M\",\n        \"DCS-7280SR2-48YC6\",\n        \"DCS-7280SR2A-48YC6\",\n        \"DCS-7280SRM-40CX2\",\n        \"DCS-7280QR-C36\",\n        \"DCS-7280QRA-C36S\",\n    ]\n    variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n\n    model = command_output[\"modelName\"]\n    # TODO this list could be a regex\n    for variant in variants:\n        model = model.replace(variant, \"\")\n    if model not in devices:\n        self.result.is_skipped(\"device is not impacted by FN044\")\n        return\n\n    for component in command_output[\"details\"][\"components\"]:\n        if component[\"name\"] == \"Aboot\":\n            aboot_version = component[\"version\"].split(\"-\")[2]\n    self.result.is_success()\n    if aboot_version.startswith(\"4.0.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"4.1.\") and int(aboot_version.split(\".\")[2]) &lt; 1:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"6.0.\") and int(aboot_version.split(\".\")[2]) &lt; 9:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"6.1.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice72Resolution","title":"VerifyFieldNotice72Resolution","text":"<p>             Bases: <code>AntaTest</code></p> <p>Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice72Resolution(AntaTest):\n\"\"\"\n    Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072\n    \"\"\"\n\n    name = \"VerifyFieldNotice72Resolution\"\n    description = \"Verifies if the device has exposeure to FN72, and if the issue has been mitigated\"\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice72Resolution validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        devices = [\"DCS-7280SR3-48YC8\", \"DCS-7280SR3K-48YC8\"]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n        model = command_output[\"modelName\"]\n\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"Platform is not impacted by FN072\")\n            return\n\n        serial = command_output[\"serialNumber\"]\n        number = int(serial[3:7])\n\n        if \"JPE\" not in serial and \"JAS\" not in serial:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JPE\" in serial and number &gt;= 2131:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JPE\" in serial and number &gt;= 2134:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        # Because each of the if checks above will return if taken, we only run the long\n        # check if we get this far\n        for entry in command_output[\"details\"][\"components\"]:\n            if entry[\"name\"] == \"FixedSystemvrm1\":\n                if int(entry[\"version\"]) &lt; 7:\n                    self.result.is_failure(\"Device is exposed to FN72\")\n                else:\n                    self.result.is_success(\"FN72 is mitigated\")\n                return\n        # We should never hit this point\n        self.result.is_error(\"Error in running test - FixedSystemvrm1 not found\")\n        return\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice72Resolution.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyFieldNotice72Resolution validation</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice72Resolution validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    devices = [\"DCS-7280SR3-48YC8\", \"DCS-7280SR3K-48YC8\"]\n    variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n    model = command_output[\"modelName\"]\n\n    for variant in variants:\n        model = model.replace(variant, \"\")\n    if model not in devices:\n        self.result.is_skipped(\"Platform is not impacted by FN072\")\n        return\n\n    serial = command_output[\"serialNumber\"]\n    number = int(serial[3:7])\n\n    if \"JPE\" not in serial and \"JAS\" not in serial:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3-48YC8\" and \"JPE\" in serial and number &gt;= 2131:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3K-48YC8\" and \"JPE\" in serial and number &gt;= 2134:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3K-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    # Because each of the if checks above will return if taken, we only run the long\n    # check if we get this far\n    for entry in command_output[\"details\"][\"components\"]:\n        if entry[\"name\"] == \"FixedSystemvrm1\":\n            if int(entry[\"version\"]) &lt; 7:\n                self.result.is_failure(\"Device is exposed to FN72\")\n            else:\n                self.result.is_success(\"FN72 is mitigated\")\n            return\n    # We should never hit this point\n    self.result.is_error(\"Error in running test - FixedSystemvrm1 not found\")\n    return\n</code></pre>"},{"location":"api/tests.hardware/","title":"Hardware","text":""},{"location":"api/tests.hardware/#anta-catalog-for-hardware-tests","title":"ANTA catalog for hardware tests","text":"<p>Test functions related to the hardware or environement</p>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyAdverseDrops","title":"VerifyAdverseDrops","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no adverse drops on DCS7280E and DCS7500E.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyAdverseDrops(AntaTest):\n\"\"\"\n    Verifies there is no adverse drops on DCS7280E and DCS7500E.\n    \"\"\"\n\n    name = \"VerifyAdverseDrops\"\n    description = \"Verifies there is no adverse drops on DCS7280E and DCS7500E\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show hardware counter drop\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyAdverseDrops validation\"\"\"\n        command_output = self.instance_commands[0].json_output\n        total_adverse_drop = command_output[\"totalAdverseDrops\"] if \"totalAdverseDrops\" in command_output.keys() else \"\"\n        if total_adverse_drop == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device TotalAdverseDrops counter is {total_adverse_drop}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyAdverseDrops.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyAdverseDrops validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyAdverseDrops validation\"\"\"\n    command_output = self.instance_commands[0].json_output\n    total_adverse_drop = command_output[\"totalAdverseDrops\"] if \"totalAdverseDrops\" in command_output.keys() else \"\"\n    if total_adverse_drop == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device TotalAdverseDrops counter is {total_adverse_drop}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling","title":"VerifyEnvironmentCooling","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the fans status is in the accepted states list.</p> <p>Default accepted states list is [\u2018ok\u2019]</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentCooling(AntaTest):\n\"\"\"\n    Verifies the fans status is in the accepted states list.\n\n    Default accepted states list is ['ok']\n    \"\"\"\n\n    name = \"VerifyEnvironmentCooling\"\n    description = \"Verifies the fans status is OK for fans\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyEnvironmentCooling validation\n\n        Args:\n            accepted_states: Accepted states list for fan status\n        \"\"\"\n        if accepted_states is None:\n            accepted_states = [\"ok\"]\n\n        command_output = self.instance_commands[0].json_output\n        self.result.is_success()\n        # First go through power supplies fans\n        for power_supply in command_output.get(\"powerSupplySlots\", []):\n            for fan in power_supply.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in accepted_states:\n                    if self.result.result == \"success\":\n                        self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                    self.result.is_failure(f\"Fan {fan['label']} on PowerSupply {power_supply['label']} has state '{state}'.\")\n        # Then go through Fan Trays\n        for fan_tray in command_output.get(\"fanTraySlots\", []):\n            for fan in fan_tray.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in accepted_states:\n                    if self.result.result == \"success\":\n                        self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                    self.result.is_failure(f\"Fan {fan['label']} on Fan Tray {fan_tray['label']} has state '{state}'.\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling.test","title":"test","text":"<pre><code>test(accepted_states: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyEnvironmentCooling validation</p> <p>Parameters:</p> Name Type Description Default <code>accepted_states</code> <code>Optional[List[str]]</code> <p>Accepted states list for fan status</p> <code>None</code> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyEnvironmentCooling validation\n\n    Args:\n        accepted_states: Accepted states list for fan status\n    \"\"\"\n    if accepted_states is None:\n        accepted_states = [\"ok\"]\n\n    command_output = self.instance_commands[0].json_output\n    self.result.is_success()\n    # First go through power supplies fans\n    for power_supply in command_output.get(\"powerSupplySlots\", []):\n        for fan in power_supply.get(\"fans\", []):\n            if (state := fan[\"status\"]) not in accepted_states:\n                if self.result.result == \"success\":\n                    self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                self.result.is_failure(f\"Fan {fan['label']} on PowerSupply {power_supply['label']} has state '{state}'.\")\n    # Then go through Fan Trays\n    for fan_tray in command_output.get(\"fanTraySlots\", []):\n        for fan in fan_tray.get(\"fans\", []):\n            if (state := fan[\"status\"]) not in accepted_states:\n                if self.result.result == \"success\":\n                    self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                self.result.is_failure(f\"Fan {fan['label']} on Fan Tray {fan_tray['label']} has state '{state}'.\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower","title":"VerifyEnvironmentPower","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the power supplies status is in the accepted states list</p> <p>The default accepted states list is [\u2018ok\u2019]</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentPower(AntaTest):\n\"\"\"\n    Verifies the power supplies status is in the accepted states list\n\n    The default accepted states list is ['ok']\n    \"\"\"\n\n    name = \"VerifyEnvironmentPower\"\n    description = \"Verifies the power supplies status is OK\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment power\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyEnvironmentPower validation\n\n        Args:\n            accepted_states: Accepted states list for power supplies\n        \"\"\"\n        if accepted_states is None:\n            accepted_states = [\"ok\"]\n        command_output = self.instance_commands[0].json_output\n        power_supplies = command_output[\"powerSupplies\"] if \"powerSupplies\" in command_output.keys() else \"{}\"\n        wrong_power_supplies = {\n            powersupply: {\"state\": value[\"state\"]} for powersupply, value in dict(power_supplies).items() if value[\"state\"] not in accepted_states\n        }\n        if not wrong_power_supplies:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following power supplies states are not in the accepted_states list {accepted_states}\")\n            self.result.messages.append(str(wrong_power_supplies))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower.test","title":"test","text":"<pre><code>test(accepted_states: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyEnvironmentPower validation</p> <p>Parameters:</p> Name Type Description Default <code>accepted_states</code> <code>Optional[List[str]]</code> <p>Accepted states list for power supplies</p> <code>None</code> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyEnvironmentPower validation\n\n    Args:\n        accepted_states: Accepted states list for power supplies\n    \"\"\"\n    if accepted_states is None:\n        accepted_states = [\"ok\"]\n    command_output = self.instance_commands[0].json_output\n    power_supplies = command_output[\"powerSupplies\"] if \"powerSupplies\" in command_output.keys() else \"{}\"\n    wrong_power_supplies = {\n        powersupply: {\"state\": value[\"state\"]} for powersupply, value in dict(power_supplies).items() if value[\"state\"] not in accepted_states\n    }\n    if not wrong_power_supplies:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following power supplies states are not in the accepted_states list {accepted_states}\")\n        self.result.messages.append(str(wrong_power_supplies))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentSystemCooling","title":"VerifyEnvironmentSystemCooling","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the System Cooling is ok.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentSystemCooling(AntaTest):\n\"\"\"\n    Verifies the System Cooling is ok.\n    \"\"\"\n\n    name = \"VerifyEnvironmentSystemCooling\"\n    description = \"Verifies the fans status is OK for fans\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n        sys_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n\n        self.result.is_success()\n        if sys_status != \"coolingOk\":\n            self.result.is_failure(f\"Device System cooling is not OK: {sys_status}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentSystemCooling.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyEnvironmentCooling validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n    sys_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n\n    self.result.is_success()\n    if sys_status != \"coolingOk\":\n        self.result.is_failure(f\"Device System cooling is not OK: {sys_status}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTemperature","title":"VerifyTemperature","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies device temparture is currently OK (temperatureOK).</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK (temperatureOK).\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK (temperatureOK)\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = self.instance_commands[0].json_output\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTemperature.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyTemperature validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n    command_output = self.instance_commands[0].json_output\n    temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n    if temperature_status == \"temperatureOk\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers","title":"VerifyTransceiversManufacturers","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies Manufacturers of all Transceivers.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversManufacturers(AntaTest):\n\"\"\"\n    Verifies Manufacturers of all Transceivers.\n    \"\"\"\n\n    name = \"VerifyTransceiversManufacturers\"\n    description = \"\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show inventory\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTransceiversManufacturers validation\n\n        Args:\n            manufacturers: List of allowed transceivers manufacturers.\n        \"\"\"\n        if not manufacturers:\n            self.result.is_skipped(f\"{self.__class__.name} was not run as no manufacturers were given\")\n        else:\n            command_output = self.instance_commands[0].json_output\n            wrong_manufacturers = {interface: value[\"mfgName\"] for interface, value in command_output[\"xcvrSlots\"].items() if value[\"mfgName\"] not in manufacturers}\n            if not wrong_manufacturers:\n                self.result.is_success()\n            else:\n                self.result.is_failure(\"The following interfaces have transceivers from unauthorized manufacturers\")\n                self.result.messages.append(str(wrong_manufacturers))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers.test","title":"test","text":"<pre><code>test(manufacturers: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyTransceiversManufacturers validation</p> <p>Parameters:</p> Name Type Description Default <code>manufacturers</code> <code>Optional[List[str]]</code> <p>List of allowed transceivers manufacturers.</p> <code>None</code> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTransceiversManufacturers validation\n\n    Args:\n        manufacturers: List of allowed transceivers manufacturers.\n    \"\"\"\n    if not manufacturers:\n        self.result.is_skipped(f\"{self.__class__.name} was not run as no manufacturers were given\")\n    else:\n        command_output = self.instance_commands[0].json_output\n        wrong_manufacturers = {interface: value[\"mfgName\"] for interface, value in command_output[\"xcvrSlots\"].items() if value[\"mfgName\"] not in manufacturers}\n        if not wrong_manufacturers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following interfaces have transceivers from unauthorized manufacturers\")\n            self.result.messages.append(str(wrong_manufacturers))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversTemperature","title":"VerifyTransceiversTemperature","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies Transceivers temperature is currently OK.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversTemperature(AntaTest):\n\"\"\"\n    Verifies Transceivers temperature is currently OK.\n    \"\"\"\n\n    name = \"VerifyTransceiversTemperature\"\n    description = \"Verifies Transceivers temperature is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaCommand(command=\"show system environment temperature transceiver\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTransceiversTemperature validation\"\"\"\n        command_output = self.instance_commands[0].json_output\n        sensors = command_output[\"tempSensors\"] if \"tempSensors\" in command_output.keys() else \"\"\n        wrong_sensors = {\n            sensor[\"name\"]: {\n                \"hwStatus\": sensor[\"hwStatus\"],\n                \"alertCount\": sensor[\"alertCount\"],\n            }\n            for sensor in sensors\n            if sensor[\"hwStatus\"] != \"ok\" or sensor[\"alertCount\"] != 0\n        }\n        if not wrong_sensors:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following sensors do not have the correct temperature or had alarms in the past:\")\n            self.result.messages.append(str(wrong_sensors))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversTemperature.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyTransceiversTemperature validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyTransceiversTemperature validation\"\"\"\n    command_output = self.instance_commands[0].json_output\n    sensors = command_output[\"tempSensors\"] if \"tempSensors\" in command_output.keys() else \"\"\n    wrong_sensors = {\n        sensor[\"name\"]: {\n            \"hwStatus\": sensor[\"hwStatus\"],\n            \"alertCount\": sensor[\"alertCount\"],\n        }\n        for sensor in sensors\n        if sensor[\"hwStatus\"] != \"ok\" or sensor[\"alertCount\"] != 0\n    }\n    if not wrong_sensors:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"The following sensors do not have the correct temperature or had alarms in the past:\")\n        self.result.messages.append(str(wrong_sensors))\n</code></pre>"},{"location":"api/tests.interfaces/","title":"Interfaces","text":""},{"location":"api/tests.interfaces/#anta-catalog-for-interfaces-tests","title":"ANTA catalog for interfaces tests","text":"<p>Test functions related to the device interfaces</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIPProxyARP","title":"VerifyIPProxyARP","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if Proxy-ARP is enabled for the provided list of interface(s).</p> Expected Results <ul> <li>success: The test will pass if Proxy-ARP is enabled on the specified interface(s).</li> <li>failure: The test will fail if Proxy-ARP is disabled on the specified interface(s).</li> <li>error: The test will give an error if a list of interface(s) is not provided as template_params.</li> </ul> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyIPProxyARP(AntaTest):\n\"\"\"\n    Verifies if Proxy-ARP is enabled for the provided list of interface(s).\n\n    Expected Results:\n        * success: The test will pass if Proxy-ARP is enabled on the specified interface(s).\n        * failure: The test will fail if Proxy-ARP is disabled on the specified interface(s).\n        * error: The test will give an error if a list of interface(s) is not provided as template_params.\n\n    \"\"\"\n\n    name = \"VerifyIPProxyARP\"\n    description = \"Verifies if Proxy-ARP is enabled for the provided list of interface(s).\"\n    categories = [\"interfaces\"]\n    template = AntaTemplate(template=\"show ip interface {intf}\")\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyIPProxyARP validation.\n        \"\"\"\n\n        disabled_intf = []\n        for command in self.instance_commands:\n            if command.params and \"intf\" in command.params:\n                intf = command.params[\"intf\"]\n            if not command.json_output[\"interfaces\"][intf][\"proxyArp\"]:\n                disabled_intf.append(intf)\n\n        if disabled_intf:\n            self.result.is_failure(f\"The following interface(s) have Proxy-ARP disabled: {disabled_intf}\")\n\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIPProxyARP.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyIPProxyARP validation.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyIPProxyARP validation.\n    \"\"\"\n\n    disabled_intf = []\n    for command in self.instance_commands:\n        if command.params and \"intf\" in command.params:\n            intf = command.params[\"intf\"]\n        if not command.json_output[\"interfaces\"][intf][\"proxyArp\"]:\n            disabled_intf.append(intf)\n\n    if disabled_intf:\n        self.result.is_failure(f\"The following interface(s) have Proxy-ARP disabled: {disabled_intf}\")\n\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIllegalLACP","title":"VerifyIllegalLACP","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no illegal LACP packets received.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyIllegalLACP(AntaTest):\n\"\"\"\n    Verifies there is no illegal LACP packets received.\n    \"\"\"\n\n    name = \"VerifyIllegalLACP\"\n    description = \"Verifies there is no illegal LACP packets received.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show lacp counters all-ports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyIllegalLACP validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        po_with_illegal_lacp: List[Dict[str, Dict[str, int]]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            po_with_illegal_lacp.extend(\n                {portchannel: interface} for interface, interface_dict in portchannel_dict[\"interfaces\"].items() if interface_dict[\"illegalRxCount\"] != 0\n            )\n\n        if not po_with_illegal_lacp:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following port-channels have recieved illegal lacp packets on the \" f\"following ports: {po_with_illegal_lacp}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIllegalLACP.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyIllegalLACP validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyIllegalLACP validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    po_with_illegal_lacp: List[Dict[str, Dict[str, int]]] = []\n    for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n        po_with_illegal_lacp.extend(\n            {portchannel: interface} for interface, interface_dict in portchannel_dict[\"interfaces\"].items() if interface_dict[\"illegalRxCount\"] != 0\n        )\n\n    if not po_with_illegal_lacp:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"The following port-channels have recieved illegal lacp packets on the \" f\"following ports: {po_with_illegal_lacp}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceDiscards","title":"VerifyInterfaceDiscards","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies interfaces packet discard counters are equal to zero.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceDiscards(AntaTest):\n\"\"\"\n    Verifies interfaces packet discard counters are equal to zero.\n    \"\"\"\n\n    name = \"VerifyInterfaceDiscards\"\n    description = \"Verifies interfaces packet discard counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces counters discards\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceDiscards validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n\n        for interface, outer_v in command_output[\"interfaces\"].items():\n            wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have non 0 discard counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceDiscards.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyInterfaceDiscards validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceDiscards validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n\n    for interface, outer_v in command_output[\"interfaces\"].items():\n        wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have non 0 discard counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrDisabled","title":"VerifyInterfaceErrDisabled","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no interface in error disable state.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrDisabled(AntaTest):\n\"\"\"\n    Verifies there is no interface in error disable state.\n    \"\"\"\n\n    name = \"VerifyInterfaceErrDisabled\"\n    description = \"Verifies there is no interface in error disable state.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces status\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceErrDisabled validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        errdisabled_interfaces = [interface for interface, value in command_output[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n\n        if errdisabled_interfaces:\n            self.result.is_failure(f\"The following interfaces are in error disabled state: {errdisabled_interfaces}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrDisabled.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyInterfaceErrDisabled validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceErrDisabled validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    errdisabled_interfaces = [interface for interface, value in command_output[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n\n    if errdisabled_interfaces:\n        self.result.is_failure(f\"The following interfaces are in error disabled state: {errdisabled_interfaces}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrors","title":"VerifyInterfaceErrors","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies interfaces error counters are equal to zero.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrors(AntaTest):\n\"\"\"\n    Verifies interfaces error counters are equal to zero.\n    \"\"\"\n\n    name = \"VerifyInterfaceErrors\"\n    description = \"Verifies interfaces error counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces counters errors\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n        for interface, outer_v in command_output[\"interfaceErrorCounters\"].items():\n            wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have non 0 error counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrors.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyInterfaceUtilization validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n    for interface, outer_v in command_output[\"interfaceErrorCounters\"].items():\n        wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have non 0 error counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceUtilization","title":"VerifyInterfaceUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies interfaces utilization is below 75%.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceUtilization(AntaTest):\n\"\"\"\n    Verifies interfaces utilization is below 75%.\n    \"\"\"\n\n    name = \"VerifyInterfaceUtilization\"\n    description = \"Verifies interfaces utilization is below 75%.\"\n    categories = [\"interfaces\"]\n    # TODO - move from text to json if possible\n    commands = [AntaCommand(command=\"show interfaces counters rates\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n        command_output = self.instance_commands[0].text_output\n\n        wrong_interfaces = {}\n        for line in command_output.split(\"\\n\")[1:]:\n            if len(line) &gt; 0:\n                if line.split()[-5] == \"-\" or line.split()[-2] == \"-\":\n                    pass\n                elif float(line.split()[-5].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-5]\n                elif float(line.split()[-2].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-2]\n\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have a usage &gt; 75%: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceUtilization.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyInterfaceUtilization validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n\n    command_output = self.instance_commands[0].text_output\n\n    wrong_interfaces = {}\n    for line in command_output.split(\"\\n\")[1:]:\n        if len(line) &gt; 0:\n            if line.split()[-5] == \"-\" or line.split()[-2] == \"-\":\n                pass\n            elif float(line.split()[-5].replace(\"%\", \"\")) &gt; 75.0:\n                wrong_interfaces[line.split()[0]] = line.split()[-5]\n            elif float(line.split()[-2].replace(\"%\", \"\")) &gt; 75.0:\n                wrong_interfaces[line.split()[0]] = line.split()[-2]\n\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have a usage &gt; 75%: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus","title":"VerifyInterfacesStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfacesStatus(AntaTest):\n\"\"\"\n    Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.\n    \"\"\"\n\n    name = \"VerifyInterfacesStatus\"\n    description = \"Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces description\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyInterfacesStatus validation\n\n        Args:\n            minimum: Expected minimum number of Ethernet interfaces up/up.\n        \"\"\"\n\n        if minimum is None or minimum &lt; 0:\n            self.result.is_skipped(f\"VerifyInterfacesStatus was not run as an invalid minimum value was given {minimum}.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        count_up_up = 0\n        other_ethernet_interfaces = []\n\n        for interface in command_output[\"interfaceDescriptions\"]:\n            interface_dict = command_output[\"interfaceDescriptions\"][interface]\n            if \"Ethernet\" in interface:\n                if re.match(r\"connected|up\", interface_dict[\"lineProtocolStatus\"]) and re.match(r\"connected|up\", interface_dict[\"interfaceStatus\"]):\n                    count_up_up += 1\n                else:\n                    other_ethernet_interfaces.append(interface)\n\n        if count_up_up &gt;= minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Only {count_up_up}, less than {minimum} Ethernet interfaces are UP/UP\")\n            self.result.messages.append(f\"The following Ethernet interfaces are not UP/UP: {other_ethernet_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus.test","title":"test","text":"<pre><code>test(minimum: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyInterfacesStatus validation</p> <p>Parameters:</p> Name Type Description Default <code>minimum</code> <code>Optional[int]</code> <p>Expected minimum number of Ethernet interfaces up/up.</p> <code>None</code> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyInterfacesStatus validation\n\n    Args:\n        minimum: Expected minimum number of Ethernet interfaces up/up.\n    \"\"\"\n\n    if minimum is None or minimum &lt; 0:\n        self.result.is_skipped(f\"VerifyInterfacesStatus was not run as an invalid minimum value was given {minimum}.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    count_up_up = 0\n    other_ethernet_interfaces = []\n\n    for interface in command_output[\"interfaceDescriptions\"]:\n        interface_dict = command_output[\"interfaceDescriptions\"][interface]\n        if \"Ethernet\" in interface:\n            if re.match(r\"connected|up\", interface_dict[\"lineProtocolStatus\"]) and re.match(r\"connected|up\", interface_dict[\"interfaceStatus\"]):\n                count_up_up += 1\n            else:\n                other_ethernet_interfaces.append(interface)\n\n    if count_up_up &gt;= minimum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Only {count_up_up}, less than {minimum} Ethernet interfaces are UP/UP\")\n        self.result.messages.append(f\"The following Ethernet interfaces are not UP/UP: {other_ethernet_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU","title":"VerifyL3MTU","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the global layer 3 Maximum Transfer Unit (MTU) for all layer 3 interfaces.</p> Expected Results <ul> <li>success: The test will pass if all layer 3 interfaces have the proper MTU configured.</li> <li>failure: The test will fail if one or many layer 3 interfaces have the wrong MTU configured.</li> <li>skipped: The test will be skipped if the MTU value is not provided.</li> </ul> Limitations <ul> <li>Only Ethernet, Port-Channel, Vlan interfaces are supported.</li> <li>Other interface types, like Management, Loopback, Vxlan, Tunnel are currently not supported.</li> </ul> <p>https://www.arista.com/en/support/toi/eos-4-23-1f/14388-global-knob-to-set-mtu-for-all-layer-3-interfaces</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyL3MTU(AntaTest):\n\"\"\"\n    Verifies the global layer 3 Maximum Transfer Unit (MTU) for all layer 3 interfaces.\n\n    Expected Results:\n        * success: The test will pass if all layer 3 interfaces have the proper MTU configured.\n        * failure: The test will fail if one or many layer 3 interfaces have the wrong MTU configured.\n        * skipped: The test will be skipped if the MTU value is not provided.\n\n    Limitations:\n        * Only Ethernet, Port-Channel, Vlan interfaces are supported.\n        * Other interface types, like Management, Loopback, Vxlan, Tunnel are currently not supported.\n\n    https://www.arista.com/en/support/toi/eos-4-23-1f/14388-global-knob-to-set-mtu-for-all-layer-3-interfaces\n\n    \"\"\"\n\n    name = \"VerifyL3MTU\"\n    description = \"Verifies the global layer 3 Maximum Transfer Unit (MTU) for all layer 3 interfaces.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show interfaces\")]\n\n    NOT_SUPPORTED_INTERFACES: List[str] = [\"Management\", \"Loopback\", \"Vxlan\", \"Tunnel\"]\n\n    @AntaTest.anta_test\n    def test(self, mtu: int = 1500) -&gt; None:\n\"\"\"\n        Run VerifyL3MTU validation\n\n        Args:\n          mtu: Layer 3 MTU to verify. Defaults to 1500.\n\n        \"\"\"\n\n        if not mtu:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because mtu was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        wrong_l3mtu_intf = []\n\n        for interface, values in command_output[\"interfaces\"].items():\n            if re.sub(r\"\\d+$\", \"\", interface) not in self.NOT_SUPPORTED_INTERFACES:\n                if values[\"forwardingModel\"] == \"routed\" and values[\"mtu\"] != mtu:\n                    wrong_l3mtu_intf.append(interface)\n\n        if not wrong_l3mtu_intf:\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"The following interface(s) have the wrong MTU configured: {wrong_l3mtu_intf}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyL3MTU.test","title":"test","text":"<pre><code>test(mtu: int = 1500) -&gt; None\n</code></pre> <p>Run VerifyL3MTU validation</p> <p>Parameters:</p> Name Type Description Default <code>mtu</code> <code>int</code> <p>Layer 3 MTU to verify. Defaults to 1500.</p> <code>1500</code> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, mtu: int = 1500) -&gt; None:\n\"\"\"\n    Run VerifyL3MTU validation\n\n    Args:\n      mtu: Layer 3 MTU to verify. Defaults to 1500.\n\n    \"\"\"\n\n    if not mtu:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because mtu was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    wrong_l3mtu_intf = []\n\n    for interface, values in command_output[\"interfaces\"].items():\n        if re.sub(r\"\\d+$\", \"\", interface) not in self.NOT_SUPPORTED_INTERFACES:\n            if values[\"forwardingModel\"] == \"routed\" and values[\"mtu\"] != mtu:\n                wrong_l3mtu_intf.append(interface)\n\n    if not wrong_l3mtu_intf:\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"The following interface(s) have the wrong MTU configured: {wrong_l3mtu_intf}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount","title":"VerifyLoopbackCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyLoopbackCount(AntaTest):\n\"\"\"\n    Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\n    \"\"\"\n\n    name = \"VerifyLoopbackCount\"\n    description = \"Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show ip interface brief\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyLoopbackCount validation\n\n        Args:\n            number: Number of loopback interfaces expected to be present.\n        \"\"\"\n\n        if number is None:\n            self.result.is_skipped(\"VerifyLoopbackCount was not run as no number value was given.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        loopback_count = 0\n        down_loopback_interfaces = []\n\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Loopback\" in interface:\n                loopback_count += 1\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_loopback_interfaces.append(interface)\n\n        if loopback_count == number and len(down_loopback_interfaces) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if loopback_count != number:\n                self.result.is_failure(f\"Found {loopback_count} Loopbacks when expecting {number}\")\n            elif len(down_loopback_interfaces) != 0:\n                self.result.is_failure(f\"The following Loopbacks are not up: {down_loopback_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount.test","title":"test","text":"<pre><code>test(number: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyLoopbackCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>Number of loopback interfaces expected to be present.</p> <code>None</code> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyLoopbackCount validation\n\n    Args:\n        number: Number of loopback interfaces expected to be present.\n    \"\"\"\n\n    if number is None:\n        self.result.is_skipped(\"VerifyLoopbackCount was not run as no number value was given.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    loopback_count = 0\n    down_loopback_interfaces = []\n\n    for interface in command_output[\"interfaces\"]:\n        interface_dict = command_output[\"interfaces\"][interface]\n        if \"Loopback\" in interface:\n            loopback_count += 1\n            if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                down_loopback_interfaces.append(interface)\n\n    if loopback_count == number and len(down_loopback_interfaces) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if loopback_count != number:\n            self.result.is_failure(f\"Found {loopback_count} Loopbacks when expecting {number}\")\n        elif len(down_loopback_interfaces) != 0:\n            self.result.is_failure(f\"The following Loopbacks are not up: {down_loopback_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyPortChannels","title":"VerifyPortChannels","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no inactive port in port channels.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyPortChannels(AntaTest):\n\"\"\"\n    Verifies there is no inactive port in port channels.\n    \"\"\"\n\n    name = \"VerifyPortChannels\"\n    description = \"Verifies there is no inactive port in port channels.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show port-channel\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyPortChannels validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        po_with_invactive_ports: List[Dict[str, str]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            if len(portchannel_dict[\"inactivePorts\"]) != 0:\n                po_with_invactive_ports.extend({portchannel: portchannel_dict[\"inactivePorts\"]})\n\n        if not po_with_invactive_ports:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following port-channels have inactive port(s): {po_with_invactive_ports}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyPortChannels.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyPortChannels validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyPortChannels validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    po_with_invactive_ports: List[Dict[str, str]] = []\n    for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n        if len(portchannel_dict[\"inactivePorts\"]) != 0:\n            po_with_invactive_ports.extend({portchannel: portchannel_dict[\"inactivePorts\"]})\n\n    if not po_with_invactive_ports:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following port-channels have inactive port(s): {po_with_invactive_ports}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySVI","title":"VerifySVI","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no interface vlan down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifySVI(AntaTest):\n\"\"\"\n    Verifies there is no interface vlan down.\n    \"\"\"\n\n    name = \"VerifySVI\"\n    description = \"Verifies there is no interface vlan down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show ip interface brief\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifySVI validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        down_svis = []\n\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Vlan\" in interface:\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_svis.append(interface)\n\n        if len(down_svis) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following SVIs are not up: {down_svis}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySVI.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifySVI validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifySVI validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    down_svis = []\n\n    for interface in command_output[\"interfaces\"]:\n        interface_dict = command_output[\"interfaces\"][interface]\n        if \"Vlan\" in interface:\n            if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                down_svis.append(interface)\n\n    if len(down_svis) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following SVIs are not up: {down_svis}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyStormControlDrops","title":"VerifyStormControlDrops","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device did not drop packets due its to storm-control configuration.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyStormControlDrops(AntaTest):\n\"\"\"\n    Verifies the device did not drop packets due its to storm-control configuration.\n    \"\"\"\n\n    name = \"VerifyStormControlDrops\"\n    description = \"Verifies the device did not drop packets due its to storm-control configuration.\"\n    categories = [\"interfaces\"]\n    commands = [AntaCommand(command=\"show storm-control\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyStormControlDrops validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        storm_controlled_interfaces: Dict[str, Dict[str, Any]] = {}\n        for interface, interface_dict in command_output[\"interfaces\"].items():\n            for traffic_type, traffic_type_dict in interface_dict[\"trafficTypes\"].items():\n                if \"drop\" in traffic_type_dict and traffic_type_dict[\"drop\"] != 0:\n                    storm_controlled_interface_dict = storm_controlled_interfaces.setdefault(interface, {})\n                    storm_controlled_interface_dict.update({traffic_type: traffic_type_dict[\"drop\"]})\n\n        if not storm_controlled_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have none 0 storm-control drop counters {storm_controlled_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyStormControlDrops.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyStormControlDrops validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyStormControlDrops validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    storm_controlled_interfaces: Dict[str, Dict[str, Any]] = {}\n    for interface, interface_dict in command_output[\"interfaces\"].items():\n        for traffic_type, traffic_type_dict in interface_dict[\"trafficTypes\"].items():\n            if \"drop\" in traffic_type_dict and traffic_type_dict[\"drop\"] != 0:\n                storm_controlled_interface_dict = storm_controlled_interfaces.setdefault(interface, {})\n                storm_controlled_interface_dict.update({traffic_type: traffic_type_dict[\"drop\"]})\n\n    if not storm_controlled_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have none 0 storm-control drop counters {storm_controlled_interfaces}\")\n</code></pre>"},{"location":"api/tests.logging/","title":"Logging","text":""},{"location":"api/tests.logging/#anta-catalog-for-logging-tests","title":"ANTA catalog for logging tests","text":"<p>Test functions related to the EOS various logging settings</p> <p>NOTE: \u2018show logging\u2019 does not support json output yet</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingAccounting","title":"VerifyLoggingAccounting","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if AAA accounting logs are generated.</p> Expected Results <ul> <li>success: The test will pass if AAA accounting logs are generated.</li> <li>failure: The test will fail if AAA accounting logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingAccounting(AntaTest):\n\"\"\"\n    Verifies if AAA accounting logs are generated.\n\n    Expected Results:\n        * success: The test will pass if AAA accounting logs are generated.\n        * failure: The test will fail if AAA accounting logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingAccounting\"\n    description = \"Verifies if AAA accounting logs are generated.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show aaa accounting logs | tail\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingAccountingvalidation.\n        \"\"\"\n        pattern = r\"cmd=show aaa accounting logs\"\n        output = self.instance_commands[0].text_output\n\n        if re.search(pattern, output):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"AAA accounting logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingAccounting.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyLoggingAccountingvalidation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingAccountingvalidation.\n    \"\"\"\n    pattern = r\"cmd=show aaa accounting logs\"\n    output = self.instance_commands[0].text_output\n\n    if re.search(pattern, output):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"AAA accounting logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHostname","title":"VerifyLoggingHostname","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the device FQDN.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the device FQDN.</li> <li>failure: The test will fail if logs are NOT generated with the device FQDN.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHostname(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the device FQDN.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the device FQDN.\n        * failure: The test will fail if logs are NOT generated with the device FQDN.\n    \"\"\"\n\n    name = \"VerifyLoggingHostname\"\n    description = \"Verifies if logs are generated with the device FQDN.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"show hostname\"),\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingHostname validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingHostname validation.\n        \"\"\"\n        output_hostname = self.instance_commands[0].json_output\n        output_logging = self.instance_commands[2].text_output\n        fqdn = output_hostname[\"fqdn\"]\n        lines = output_logging.strip().split(\"\\n\")[::-1]\n\n        log_pattern = r\"ANTA VerifyLoggingHostname validation\"\n\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n\n        if fqdn in last_line_with_pattern:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the device FQDN\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHostname.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyLoggingHostname validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingHostname validation.\n    \"\"\"\n    output_hostname = self.instance_commands[0].json_output\n    output_logging = self.instance_commands[2].text_output\n    fqdn = output_hostname[\"fqdn\"]\n    lines = output_logging.strip().split(\"\\n\")[::-1]\n\n    log_pattern = r\"ANTA VerifyLoggingHostname validation\"\n\n    last_line_with_pattern = \"\"\n    for line in lines:\n        if re.search(log_pattern, line):\n            last_line_with_pattern = line\n            break\n\n    if fqdn in last_line_with_pattern:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Logs are not generated with the device FQDN\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts","title":"VerifyLoggingHosts","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies logging hosts (syslog servers) for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided syslog servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if syslog servers or VRF are not provided.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHosts(AntaTest):\n\"\"\"\n    Verifies logging hosts (syslog servers) for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided syslog servers are configured in the specified VRF.\n        * failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.\n        * skipped: The test will be skipped if syslog servers or VRF are not provided.\n    \"\"\"\n\n    name = \"VerifyLoggingHosts\"\n    description = \"Verifies logging hosts (syslog servers) for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show logging\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self, hosts: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyLoggingHosts validation.\n\n        Args:\n            hosts: List of hosts (syslog servers) IP addresses.\n            vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n        \"\"\"\n        if not hosts or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because hosts or vrf were not supplied\")\n            return\n\n        output = self.instance_commands[0].text_output\n\n        not_configured = []\n\n        for host in hosts:\n            pattern = rf\"Logging to '{host}'.*VRF {vrf}\"\n            if not re.search(pattern, _get_logging_states(self.logger, output)):\n                not_configured.append(host)\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Syslog servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts.test","title":"test","text":"<pre><code>test(hosts: Optional[List[str]] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifyLoggingHosts validation.</p> <p>Parameters:</p> Name Type Description Default <code>hosts</code> <code>Optional[List[str]]</code> <p>List of hosts (syslog servers) IP addresses.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport log messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, hosts: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyLoggingHosts validation.\n\n    Args:\n        hosts: List of hosts (syslog servers) IP addresses.\n        vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n    \"\"\"\n    if not hosts or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because hosts or vrf were not supplied\")\n        return\n\n    output = self.instance_commands[0].text_output\n\n    not_configured = []\n\n    for host in hosts:\n        pattern = rf\"Logging to '{host}'.*VRF {vrf}\"\n        if not re.search(pattern, _get_logging_states(self.logger, output)):\n            not_configured.append(host)\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Syslog servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingLogsGeneration","title":"VerifyLoggingLogsGeneration","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated.</p> Expected Results <ul> <li>success: The test will pass if logs are generated.</li> <li>failure: The test will fail if logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingLogsGeneration(AntaTest):\n\"\"\"\n    Verifies if logs are generated.\n\n    Expected Results:\n        * success: The test will pass if logs are generated.\n        * failure: The test will fail if logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingLogsGeneration\"\n    description = \"Verifies if logs are generated.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingLogsGeneration validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingLogs validation.\n        \"\"\"\n        log_pattern = r\"ANTA VerifyLoggingLogsGeneration validation\"\n\n        output = self.instance_commands[1].text_output\n        lines = output.strip().split(\"\\n\")[::-1]\n\n        for line in lines:\n            if re.search(log_pattern, line):\n                self.result.is_success()\n                return\n\n        self.result.is_failure(\"Logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingLogsGeneration.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyLoggingLogs validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingLogs validation.\n    \"\"\"\n    log_pattern = r\"ANTA VerifyLoggingLogsGeneration validation\"\n\n    output = self.instance_commands[1].text_output\n    lines = output.strip().split(\"\\n\")[::-1]\n\n    for line in lines:\n        if re.search(log_pattern, line):\n            self.result.is_success()\n            return\n\n    self.result.is_failure(\"Logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingPersistent","title":"VerifyLoggingPersistent","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logging persistent is enabled and logs are saved in flash.</p> Expected Results <ul> <li>success: The test will pass if logging persistent is enabled and logs are in flash.</li> <li>failure: The test will fail if logging persistent is disabled or no logs are saved in flash.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingPersistent(AntaTest):\n\"\"\"\n    Verifies if logging persistent is enabled and logs are saved in flash.\n\n    Expected Results:\n        * success: The test will pass if logging persistent is enabled and logs are in flash.\n        * failure: The test will fail if logging persistent is disabled or no logs are saved in flash.\n    \"\"\"\n\n    name = \"VerifyLoggingPersistent\"\n    description = \"Verifies if logging persistent is enabled and logs are saved in flash.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"show logging\", ofmt=\"text\"),\n        AntaCommand(command=\"dir flash:/persist/messages\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingPersistent validation.\n        \"\"\"\n        self.result.is_success()\n\n        log_output = self.instance_commands[0].text_output\n        dir_flash_output = self.instance_commands[1].text_output\n\n        if \"Persistent logging: disabled\" in _get_logging_states(self.logger, log_output):\n            self.result.is_failure(\"Persistent logging is disabled\")\n            return\n\n        pattern = r\"-rw-\\s+(\\d+)\"\n        persist_logs = re.search(pattern, dir_flash_output)\n\n        if not persist_logs or int(persist_logs.group(1)) == 0:\n            self.result.is_failure(\"No persistent logs are saved in flash\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingPersistent.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyLoggingPersistent validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingPersistent validation.\n    \"\"\"\n    self.result.is_success()\n\n    log_output = self.instance_commands[0].text_output\n    dir_flash_output = self.instance_commands[1].text_output\n\n    if \"Persistent logging: disabled\" in _get_logging_states(self.logger, log_output):\n        self.result.is_failure(\"Persistent logging is disabled\")\n        return\n\n    pattern = r\"-rw-\\s+(\\d+)\"\n    persist_logs = re.search(pattern, dir_flash_output)\n\n    if not persist_logs or int(persist_logs.group(1)) == 0:\n        self.result.is_failure(\"No persistent logs are saved in flash\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf","title":"VerifyLoggingSourceIntf","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies logging source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided logging source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if source-interface or VRF is not provided.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingSourceIntf(AntaTest):\n\"\"\"\n    Verifies logging source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided logging source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.\n        * skipped: The test will be skipped if source-interface or VRF is not provided.\n    \"\"\"\n\n    name = \"VerifyLoggingSourceInt\"\n    description = \"Verifies logging source-interface for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaCommand(command=\"show logging\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyLoggingSrcDst validation.\n\n        Args:\n            intf: Source-interface to use as source IP of log messages.\n            vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n        \"\"\"\n        if not intf or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n            return\n\n        output = self.instance_commands[0].text_output\n\n        pattern = rf\"Logging source-interface '{intf}'.*VRF {vrf}\"\n\n        if re.search(pattern, _get_logging_states(self.logger, output)):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Source-interface '{intf}' is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf.test","title":"test","text":"<pre><code>test(intf: Optional[str] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifyLoggingSrcDst validation.</p> <p>Parameters:</p> Name Type Description Default <code>intf</code> <code>Optional[str]</code> <p>Source-interface to use as source IP of log messages.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport log messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyLoggingSrcDst validation.\n\n    Args:\n        intf: Source-interface to use as source IP of log messages.\n        vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n    \"\"\"\n    if not intf or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n        return\n\n    output = self.instance_commands[0].text_output\n\n    pattern = rf\"Logging source-interface '{intf}'.*VRF {vrf}\"\n\n    if re.search(pattern, _get_logging_states(self.logger, output)):\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Source-interface '{intf}' is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingTimestamp","title":"VerifyLoggingTimestamp","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the approprate timestamp.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the appropriated timestamp.</li> <li>failure: The test will fail if logs are NOT generated with the appropriated timestamp.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingTimestamp(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the approprate timestamp.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the appropriated timestamp.\n        * failure: The test will fail if logs are NOT generated with the appropriated timestamp.\n    \"\"\"\n\n    name = \"VerifyLoggingTimestamp\"\n    description = \"Verifies if logs are generated with the appropriate timestamp.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaCommand(command=\"send log level informational message ANTA VerifyLoggingTimestamp validation\"),\n        AntaCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingTimestamp validation.\n        \"\"\"\n        log_pattern = r\"ANTA VerifyLoggingTimestamp validation\"\n        timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}-\\d{2}:\\d{2}\"\n\n        output = self.instance_commands[1].text_output\n\n        lines = output.strip().split(\"\\n\")[::-1]\n\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n\n        if re.search(timestamp_pattern, last_line_with_pattern):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the appropriate timestamp format\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingTimestamp.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyLoggingTimestamp validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingTimestamp validation.\n    \"\"\"\n    log_pattern = r\"ANTA VerifyLoggingTimestamp validation\"\n    timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}-\\d{2}:\\d{2}\"\n\n    output = self.instance_commands[1].text_output\n\n    lines = output.strip().split(\"\\n\")[::-1]\n\n    last_line_with_pattern = \"\"\n    for line in lines:\n        if re.search(log_pattern, line):\n            last_line_with_pattern = line\n            break\n\n    if re.search(timestamp_pattern, last_line_with_pattern):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Logs are not generated with the appropriate timestamp format\")\n</code></pre>"},{"location":"api/tests/","title":"Overview","text":""},{"location":"api/tests/#anta-tests-landing-page","title":"ANTA Tests landing page","text":"<p>This section describes all the available tests provided by ANTA package.</p> <ul> <li>AAA</li> <li>Configuration</li> <li>Connectivity</li> <li>Field Notice</li> <li>Hardware</li> <li>Interfaces</li> <li>Logging</li> <li>MLAG</li> <li>Multicast</li> <li>Profiles</li> <li>Routing Generic</li> <li>Routing BGP</li> <li>Routing OSPF</li> <li>Security</li> <li>SNMP</li> <li>Software</li> <li>STP</li> <li>System</li> <li>VXLAN</li> </ul> <p>All these tests can be imported in a catalog to be used by the anta cli or in your own framework</p>"},{"location":"api/tests.mlag/","title":"MLAG","text":""},{"location":"api/tests.mlag/#anta-catalog-for-mlag-tests","title":"ANTA catalog for mlag tests","text":"<p>Test functions related to Multi-chassis Link Aggregation (MLAG)</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagConfigSanity","title":"VerifyMlagConfigSanity","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies there are no MLAG config-sanity inconsistencies.</p> Expected Results <ul> <li>success: The test will pass if there are NO MLAG config-sanity inconsistencies.</li> <li>failure: The test will fail if there are MLAG config-sanity inconsistencies.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> <li>error: The test will give an error if \u2018mlagActive\u2019 is not found in the JSON response.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagConfigSanity(AntaTest):\n\"\"\"\n    This test verifies there are no MLAG config-sanity inconsistencies.\n\n    Expected Results:\n        * success: The test will pass if there are NO MLAG config-sanity inconsistencies.\n        * failure: The test will fail if there are MLAG config-sanity inconsistencies.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n        * error: The test will give an error if 'mlagActive' is not found in the JSON response.\n    \"\"\"\n\n    name = \"VerifyMlagConfigSanity\"\n    description = \"This test verifies there are no MLAG config-sanity inconsistencies.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag config-sanity\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMlagConfigSanity validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if (mlag_status := get_value(command_output, \"mlagActive\")) is None:\n            self.result.is_error(\"Incorrect JSON response - 'mlagActive' state was not found\")\n            return\n\n        if mlag_status is False:\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        keys_to_verify = [\"globalConfiguration\", \"interfaceConfiguration\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if not any(verified_output.values()):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG config-sanity returned inconsistencies: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagConfigSanity.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyMlagConfigSanity validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMlagConfigSanity validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if (mlag_status := get_value(command_output, \"mlagActive\")) is None:\n        self.result.is_error(\"Incorrect JSON response - 'mlagActive' state was not found\")\n        return\n\n    if mlag_status is False:\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    keys_to_verify = [\"globalConfiguration\", \"interfaceConfiguration\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if not any(verified_output.values()):\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"MLAG config-sanity returned inconsistencies: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary","title":"VerifyMlagDualPrimary","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the dual-primary detection and its parameters of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the dual-primary detection is enabled and its parameters are configured properly.</li> <li>failure: The test will fail if the dual-primary detection is NOT enabled or its parameters are NOT configured properly.</li> <li>skipped: The test will be skipped if the dual-primary parameters are NOT provided or if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagDualPrimary(AntaTest):\n\"\"\"\n    This test verifies the dual-primary detection and its parameters of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the dual-primary detection is enabled and its parameters are configured properly.\n        * failure: The test will fail if the dual-primary detection is NOT enabled or its parameters are NOT configured properly.\n        * skipped: The test will be skipped if the dual-primary parameters are NOT provided or if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagDualPrimary\"\n    description = \"This test verifies the dual-primary detection and its parameters of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag detail\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(\n        self, detection_delay: Optional[int] = None, errdisabled: bool = False, recovery_delay: Optional[int] = None, recovery_delay_non_mlag: Optional[int] = None\n    ) -&gt; None:\n\"\"\"\n        Run VerifyMlagDualPrimary validation\n\n        Args:\n            detection_delay: Delay detection for &lt;N&gt; seconds.\n            errdisabled: Errdisabled all interfaces when dual-primary is detected. Defaults to False.\n            recovery_delay: Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled.\n            recovery_delay_non_mlag: Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled.\n        \"\"\"\n\n        if detection_delay is None or errdisabled is None or recovery_delay is None or recovery_delay_non_mlag is None:\n            self.result.is_skipped(\n                f\"{self.__class__.name} did not run because detection_delay, errdisabled, recovery_delay or recovery_delay_non_mlag were not supplied\"\n            )\n            return\n\n        errdisabled_action = \"errdisableAllInterfaces\" if errdisabled else \"none\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        if command_output[\"dualPrimaryDetectionState\"] == \"disabled\":\n            self.result.is_failure(\"Dual-primary detection is disabled\")\n            return\n\n        keys_to_verify = [\"detail.dualPrimaryDetectionDelay\", \"detail.dualPrimaryAction\", \"dualPrimaryMlagRecoveryDelay\", \"dualPrimaryNonMlagRecoveryDelay\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if (\n            verified_output[\"detail.dualPrimaryDetectionDelay\"] == detection_delay\n            and verified_output[\"detail.dualPrimaryAction\"] == errdisabled_action\n            and verified_output[\"dualPrimaryMlagRecoveryDelay\"] == recovery_delay\n            and verified_output[\"dualPrimaryNonMlagRecoveryDelay\"] == recovery_delay_non_mlag\n        ):\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"The dual-primary parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagDualPrimary.test","title":"test","text":"<pre><code>test(detection_delay: Optional[int] = None, errdisabled: bool = False, recovery_delay: Optional[int] = None, recovery_delay_non_mlag: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyMlagDualPrimary validation</p> <p>Parameters:</p> Name Type Description Default <code>detection_delay</code> <code>Optional[int]</code> <p>Delay detection for  seconds. <code>None</code> <code>errdisabled</code> <code>bool</code> <p>Errdisabled all interfaces when dual-primary is detected. Defaults to False.</p> <code>False</code> <code>recovery_delay</code> <code>Optional[int]</code> <p>Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled.</p> <code>None</code> <code>recovery_delay_non_mlag</code> <code>Optional[int]</code> <p>Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled.</p> <code>None</code> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(\n    self, detection_delay: Optional[int] = None, errdisabled: bool = False, recovery_delay: Optional[int] = None, recovery_delay_non_mlag: Optional[int] = None\n) -&gt; None:\n\"\"\"\n    Run VerifyMlagDualPrimary validation\n\n    Args:\n        detection_delay: Delay detection for &lt;N&gt; seconds.\n        errdisabled: Errdisabled all interfaces when dual-primary is detected. Defaults to False.\n        recovery_delay: Delay (seconds) after dual-primary detection resolves until non peer-link ports that are part of an MLAG are enabled.\n        recovery_delay_non_mlag: Delay (seconds) after dual-primary detection resolves until ports that are not part of an MLAG are enabled.\n    \"\"\"\n\n    if detection_delay is None or errdisabled is None or recovery_delay is None or recovery_delay_non_mlag is None:\n        self.result.is_skipped(\n            f\"{self.__class__.name} did not run because detection_delay, errdisabled, recovery_delay or recovery_delay_non_mlag were not supplied\"\n        )\n        return\n\n    errdisabled_action = \"errdisableAllInterfaces\" if errdisabled else \"none\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    if command_output[\"dualPrimaryDetectionState\"] == \"disabled\":\n        self.result.is_failure(\"Dual-primary detection is disabled\")\n        return\n\n    keys_to_verify = [\"detail.dualPrimaryDetectionDelay\", \"detail.dualPrimaryAction\", \"dualPrimaryMlagRecoveryDelay\", \"dualPrimaryNonMlagRecoveryDelay\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if (\n        verified_output[\"detail.dualPrimaryDetectionDelay\"] == detection_delay\n        and verified_output[\"detail.dualPrimaryAction\"] == errdisabled_action\n        and verified_output[\"dualPrimaryMlagRecoveryDelay\"] == recovery_delay\n        and verified_output[\"dualPrimaryNonMlagRecoveryDelay\"] == recovery_delay_non_mlag\n    ):\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"The dual-primary parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagInterfaces","title":"VerifyMlagInterfaces","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies there are no inactive or active-partial MLAG ports.</p> Expected Results <ul> <li>success: The test will pass if there are NO inactive or active-partial MLAG ports.</li> <li>failure: The test will fail if there are inactive or active-partial MLAG ports.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagInterfaces(AntaTest):\n\"\"\"\n    This test verifies there are no inactive or active-partial MLAG ports.\n\n    Expected Results:\n        * success: The test will pass if there are NO inactive or active-partial MLAG ports.\n        * failure: The test will fail if there are inactive or active-partial MLAG ports.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagInterfaces\"\n    description = \"This test verifies there are no inactive or active-partial MLAG ports.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMlagInterfaces validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        if command_output[\"mlagPorts\"][\"Inactive\"] == 0 and command_output[\"mlagPorts\"][\"Active-partial\"] == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG status is not OK: {command_output['mlagPorts']}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagInterfaces.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyMlagInterfaces validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMlagInterfaces validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    if command_output[\"mlagPorts\"][\"Inactive\"] == 0 and command_output[\"mlagPorts\"][\"Active-partial\"] == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"MLAG status is not OK: {command_output['mlagPorts']}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay","title":"VerifyMlagReloadDelay","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the reload-delay parameters of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the reload-delay parameters are configured properly.</li> <li>failure: The test will fail if the reload-delay parameters are NOT configured properly.</li> <li>skipped: The test will be skipped if the reload-delay parameters are NOT provided or if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagReloadDelay(AntaTest):\n\"\"\"\n    This test verifies the reload-delay parameters of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the reload-delay parameters are configured properly.\n        * failure: The test will fail if the reload-delay parameters are NOT configured properly.\n        * skipped: The test will be skipped if the reload-delay parameters are NOT provided or if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagReloadDelay\"\n    description = \"This test verifies the reload-delay parameters of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self, reload_delay: Optional[int] = None, reload_delay_non_mlag: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyMlagReloadDelay validation\n\n        Args:\n            reload_delay: Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled.\n            reload_delay_non_mlag: Delay (seconds) after reboot until ports that are not part of an MLAG are enabled.\n        \"\"\"\n\n        if not reload_delay or not reload_delay_non_mlag:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because reload_delay or reload_delay_non_mlag were not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        keys_to_verify = [\"reloadDelay\", \"reloadDelayNonMlag\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if verified_output[\"reloadDelay\"] == reload_delay and verified_output[\"reloadDelayNonMlag\"] == reload_delay_non_mlag:\n            self.result.is_success()\n\n        else:\n            self.result.is_failure(f\"The reload-delay parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagReloadDelay.test","title":"test","text":"<pre><code>test(reload_delay: Optional[int] = None, reload_delay_non_mlag: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyMlagReloadDelay validation</p> <p>Parameters:</p> Name Type Description Default <code>reload_delay</code> <code>Optional[int]</code> <p>Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled.</p> <code>None</code> <code>reload_delay_non_mlag</code> <code>Optional[int]</code> <p>Delay (seconds) after reboot until ports that are not part of an MLAG are enabled.</p> <code>None</code> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, reload_delay: Optional[int] = None, reload_delay_non_mlag: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyMlagReloadDelay validation\n\n    Args:\n        reload_delay: Delay (seconds) after reboot until non peer-link ports that are part of an MLAG are enabled.\n        reload_delay_non_mlag: Delay (seconds) after reboot until ports that are not part of an MLAG are enabled.\n    \"\"\"\n\n    if not reload_delay or not reload_delay_non_mlag:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because reload_delay or reload_delay_non_mlag were not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    keys_to_verify = [\"reloadDelay\", \"reloadDelayNonMlag\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if verified_output[\"reloadDelay\"] == reload_delay and verified_output[\"reloadDelayNonMlag\"] == reload_delay_non_mlag:\n        self.result.is_success()\n\n    else:\n        self.result.is_failure(f\"The reload-delay parameters are not configured properly: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagStatus","title":"VerifyMlagStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the health status of the MLAG configuration.</p> Expected Results <ul> <li>success: The test will pass if the MLAG state is \u2018active\u2019, negotiation status is \u2018connected\u2019,            peer-link status and local interface status are \u2018up\u2019.</li> <li>failure: The test will fail if the MLAG state is not \u2018active\u2019, negotiation status is not \u2018connected\u2019,            peer-link status or local interface status are not \u2018up\u2019.</li> <li>skipped: The test will be skipped if MLAG is \u2018disabled\u2019.</li> </ul> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagStatus(AntaTest):\n\"\"\"\n    This test verifies the health status of the MLAG configuration.\n\n    Expected Results:\n        * success: The test will pass if the MLAG state is 'active', negotiation status is 'connected',\n                   peer-link status and local interface status are 'up'.\n        * failure: The test will fail if the MLAG state is not 'active', negotiation status is not 'connected',\n                   peer-link status or local interface status are not 'up'.\n        * skipped: The test will be skipped if MLAG is 'disabled'.\n    \"\"\"\n\n    name = \"VerifyMlagStatus\"\n    description = \"This test verifies the health status of the MLAG configuration.\"\n    categories = [\"mlag\"]\n    commands = [AntaCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMlagStatus validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n            return\n\n        keys_to_verify = [\"state\", \"negStatus\", \"localIntfStatus\", \"peerLinkStatus\"]\n        verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n        if (\n            verified_output[\"state\"] == \"active\"\n            and verified_output[\"negStatus\"] == \"connected\"\n            and verified_output[\"localIntfStatus\"] == \"up\"\n            and verified_output[\"peerLinkStatus\"] == \"up\"\n        ):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"MLAG status is not OK: {verified_output}\")\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagStatus.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyMlagStatus validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMlagStatus validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n        return\n\n    keys_to_verify = [\"state\", \"negStatus\", \"localIntfStatus\", \"peerLinkStatus\"]\n    verified_output = {key: get_value(command_output, key) for key in keys_to_verify}\n\n    if (\n        verified_output[\"state\"] == \"active\"\n        and verified_output[\"negStatus\"] == \"connected\"\n        and verified_output[\"localIntfStatus\"] == \"up\"\n        and verified_output[\"peerLinkStatus\"] == \"up\"\n    ):\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"MLAG status is not OK: {verified_output}\")\n</code></pre>"},{"location":"api/tests.multicast/","title":"Multicast","text":""},{"location":"api/tests.multicast/#anta-catalog-for-multicast-tests","title":"ANTA catalog for multicast tests","text":"<p>Test functions related to multicast</p>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal","title":"VerifyIGMPSnoopingGlobal","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping global configuration.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>str</code> <p>Expected global IGMP snooping configuration (enabled or disabled).</p> required Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingGlobal(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping global configuration.\n\n    Args:\n        configuration (str): Expected global IGMP snooping configuration (enabled or disabled).\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingGlobal\"\n    description = \"Verifies the IGMP snooping global configuration.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaCommand(command=\"show ip igmp snooping\")]\n\n    @AntaTest.anta_test\n    def test(self, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyIGMPSnoopingGlobal validation\n\n        Args:\n            configuration: Expected global IGMP configuration (enabled or disabled).\n        \"\"\"\n\n        if not configuration:\n            self.result.is_skipped(\"VerifyIGMPSnoopingGlobal was not run as no configuration was given\")\n            return\n\n        if configuration not in [\"enabled\", \"disabled\"]:\n            self.result.is_error(f\"VerifyIGMPSnoopingGlobal was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n        if (igmp_state := command_output[\"igmpSnoopingState\"]) != configuration:\n            self.result.is_failure(f\"IGMP state is not valid: {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal.test","title":"test","text":"<pre><code>test(configuration: Optional[str] = None) -&gt; None\n</code></pre> <p>Run VerifyIGMPSnoopingGlobal validation</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>Optional[str]</code> <p>Expected global IGMP configuration (enabled or disabled).</p> <code>None</code> Source code in <code>anta/tests/multicast.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyIGMPSnoopingGlobal validation\n\n    Args:\n        configuration: Expected global IGMP configuration (enabled or disabled).\n    \"\"\"\n\n    if not configuration:\n        self.result.is_skipped(\"VerifyIGMPSnoopingGlobal was not run as no configuration was given\")\n        return\n\n    if configuration not in [\"enabled\", \"disabled\"]:\n        self.result.is_error(f\"VerifyIGMPSnoopingGlobal was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    self.result.is_success()\n    if (igmp_state := command_output[\"igmpSnoopingState\"]) != configuration:\n        self.result.is_failure(f\"IGMP state is not valid: {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans","title":"VerifyIGMPSnoopingVlans","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping configuration for some VLANs.</p> <p>Parameters:</p> Name Type Description Default <code>vlans</code> <code>List[str]</code> <p>A list of VLANs</p> required <code>configuration</code> <code>str</code> <p>Expected IGMP snooping configuration (enabled or disabled) for these VLANs.</p> required Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingVlans(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping configuration for some VLANs.\n\n    Args:\n        vlans (List[str]): A list of VLANs\n        configuration (str): Expected IGMP snooping configuration (enabled or disabled) for these VLANs.\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingVlans\"\n    description = \"Verifies the IGMP snooping configuration for some VLANs.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaCommand(command=\"show ip igmp snooping\")]\n\n    @AntaTest.anta_test\n    def test(self, vlans: Optional[List[str]] = None, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyIGMPSnoopingVlans validation\n\n        Args:\n            vlans: List of VLANs.\n            configuration: Expected IGMP configuration (enabled or disabled) for these VLANs.\n        \"\"\"\n\n        if not vlans or not configuration:\n            self.result.is_skipped(\"VerifyIGMPSnoopingVlans was not run as no vlans or configuration was given\")\n            return\n        if configuration not in [\"enabled\", \"disabled\"]:\n            self.result.is_error(f\"VerifyIGMPSnoopingVlans was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n        for vlan in vlans:\n            if vlan not in command_output[\"vlans\"]:\n                self.result.is_failure(f\"Supplied vlan {vlan} is not present on the device.\")\n                continue\n\n            igmp_state = command_output[\"vlans\"][str(vlan)][\"igmpSnoopingState\"]\n            if igmp_state != configuration:\n                self.result.is_failure(f\"IGMP state for vlan {vlan} is {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans.test","title":"test","text":"<pre><code>test(vlans: Optional[List[str]] = None, configuration: Optional[str] = None) -&gt; None\n</code></pre> <p>Run VerifyIGMPSnoopingVlans validation</p> <p>Parameters:</p> Name Type Description Default <code>vlans</code> <code>Optional[List[str]]</code> <p>List of VLANs.</p> <code>None</code> <code>configuration</code> <code>Optional[str]</code> <p>Expected IGMP configuration (enabled or disabled) for these VLANs.</p> <code>None</code> Source code in <code>anta/tests/multicast.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, vlans: Optional[List[str]] = None, configuration: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyIGMPSnoopingVlans validation\n\n    Args:\n        vlans: List of VLANs.\n        configuration: Expected IGMP configuration (enabled or disabled) for these VLANs.\n    \"\"\"\n\n    if not vlans or not configuration:\n        self.result.is_skipped(\"VerifyIGMPSnoopingVlans was not run as no vlans or configuration was given\")\n        return\n    if configuration not in [\"enabled\", \"disabled\"]:\n        self.result.is_error(f\"VerifyIGMPSnoopingVlans was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    self.result.is_success()\n    for vlan in vlans:\n        if vlan not in command_output[\"vlans\"]:\n            self.result.is_failure(f\"Supplied vlan {vlan} is not present on the device.\")\n            continue\n\n        igmp_state = command_output[\"vlans\"][str(vlan)][\"igmpSnoopingState\"]\n        if igmp_state != configuration:\n            self.result.is_failure(f\"IGMP state for vlan {vlan} is {igmp_state}\")\n</code></pre>"},{"location":"api/tests.profiles/","title":"Profiles","text":""},{"location":"api/tests.profiles/#anta-catalog-for-profiles-tests","title":"ANTA catalog for profiles tests","text":"<p>Test functions related to ASIC profiles</p>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile","title":"VerifyTcamProfile","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is using the configured TCAM profile.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyTcamProfile(AntaTest):\n\"\"\"\n    Verifies the device is using the configured TCAM profile.\n    \"\"\"\n\n    name = \"VerifyTcamProfile\"\n    description = \"Verify that the assigned TCAM profile is actually running on the device\"\n    categories = [\"profiles\"]\n    commands = [AntaCommand(command=\"show hardware tcam profile\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyTcamProfile validation\n\n        Args:\n            profile: Expected TCAM profile.\n        \"\"\"\n        if not profile:\n            self.result.is_skipped(\"VerifyTcamProfile was not run as no profile was given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"pmfProfiles\"][\"FixedSystem\"][\"status\"] == command_output[\"pmfProfiles\"][\"FixedSystem\"][\"config\"] == profile:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Incorrect profile running on device: {command_output['pmfProfiles']['FixedSystem']['status']}\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile.test","title":"test","text":"<pre><code>test(profile: Optional[str] = None) -&gt; None\n</code></pre> <p>Run VerifyTcamProfile validation</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[str]</code> <p>Expected TCAM profile.</p> <code>None</code> Source code in <code>anta/tests/profiles.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyTcamProfile validation\n\n    Args:\n        profile: Expected TCAM profile.\n    \"\"\"\n    if not profile:\n        self.result.is_skipped(\"VerifyTcamProfile was not run as no profile was given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n    if command_output[\"pmfProfiles\"][\"FixedSystem\"][\"status\"] == command_output[\"pmfProfiles\"][\"FixedSystem\"][\"config\"] == profile:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Incorrect profile running on device: {command_output['pmfProfiles']['FixedSystem']['status']}\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode","title":"VerifyUnifiedForwardingTableMode","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is using the expected Unified Forwarding Table mode.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyUnifiedForwardingTableMode(AntaTest):\n\"\"\"\n    Verifies the device is using the expected Unified Forwarding Table mode.\n    \"\"\"\n\n    name = \"VerifyUnifiedForwardingTableMode\"\n    description = \"\"\n    categories = [\"profiles\"]\n    commands = [AntaCommand(command=\"show platform trident forwarding-table partition\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, mode: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyUnifiedForwardingTableMode validation\n\n        Args:\n            mode: Expected UFT mode.\n        \"\"\"\n        if not mode:\n            self.result.is_skipped(\"VerifyUnifiedForwardingTableMode was not run as no mode was given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n        if command_output[\"uftMode\"] == mode:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device is not running correct UFT mode (expected: {mode} / running: {command_output['uftMode']})\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode.test","title":"test","text":"<pre><code>test(mode: Optional[str] = None) -&gt; None\n</code></pre> <p>Run VerifyUnifiedForwardingTableMode validation</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Optional[str]</code> <p>Expected UFT mode.</p> <code>None</code> Source code in <code>anta/tests/profiles.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, mode: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyUnifiedForwardingTableMode validation\n\n    Args:\n        mode: Expected UFT mode.\n    \"\"\"\n    if not mode:\n        self.result.is_skipped(\"VerifyUnifiedForwardingTableMode was not run as no mode was given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n    if command_output[\"uftMode\"] == mode:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device is not running correct UFT mode (expected: {mode} / running: {command_output['uftMode']})\")\n</code></pre>"},{"location":"api/tests.routing.bgp/","title":"BGP","text":""},{"location":"api/tests.routing.bgp/#anta-catalog-for-routing-bgp-tests","title":"ANTA catalog for routing-bgp tests","text":"<p>BGP test functions</p>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount","title":"VerifyBGPEVPNCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are Established and if the actual                      number of BGP EVPN neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNCount(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF)\n    and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\n\n    * self.result = \"skipped\" if the `number` parameter is missing\n    * self.result = \"success\" if all EVPN BGP sessions are Established and if the actual\n                         number of BGP EVPN neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNCount\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp evpn summary\")]\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyBGPEVPNCount validation\n\n        Args:\n            number: The expected number of BGP EVPN neighbors in the default VRF.\n        \"\"\"\n        if not number:\n            self.result.is_skipped(\"VerifyBGPEVPNCount could not run because number was not supplied.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers and len(peers) == number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP EVPN peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount.test","title":"test","text":"<pre><code>test(number: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyBGPEVPNCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The expected number of BGP EVPN neighbors in the default VRF.</p> <code>None</code> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"evpn\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyBGPEVPNCount validation\n\n    Args:\n        number: The expected number of BGP EVPN neighbors in the default VRF.\n    \"\"\"\n    if not number:\n        self.result.is_skipped(\"VerifyBGPEVPNCount could not run because number was not supplied.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers and len(peers) == number:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP EVPN peers and got {len(peers)}\")\n        if non_established_peers:\n            self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNState","title":"VerifyBGPEVPNState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP EVPN peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNState(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP EVPN peers are returned by the device\n    * self.result = \"success\" if all EVPN BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNState\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp evpn summary\")]\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPEVPNState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        bgp_vrfs = command_output[\"vrfs\"]\n\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNState.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyBGPEVPNState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"evpn\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPEVPNState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    bgp_vrfs = command_output[\"vrfs\"]\n\n    peers = bgp_vrfs[\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount","title":"VerifyBGPIPv4UnicastCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect.</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> or <code>vrf</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established                      and if all BGP messages queues for these sessions are empty                      and if the actual number of BGP IPv4 unicast neighbors is equal to `number.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastCount(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established\n    and all BGP messages queues for these sessions are empty\n    and the actual number of BGP IPv4 unicast neighbors is the one we expect.\n\n    * self.result = \"skipped\" if the `number` or `vrf` parameter is missing\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established\n                         and if all BGP messages queues for these sessions are empty\n                         and if the actual number of BGP IPv4 unicast neighbors is equal to `number.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastCount\"\n    description = (\n        \"Verifies all IPv4 unicast BGP sessions are established and all their BGP messages queues are empty and \"\n        \" the actual number of BGP IPv4 unicast neighbors is the one we expect.\"\n    )\n    categories = [\"routing\", \"bgp\"]\n    template = AntaTemplate(template=\"show bgp ipv4 unicast summary vrf {vrf}\")\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyBGPIPv4UnicastCount validation\n\n        Args:\n            number: The expected number of BGP IPv4 unicast neighbors.\n            vrf: VRF to verify (template parameter)\n        \"\"\"\n\n        if not number:\n            self.result.is_skipped(\"VerifyBGPIPv4UnicastCount could not run because number was not supplied\")\n            return\n\n        self.result.is_success()\n\n        for command in self.instance_commands:\n            if command.params and \"vrf\" in command.params:\n                vrf = command.params[\"vrf\"]\n\n            peers = command.json_output[\"vrfs\"][vrf][\"peers\"]\n            state_issue = _check_bgp_vrfs(command.json_output[\"vrfs\"])\n\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP peer in vrf {vrf} and got {len(peers)}\")\n            if state_issue:\n                self.result.is_failure(f\"The following IPv4 peers are not established: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount.test","title":"test","text":"<pre><code>test(number: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyBGPIPv4UnicastCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The expected number of BGP IPv4 unicast neighbors.</p> <code>None</code> <code>vrf</code> <p>VRF to verify (template parameter)</p> required Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv4\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyBGPIPv4UnicastCount validation\n\n    Args:\n        number: The expected number of BGP IPv4 unicast neighbors.\n        vrf: VRF to verify (template parameter)\n    \"\"\"\n\n    if not number:\n        self.result.is_skipped(\"VerifyBGPIPv4UnicastCount could not run because number was not supplied\")\n        return\n\n    self.result.is_success()\n\n    for command in self.instance_commands:\n        if command.params and \"vrf\" in command.params:\n            vrf = command.params[\"vrf\"]\n\n        peers = command.json_output[\"vrfs\"][vrf][\"peers\"]\n        state_issue = _check_bgp_vrfs(command.json_output[\"vrfs\"])\n\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP peer in vrf {vrf} and got {len(peers)}\")\n        if state_issue:\n            self.result.is_failure(f\"The following IPv4 peers are not established: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastState","title":"VerifyBGPIPv4UnicastState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastState\"\n    description = \"Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp ipv4 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastState.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyBGPIPv4UnicastState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv4\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n    state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n    if not state_issue:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv6UnicastState","title":"VerifyBGPIPv6UnicastState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv6 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv6UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv6 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv6 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv6UnicastState\"\n    description = \"Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp ipv6 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv6\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv6UnicastState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv6UnicastState.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyBGPIPv6UnicastState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv6\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv6UnicastState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n    if not state_issue:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount","title":"VerifyBGPRTCCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are Established and if the actual                      number of BGP RTC neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCCount(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF)\n    and the actual number of BGP RTC neighbors is the one we expect (default VRF).\n\n    * self.result = \"skipped\" if the `number` parameter is missing\n    * self.result = \"success\" if all RTC BGP sessions are Established and if the actual\n                         number of BGP RTC neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCCount\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp rt-membership summary\")]\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyBGPRTCCount validation\n\n        Args:\n            number: The expected number of BGP RTC neighbors (default VRF).\n        \"\"\"\n        if not number:\n            self.result.is_skipped(\"VerifyBGPRTCCount could not run because number was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers and len(peers) == number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP RTC peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount.test","title":"test","text":"<pre><code>test(number: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyBGPRTCCount validation</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The expected number of BGP RTC neighbors (default VRF).</p> <code>None</code> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"rtc\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyBGPRTCCount validation\n\n    Args:\n        number: The expected number of BGP RTC neighbors (default VRF).\n    \"\"\"\n    if not number:\n        self.result.is_skipped(\"VerifyBGPRTCCount could not run because number was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers and len(peers) == number:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP RTC peers and got {len(peers)}\")\n        if non_established_peers:\n            self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCState","title":"VerifyBGPRTCState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP RTC peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCState(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP RTC peers are returned by the device\n    * self.result = \"success\" if all RTC BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCState\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaCommand(command=\"show bgp rt-membership summary\")]\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPRTCState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        bgp_vrfs = command_output[\"vrfs\"]\n\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCState.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyBGPRTCState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"rtc\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPRTCState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    bgp_vrfs = command_output[\"vrfs\"]\n\n    peers = bgp_vrfs[\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.generic/","title":"Generic","text":""},{"location":"api/tests.routing.generic/#anta-catalog-for-routing-generic-tests","title":"ANTA catalog for routing-generic tests","text":"<p>Generic routing test functions</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyBFD","title":"VerifyBFD","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyBFD(AntaTest):\n\"\"\"\n    Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\n    \"\"\"\n\n    name = \"VerifyBFD\"\n    description = \"Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\"\n    categories = [\"routing\", \"generic\"]\n    # revision 1 as later revision introduce additional nesting for type\n    commands = [AntaCommand(command=\"show bfd peers\", revision=1)]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBFD validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        self.result.is_success()\n\n        for _, vrf_data in command_output[\"vrfs\"].items():\n            for _, neighbor_data in vrf_data[\"ipv4Neighbors\"].items():\n                for peer, peer_data in neighbor_data[\"peerStats\"].items():\n                    if (peer_status := peer_data[\"status\"]) != \"up\":\n                        failure_message = f\"bfd state for peer '{peer}' is {peer_status} (expected up).\"\n                        if (peer_l3intf := peer_data.get(\"l3intf\")) is not None and peer_l3intf != \"\":\n                            failure_message += f\" Interface: {peer_l3intf}.\"\n                        self.result.is_failure(failure_message)\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyBFD.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyBFD validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBFD validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    self.result.is_success()\n\n    for _, vrf_data in command_output[\"vrfs\"].items():\n        for _, neighbor_data in vrf_data[\"ipv4Neighbors\"].items():\n            for peer, peer_data in neighbor_data[\"peerStats\"].items():\n                if (peer_status := peer_data[\"status\"]) != \"up\":\n                    failure_message = f\"bfd state for peer '{peer}' is {peer_status} (expected up).\"\n                    if (peer_l3intf := peer_data.get(\"l3intf\")) is not None and peer_l3intf != \"\":\n                        failure_message += f\" Interface: {peer_l3intf}.\"\n                    self.result.is_failure(failure_message)\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel","title":"VerifyRoutingProtocolModel","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model.</p> <pre><code>model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent\n</code></pre> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingProtocolModel(AntaTest):\n\"\"\"\n    Verifies the configured routing protocol model is the one we expect.\n    And if there is no mismatch between the configured and operating routing protocol model.\n\n        model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent\n    \"\"\"\n\n    name = \"VerifyRoutingProtocolModel\"\n    description = (\n        \"Verifies the configured routing protocol model is the expected one and if there is no mismatch between the configured and operating routing protocol model.\"\n    )\n    categories = [\"routing\", \"generic\"]\n    # \"revision\": 3\n    commands = [AntaCommand(command=\"show ip route summary\")]\n\n    @AntaTest.anta_test\n    def test(self, model: Optional[str] = \"multi-agent\") -&gt; None:\n\"\"\"Run VerifyRoutingProtocolModel validation\"\"\"\n\n        if not model:\n            self.result.is_skipped(\"VerifyRoutingProtocolModel was not run as no model was given\")\n            return\n        command_output = self.instance_commands[0].json_output\n\n        configured_model = command_output[\"protoModelStatus\"][\"configuredProtoModel\"]\n        operating_model = command_output[\"protoModelStatus\"][\"operatingProtoModel\"]\n        if configured_model == operating_model == model:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing model is misconfigured: configured: {configured_model} - operating: {operating_model} - expected: {model}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel.test","title":"test","text":"<pre><code>test(model: Optional[str] = 'multi-agent') -&gt; None\n</code></pre> <p>Run VerifyRoutingProtocolModel validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, model: Optional[str] = \"multi-agent\") -&gt; None:\n\"\"\"Run VerifyRoutingProtocolModel validation\"\"\"\n\n    if not model:\n        self.result.is_skipped(\"VerifyRoutingProtocolModel was not run as no model was given\")\n        return\n    command_output = self.instance_commands[0].json_output\n\n    configured_model = command_output[\"protoModelStatus\"][\"configuredProtoModel\"]\n    operating_model = command_output[\"protoModelStatus\"][\"operatingProtoModel\"]\n    if configured_model == operating_model == model:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"routing model is misconfigured: configured: {configured_model} - operating: {operating_model} - expected: {model}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize","title":"VerifyRoutingTableSize","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>minimum(int)</code> <p>Expected minimum routing table (default VRF) size.</p> required <code>maximum(int)</code> <p>Expected maximum routing table (default VRF) size.</p> required Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingTableSize(AntaTest):\n\"\"\"\n    Verifies the size of the IP routing table (default VRF).\n    Should be between the two provided thresholds.\n\n    Args:\n        minimum(int): Expected minimum routing table (default VRF) size.\n        maximum(int): Expected maximum routing table (default VRF) size.\n    \"\"\"\n\n    name = \"VerifyRoutingTableSize\"\n    description = \"Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.\"\n    categories = [\"routing\", \"generic\"]\n    # \"revision\": 3\n    commands = [AntaCommand(command=\"show ip route summary\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None, maximum: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyRoutingTableSize validation\"\"\"\n\n        if not minimum or not maximum:\n            self.result.is_skipped(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} was not provided\")\n            return\n        if not isinstance(minimum, int) or not isinstance(maximum, int):\n            self.result.is_error(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} is not a valid value (integer)\")\n            return\n        if maximum &lt; minimum:\n            self.result.is_error(f\"VerifyRoutingTableSize was not run as minimum {minimum} is greate than maximum {maximum}.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n        total_routes = int(command_output[\"vrfs\"][\"default\"][\"totalRoutes\"])\n        if minimum &lt;= total_routes &lt;= maximum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing-table has {total_routes} routes and not between min ({minimum}) and maximum ({maximum})\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize.test","title":"test","text":"<pre><code>test(minimum: Optional[int] = None, maximum: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyRoutingTableSize validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: Optional[int] = None, maximum: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyRoutingTableSize validation\"\"\"\n\n    if not minimum or not maximum:\n        self.result.is_skipped(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} was not provided\")\n        return\n    if not isinstance(minimum, int) or not isinstance(maximum, int):\n        self.result.is_error(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} is not a valid value (integer)\")\n        return\n    if maximum &lt; minimum:\n        self.result.is_error(f\"VerifyRoutingTableSize was not run as minimum {minimum} is greate than maximum {maximum}.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n    total_routes = int(command_output[\"vrfs\"][\"default\"][\"totalRoutes\"])\n    if minimum &lt;= total_routes &lt;= maximum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"routing-table has {total_routes} routes and not between min ({minimum}) and maximum ({maximum})\")\n</code></pre>"},{"location":"api/tests.routing.ospf/","title":"OSPF","text":""},{"location":"api/tests.routing.ospf/#anta-catalog-for-routing-ospf-tests","title":"ANTA catalog for routing-ospf tests","text":"<p>OSPF test functions</p>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount","title":"VerifyOSPFNeighborCount","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the number of OSPF neighbors in FULL state is the one we expect.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The expected number of OSPF neighbors in FULL state.</p> required Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborCount(AntaTest):\n\"\"\"\n    Verifies the number of OSPF neighbors in FULL state is the one we expect.\n\n    Args:\n        number (int): The expected number of OSPF neighbors in FULL state.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborCount\"\n    description = \"Verifies the number of OSPF neighbors in FULL state is the one we expect.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaCommand(command=\"show ip ospf neighbor\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborCount validation\"\"\"\n        if not (isinstance(number, int) and number &gt;= 0):\n            self.result.is_skipped(f\"VerifyOSPFNeighborCount was not run as the number given '{number}' is not a valid value.\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if (neighbor_count := _count_ospf_neighbor(command_output)) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n\n        self.result.is_success()\n\n        if neighbor_count != number:\n            self.result.is_failure(f\"device has {neighbor_count} neighbors (expected {number})\")\n\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        print(not_full_neighbors)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount.test","title":"test","text":"<pre><code>test(number: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyOSPFNeighborCount validation</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborCount validation\"\"\"\n    if not (isinstance(number, int) and number &gt;= 0):\n        self.result.is_skipped(f\"VerifyOSPFNeighborCount was not run as the number given '{number}' is not a valid value.\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if (neighbor_count := _count_ospf_neighbor(command_output)) == 0:\n        self.result.is_skipped(\"no OSPF neighbor found\")\n        return\n\n    self.result.is_success()\n\n    if neighbor_count != number:\n        self.result.is_failure(f\"device has {neighbor_count} neighbors (expected {number})\")\n\n    not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n    print(not_full_neighbors)\n    if not_full_neighbors:\n        self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborState","title":"VerifyOSPFNeighborState","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all OSPF neighbors are in FULL state.</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborState(AntaTest):\n\"\"\"\n    Verifies all OSPF neighbors are in FULL state.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborState\"\n    description = \"Verifies all OSPF neighbors are in FULL state.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaCommand(command=\"show ip ospf neighbor\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborState validation\"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if _count_ospf_neighbor(command_output) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n\n        self.result.is_success()\n\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborState.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyOSPFNeighborState validation</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborState validation\"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if _count_ospf_neighbor(command_output) == 0:\n        self.result.is_skipped(\"no OSPF neighbor found\")\n        return\n\n    self.result.is_success()\n\n    not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n    if not_full_neighbors:\n        self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.security/","title":"Security","text":""},{"location":"api/tests.security/#anta-catalog-for-security-tests","title":"ANTA catalog for security tests","text":"<p>Test functions related to the EOS various security settings</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpStatus","title":"VerifyAPIHttpStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTP server is disabled globally.</p> Expected Results <ul> <li>success: The test will pass if eAPI HTTP server is disabled globally.</li> <li>failure: The test will fail if eAPI HTTP server is NOT disabled globally.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpStatus(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTP server is disabled globally.\n\n    Expected Results:\n        * success: The test will pass if eAPI HTTP server is disabled globally.\n        * failure: The test will fail if eAPI HTTP server is NOT disabled globally.\n    \"\"\"\n\n    name = \"VerifyAPIHttpStatus\"\n    description = \"Verifies if eAPI HTTP server is disabled globally.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyAPIHTTPStatus validation.\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"enabled\"] and not command_output[\"httpServer\"][\"running\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"eAPI HTTP server is enabled globally\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpStatus.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyAPIHTTPStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyAPIHTTPStatus validation.\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"enabled\"] and not command_output[\"httpServer\"][\"running\"]:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"eAPI HTTP server is enabled globally\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL","title":"VerifyAPIHttpsSSL","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTPS server SSL profile is configured and valid.</p> Expected results <ul> <li>success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.</li> <li>failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.</li> <li>skipped: The test will be skipped if the SSL profile is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpsSSL(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTPS server SSL profile is configured and valid.\n\n    Expected results:\n        * success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.\n        * failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.\n        * skipped: The test will be skipped if the SSL profile is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIHttpsSSL\"\n    description = \"Verifies if eAPI HTTPS server SSL profile is configured and valid.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands\")]\n\n    @AntaTest.anta_test\n    def test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyAPIHttpsSSL validation.\n\n        Args:\n            profile: SSL profile to verify.\n        \"\"\"\n        if not profile:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because profile was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        try:\n            if command_output[\"sslProfile\"][\"name\"] == profile and command_output[\"sslProfile\"][\"state\"] == \"valid\":\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is misconfigured or invalid\")\n\n        except KeyError:\n            self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is not configured\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL.test","title":"test","text":"<pre><code>test(profile: Optional[str] = None) -&gt; None\n</code></pre> <p>Run VerifyAPIHttpsSSL validation.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[str]</code> <p>SSL profile to verify.</p> <code>None</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyAPIHttpsSSL validation.\n\n    Args:\n        profile: SSL profile to verify.\n    \"\"\"\n    if not profile:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because profile was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    try:\n        if command_output[\"sslProfile\"][\"name\"] == profile and command_output[\"sslProfile\"][\"state\"] == \"valid\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is misconfigured or invalid\")\n\n    except KeyError:\n        self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is not configured\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl","title":"VerifyAPIIPv4Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIIPv4Acl\"\n    description = \"Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands ip access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyAPIIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} eAPI IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl.test","title":"test","text":"<pre><code>test(number: Optional[int] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifyAPIIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for eAPI. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyAPIIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} eAPI IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"eAPI IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl","title":"VerifyAPIIPv6Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIIPv6Acl\"\n    description = \"Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management api http-commands ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyAPIIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} eAPI IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl.test","title":"test","text":"<pre><code>test(number: Optional[int] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifyAPIIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for eAPI. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyAPIIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} eAPI IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"eAPI IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl","title":"VerifySSHIPv4Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySSHIPv4Acl\"\n    description = \"Verifies if the SSHD agent has IPv4 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh ip access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySSHIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SSH IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl.test","title":"test","text":"<pre><code>test(number: Optional[int] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifySSHIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SSHD agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySSHIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SSH IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SSH IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl","title":"VerifySSHIPv6Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySSHIPv6Acl\"\n    description = \"Verifies if the SSHD agent has IPv6 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySSHIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SSH IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl.test","title":"test","text":"<pre><code>test(number: Optional[int] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifySSHIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SSHD agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySSHIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SSH IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SSH IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHStatus","title":"VerifySSHStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if the SSHD agent is disabled in the default VRF.</li> <li>failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHStatus(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if the SSHD agent is disabled in the default VRF.\n        * failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifySSHStatus\"\n    description = \"Verifies if the SSHD agent is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management ssh\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySSHStatus validation.\n        \"\"\"\n\n        command_output = self.instance_commands[0].text_output\n\n        line = [line for line in command_output.split(\"\\n\") if line.startswith(\"SSHD status\")][0]\n        status = line.split(\"is \")[1]\n\n        if status == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(line)\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHStatus.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifySSHStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySSHStatus validation.\n    \"\"\"\n\n    command_output = self.instance_commands[0].text_output\n\n    line = [line for line in command_output.split(\"\\n\") if line.startswith(\"SSHD status\")][0]\n    status = line.split(\"is \")[1]\n\n    if status == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(line)\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyTelnetStatus","title":"VerifyTelnetStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if Telnet is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if Telnet is disabled in the default VRF.</li> <li>failure: The test will fail if Telnet is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyTelnetStatus(AntaTest):\n\"\"\"\n    Verifies if Telnet is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if Telnet is disabled in the default VRF.\n        * failure: The test will fail if Telnet is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifyTelnetStatus\"\n    description = \"Verifies if Telnet is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaCommand(command=\"show management telnet\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyTelnetStatus validation.\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"serverState\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Telnet status for Default VRF is enabled\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyTelnetStatus.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyTelnetStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyTelnetStatus validation.\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"serverState\"] == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Telnet status for Default VRF is enabled\")\n</code></pre>"},{"location":"api/tests.snmp/","title":"SNMP","text":""},{"location":"api/tests.snmp/#anta-catalog-for-snmp-tests","title":"ANTA catalog for SNMP tests","text":"<p>Test functions related to the EOS various SNMP settings</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl","title":"VerifySnmpIPv4Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpIPv4Acl\"\n    description = \"Verifies if the SNMP agent has IPv4 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp ipv4 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SNMP IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl.test","title":"test","text":"<pre><code>test(number: Optional[int] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifySnmpIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SNMP IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SNMP IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl","title":"VerifySnmpIPv6Acl","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpIPv6Acl\"\n    description = \"Verifies if the SNMP agent has IPv6 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SNMP IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl.test","title":"test","text":"<pre><code>test(number: Optional[int] = None, vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifySnmpIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SNMP IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SNMP IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus","title":"VerifySnmpStatus","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies whether the SNMP agent is enabled in a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the SNMP agent is enabled in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent is disabled in the specified VRF.</li> <li>skipped: The test will be skipped if the VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpStatus(AntaTest):\n\"\"\"\n    Verifies whether the SNMP agent is enabled in a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the SNMP agent is enabled in the specified VRF.\n        * failure: The test will fail if the SNMP agent is disabled in the specified VRF.\n        * skipped: The test will be skipped if the VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpStatus\"\n    description = \"Verifies if the SNMP agent is enabled.\"\n    categories = [\"snmp\"]\n    commands = [AntaCommand(command=\"show snmp\")]\n\n    @AntaTest.anta_test\n    def test(self, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpStatus validation.\n\n        Args:\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because vrf was not supplied\")\n        else:\n            command_output = self.instance_commands[0].json_output\n\n            if command_output[\"enabled\"] and vrf in command_output[\"vrfs\"][\"snmpVrfs\"]:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"SNMP agent disabled in vrf {vrf}\")\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus.test","title":"test","text":"<pre><code>test(vrf: str = 'default') -&gt; None\n</code></pre> <p>Run VerifySnmpStatus validation.</p> <p>Parameters:</p> Name Type Description Default <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpStatus validation.\n\n    Args:\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because vrf was not supplied\")\n    else:\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"enabled\"] and vrf in command_output[\"vrfs\"][\"snmpVrfs\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"SNMP agent disabled in vrf {vrf}\")\n</code></pre>"},{"location":"api/tests.software/","title":"Software","text":""},{"location":"api/tests.software/#anta-catalog-for-software-tests","title":"ANTA catalog for software tests","text":"<p>Test functions related to the EOS software</p>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSExtensions","title":"VerifyEOSExtensions","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies all EOS extensions installed on the device are enabled for boot persistence.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSExtensions(AntaTest):\n\"\"\"\n    Verifies all EOS extensions installed on the device are enabled for boot persistence.\n    \"\"\"\n\n    name = \"VerifyEOSExtensions\"\n    description = \"Verifies all EOS extensions installed on the device are enabled for boot persistence.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show extensions\"), AntaCommand(command=\"show boot-extensions\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyEOSExtensions validation\"\"\"\n\n        boot_extensions = []\n\n        show_extensions_command_output = self.instance_commands[0].json_output\n        show_boot_extensions_command_output = self.instance_commands[1].json_output\n\n        installed_extensions = [\n            extension for extension, extension_data in show_extensions_command_output[\"extensions\"].items() if extension_data[\"status\"] == \"installed\"\n        ]\n\n        for extension in show_boot_extensions_command_output[\"extensions\"]:\n            extension = extension.strip(\"\\n\")\n            if extension != \"\":\n                boot_extensions.append(extension)\n\n        installed_extensions.sort()\n        boot_extensions.sort()\n        if installed_extensions == boot_extensions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Missing EOS extensions: installed {installed_extensions} / configured: {boot_extensions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSExtensions.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyEOSExtensions validation</p> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyEOSExtensions validation\"\"\"\n\n    boot_extensions = []\n\n    show_extensions_command_output = self.instance_commands[0].json_output\n    show_boot_extensions_command_output = self.instance_commands[1].json_output\n\n    installed_extensions = [\n        extension for extension, extension_data in show_extensions_command_output[\"extensions\"].items() if extension_data[\"status\"] == \"installed\"\n    ]\n\n    for extension in show_boot_extensions_command_output[\"extensions\"]:\n        extension = extension.strip(\"\\n\")\n        if extension != \"\":\n            boot_extensions.append(extension)\n\n    installed_extensions.sort()\n    boot_extensions.sort()\n    if installed_extensions == boot_extensions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Missing EOS extensions: installed {installed_extensions} / configured: {boot_extensions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion","title":"VerifyEOSVersion","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed EOS version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed EOS version.\n    \"\"\"\n\n    name = \"VerifyEOSVersion\"\n    description = \"Verifies the device is running one of the allowed EOS version.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show version\")]\n\n    @AntaTest.anta_test\n    def test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyEOSVersion validation\n\n        Args:\n            versions: List of allowed EOS versions.\n        \"\"\"\n        if not versions:\n            self.result.is_skipped(\"VerifyEOSVersion was not run as no versions were given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if command_output[\"version\"] in versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f'device is running version {command_output[\"version\"]} not in expected versions: {versions}')\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion.test","title":"test","text":"<pre><code>test(versions: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyEOSVersion validation</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Optional[List[str]]</code> <p>List of allowed EOS versions.</p> <code>None</code> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyEOSVersion validation\n\n    Args:\n        versions: List of allowed EOS versions.\n    \"\"\"\n    if not versions:\n        self.result.is_skipped(\"VerifyEOSVersion was not run as no versions were given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if command_output[\"version\"] in versions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f'device is running version {command_output[\"version\"]} not in expected versions: {versions}')\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion","title":"VerifyTerminAttrVersion","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed TerminAttr version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyTerminAttrVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed TerminAttr version.\n    \"\"\"\n\n    name = \"VerifyTerminAttrVersion\"\n    description = \"Verifies the device is running one of the allowed TerminAttr version.\"\n    categories = [\"software\"]\n    commands = [AntaCommand(command=\"show version detail\")]\n\n    @AntaTest.anta_test\n    def test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTerminAttrVersion validation\n\n        Args:\n            versions: List of allowed TerminAttr versions.\n        \"\"\"\n\n        if not versions:\n            self.result.is_skipped(\"VerifyTerminAttrVersion was not run as no versions were given\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        command_output_data = command_output[\"details\"][\"packages\"][\"TerminAttr-core\"][\"version\"]\n        if command_output_data in versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device is running TerminAttr version {command_output_data} and is not in the allowed list: {versions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion.test","title":"test","text":"<pre><code>test(versions: Optional[List[str]] = None) -&gt; None\n</code></pre> <p>Run VerifyTerminAttrVersion validation</p> <p>Parameters:</p> Name Type Description Default <code>versions</code> <code>Optional[List[str]]</code> <p>List of allowed TerminAttr versions.</p> <code>None</code> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTerminAttrVersion validation\n\n    Args:\n        versions: List of allowed TerminAttr versions.\n    \"\"\"\n\n    if not versions:\n        self.result.is_skipped(\"VerifyTerminAttrVersion was not run as no versions were given\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    command_output_data = command_output[\"details\"][\"packages\"][\"TerminAttr-core\"][\"version\"]\n    if command_output_data in versions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device is running TerminAttr version {command_output_data} and is not in the allowed list: {versions}\")\n</code></pre>"},{"location":"api/tests.stp/","title":"STP","text":""},{"location":"api/tests.stp/#anta-catalog-for-stp-tests","title":"ANTA catalog for STP tests","text":"<p>Test functions related to various Spanning Tree Protocol (STP) settings</p>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPBlockedPorts","title":"VerifySTPBlockedPorts","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no STP blocked ports.</p> Expected Results <ul> <li>success: The test will pass if there are NO ports blocked by STP.</li> <li>failure: The test will fail if there are ports blocked by STP.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPBlockedPorts(AntaTest):\n\"\"\"\n    Verifies there is no STP blocked ports.\n\n    Expected Results:\n        * success: The test will pass if there are NO ports blocked by STP.\n        * failure: The test will fail if there are ports blocked by STP.\n    \"\"\"\n\n    name = \"VerifySTPBlockedPorts\"\n    description = \"Verifies there is no STP blocked ports.\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree blockedports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySTPBlockedPorts validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if not (stp_instances := command_output[\"spanningTreeInstances\"]):\n            self.result.is_success()\n        else:\n            for key, value in stp_instances.items():\n                stp_instances[key] = value.pop(\"spanningTreeBlockedPorts\")\n            self.result.is_failure(f\"The following ports are blocked by STP: {stp_instances}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPBlockedPorts.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifySTPBlockedPorts validation</p> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySTPBlockedPorts validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if not (stp_instances := command_output[\"spanningTreeInstances\"]):\n        self.result.is_success()\n    else:\n        for key, value in stp_instances.items():\n            stp_instances[key] = value.pop(\"spanningTreeBlockedPorts\")\n        self.result.is_failure(f\"The following ports are blocked by STP: {stp_instances}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPCounters","title":"VerifySTPCounters","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies there is no errors in STP BPDU packets.</p> Expected Results <ul> <li>success: The test will pass if there are NO STP BPDU packet errors under all interfaces participating in STP.</li> <li>failure: The test will fail if there are STP BPDU packet errors on one or many interface(s).</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPCounters(AntaTest):\n\"\"\"\n    Verifies there is no errors in STP BPDU packets.\n\n    Expected Results:\n        * success: The test will pass if there are NO STP BPDU packet errors under all interfaces participating in STP.\n        * failure: The test will fail if there are STP BPDU packet errors on one or many interface(s).\n    \"\"\"\n\n    name = \"VerifySTPCounters\"\n    description = \"Verifies there is no errors in STP BPDU packets.\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree counters\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySTPBlockedPorts validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        interfaces_with_errors = [\n            interface for interface, counters in command_output[\"interfaces\"].items() if counters[\"bpduTaggedError\"] or counters[\"bpduOtherError\"] != 0\n        ]\n\n        if interfaces_with_errors:\n            self.result.is_failure(f\"The following interfaces have STP BPDU packet errors: {interfaces_with_errors}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPCounters.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifySTPBlockedPorts validation</p> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySTPBlockedPorts validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    interfaces_with_errors = [\n        interface for interface, counters in command_output[\"interfaces\"].items() if counters[\"bpduTaggedError\"] or counters[\"bpduOtherError\"] != 0\n    ]\n\n    if interfaces_with_errors:\n        self.result.is_failure(f\"The following interfaces have STP BPDU packet errors: {interfaces_with_errors}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPForwardingPorts","title":"VerifySTPForwardingPorts","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies that all interfaces are in a forwarding state for a provided list of VLAN(s).</p> Expected Results <ul> <li>success: The test will pass if all interfaces are in a forwarding state for the specified VLAN(s).</li> <li>failure: The test will fail if one or many interfaces are NOT in a forwarding state in the specified VLAN(s).</li> <li>error: The test will give an error if a list of VLAN(s) is not provided as template_params.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPForwardingPorts(AntaTest):\n\"\"\"\n    Verifies that all interfaces are in a forwarding state for a provided list of VLAN(s).\n\n    Expected Results:\n        * success: The test will pass if all interfaces are in a forwarding state for the specified VLAN(s).\n        * failure: The test will fail if one or many interfaces are NOT in a forwarding state in the specified VLAN(s).\n        * error: The test will give an error if a list of VLAN(s) is not provided as template_params.\n    \"\"\"\n\n    name = \"VerifySTPForwardingPorts\"\n    description = \"Verifies that all interfaces are forwarding for a provided list of VLAN(s).\"\n    categories = [\"stp\"]\n    template = AntaTemplate(template=\"show spanning-tree topology vlan {vlan} status\")\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySTPForwardingPorts validation.\n        \"\"\"\n\n        self.result.is_success()\n\n        for command in self.instance_commands:\n            if command.params and \"vlan\" in command.params:\n                vlan_id = command.params[\"vlan\"]\n\n            if not (topologies := get_value(command.json_output, \"topologies\")):\n                self.result.is_failure(f\"STP instance for VLAN {vlan_id} is not configured\")\n\n            else:\n                for value in topologies.values():\n                    if int(vlan_id) in value[\"vlans\"]:\n                        interfaces_not_forwarding = [interface for interface, state in value[\"interfaces\"].items() if state[\"state\"] != \"forwarding\"]\n\n                if interfaces_not_forwarding:\n                    self.result.is_failure(f\"The following interface(s) are not in a forwarding state for VLAN {vlan_id}: {interfaces_not_forwarding}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPForwardingPorts.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifySTPForwardingPorts validation.</p> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySTPForwardingPorts validation.\n    \"\"\"\n\n    self.result.is_success()\n\n    for command in self.instance_commands:\n        if command.params and \"vlan\" in command.params:\n            vlan_id = command.params[\"vlan\"]\n\n        if not (topologies := get_value(command.json_output, \"topologies\")):\n            self.result.is_failure(f\"STP instance for VLAN {vlan_id} is not configured\")\n\n        else:\n            for value in topologies.values():\n                if int(vlan_id) in value[\"vlans\"]:\n                    interfaces_not_forwarding = [interface for interface, state in value[\"interfaces\"].items() if state[\"state\"] != \"forwarding\"]\n\n            if interfaces_not_forwarding:\n                self.result.is_failure(f\"The following interface(s) are not in a forwarding state for VLAN {vlan_id}: {interfaces_not_forwarding}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode","title":"VerifySTPMode","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the configured STP mode for a provided list of VLAN(s).</p> Expected Results <ul> <li>success: The test will pass if the STP mode is configured properly in the specified VLAN(s).</li> <li>failure: The test will fail if the STP mode is NOT configured properly for one or more specified VLAN(s).</li> <li>skipped: The test will be skipped if the STP mode is not provided.</li> <li>error: The test will give an error if a list of VLAN(s) is not provided as template_params.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPMode(AntaTest):\n\"\"\"\n    Verifies the configured STP mode for a provided list of VLAN(s).\n\n    Expected Results:\n        * success: The test will pass if the STP mode is configured properly in the specified VLAN(s).\n        * failure: The test will fail if the STP mode is NOT configured properly for one or more specified VLAN(s).\n        * skipped: The test will be skipped if the STP mode is not provided.\n        * error: The test will give an error if a list of VLAN(s) is not provided as template_params.\n    \"\"\"\n\n    name = \"VerifySTPMode\"\n    description = \"Verifies the configured STP mode for a provided list of VLAN(s).\"\n    categories = [\"stp\"]\n    template = AntaTemplate(template=\"show spanning-tree vlan {vlan}\")\n\n    @staticmethod\n    def _check_stp_mode(mode: str) -&gt; None:\n\"\"\"\n        Verifies if the provided STP mode is compatible with Arista EOS devices.\n\n        Args:\n            mode: The STP mode to verify.\n        \"\"\"\n        stp_modes = [\"mstp\", \"rstp\", \"rapidPvst\"]\n\n        if mode not in stp_modes:\n            raise ValueError(f\"Wrong STP mode provided. Valid modes are: {stp_modes}\")\n\n    @AntaTest.anta_test\n    def test(self, mode: str = \"mstp\") -&gt; None:\n\"\"\"\n        Run VerifySTPVersion validation.\n\n        Args:\n            mode: STP mode to verify. Defaults to 'mstp'.\n        \"\"\"\n        if not mode:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because mode was not supplied\")\n            return\n\n        self._check_stp_mode(mode)\n\n        self.result.is_success()\n\n        for command in self.instance_commands:\n            if command.params and \"vlan\" in command.params:\n                vlan_id = command.params[\"vlan\"]\n            if not (stp_mode := get_value(command.json_output, f\"spanningTreeVlanInstances.{vlan_id}.spanningTreeVlanInstance.protocol\")):\n                self.result.is_failure(f\"STP mode '{mode}' not configured for VLAN {vlan_id}\")\n\n            elif stp_mode != mode:\n                self.result.is_failure(f\"Wrong STP mode configured for VLAN {vlan_id}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPMode.test","title":"test","text":"<pre><code>test(mode: str = 'mstp') -&gt; None\n</code></pre> <p>Run VerifySTPVersion validation.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>STP mode to verify. Defaults to \u2018mstp\u2019.</p> <code>'mstp'</code> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, mode: str = \"mstp\") -&gt; None:\n\"\"\"\n    Run VerifySTPVersion validation.\n\n    Args:\n        mode: STP mode to verify. Defaults to 'mstp'.\n    \"\"\"\n    if not mode:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because mode was not supplied\")\n        return\n\n    self._check_stp_mode(mode)\n\n    self.result.is_success()\n\n    for command in self.instance_commands:\n        if command.params and \"vlan\" in command.params:\n            vlan_id = command.params[\"vlan\"]\n        if not (stp_mode := get_value(command.json_output, f\"spanningTreeVlanInstances.{vlan_id}.spanningTreeVlanInstance.protocol\")):\n            self.result.is_failure(f\"STP mode '{mode}' not configured for VLAN {vlan_id}\")\n\n        elif stp_mode != mode:\n            self.result.is_failure(f\"Wrong STP mode configured for VLAN {vlan_id}\")\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority","title":"VerifySTPRootPriority","text":"<p>             Bases: <code>AntaTest</code></p> <p>Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).</p> Expected Results <ul> <li>success: The test will pass if the STP root priority is configured properly for the specified VLAN or MST instance ID(s).</li> <li>failure: The test will fail if the STP root priority is NOT configured properly for the specified VLAN or MST instance ID(s).</li> <li>skipped: The test will be skipped if the STP root priority is not provided.</li> </ul> Source code in <code>anta/tests/stp.py</code> <pre><code>class VerifySTPRootPriority(AntaTest):\n\"\"\"\n    Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).\n\n    Expected Results:\n        * success: The test will pass if the STP root priority is configured properly for the specified VLAN or MST instance ID(s).\n        * failure: The test will fail if the STP root priority is NOT configured properly for the specified VLAN or MST instance ID(s).\n        * skipped: The test will be skipped if the STP root priority is not provided.\n    \"\"\"\n\n    name = \"VerifySTPRootPriority\"\n    description = \"Verifies the STP root priority for a provided list of VLAN or MST instance ID(s).\"\n    categories = [\"stp\"]\n    commands = [AntaCommand(command=\"show spanning-tree root detail\")]\n\n    @AntaTest.anta_test\n    def test(self, priority: Optional[int] = None, instances: Optional[List[int]] = None) -&gt; None:\n\"\"\"\n        Run VerifySTPRootPriority validation.\n\n        Args:\n            priority: STP root priority to verify.\n            instances: List of VLAN or MST instance ID(s). By default, ALL VLAN or MST instance ID(s) will be verified.\n        \"\"\"\n        if not priority:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because priority was not supplied\")\n            return\n\n        command_output = self.instance_commands[0].json_output\n\n        if not (stp_instances := command_output[\"instances\"]):\n            self.result.is_failure(\"No STP instances configured\")\n            return\n\n        for instance in stp_instances:\n            if instance.startswith(\"MST\"):\n                prefix = \"MST\"\n                break\n            if instance.startswith(\"VL\"):\n                prefix = \"VL\"\n                break\n\n        check_instances = [f\"{prefix}{instance_id}\" for instance_id in instances] if instances else command_output[\"instances\"].keys()\n\n        wrong_priority_instances = [instance for instance in check_instances if get_value(command_output, f\"instances.{instance}.rootBridge.priority\") != priority]\n\n        if wrong_priority_instances:\n            self.result.is_failure(f\"The following instance(s) have the wrong STP root priority configured: {wrong_priority_instances}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.stp/#anta.tests.stp.VerifySTPRootPriority.test","title":"test","text":"<pre><code>test(priority: Optional[int] = None, instances: Optional[List[int]] = None) -&gt; None\n</code></pre> <p>Run VerifySTPRootPriority validation.</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>Optional[int]</code> <p>STP root priority to verify.</p> <code>None</code> <code>instances</code> <code>Optional[List[int]]</code> <p>List of VLAN or MST instance ID(s). By default, ALL VLAN or MST instance ID(s) will be verified.</p> <code>None</code> Source code in <code>anta/tests/stp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, priority: Optional[int] = None, instances: Optional[List[int]] = None) -&gt; None:\n\"\"\"\n    Run VerifySTPRootPriority validation.\n\n    Args:\n        priority: STP root priority to verify.\n        instances: List of VLAN or MST instance ID(s). By default, ALL VLAN or MST instance ID(s) will be verified.\n    \"\"\"\n    if not priority:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because priority was not supplied\")\n        return\n\n    command_output = self.instance_commands[0].json_output\n\n    if not (stp_instances := command_output[\"instances\"]):\n        self.result.is_failure(\"No STP instances configured\")\n        return\n\n    for instance in stp_instances:\n        if instance.startswith(\"MST\"):\n            prefix = \"MST\"\n            break\n        if instance.startswith(\"VL\"):\n            prefix = \"VL\"\n            break\n\n    check_instances = [f\"{prefix}{instance_id}\" for instance_id in instances] if instances else command_output[\"instances\"].keys()\n\n    wrong_priority_instances = [instance for instance in check_instances if get_value(command_output, f\"instances.{instance}.rootBridge.priority\") != priority]\n\n    if wrong_priority_instances:\n        self.result.is_failure(f\"The following instance(s) have the wrong STP root priority configured: {wrong_priority_instances}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.system/","title":"System","text":""},{"location":"api/tests.system/#anta-catalog-for-system-tests","title":"ANTA catalog for system tests","text":"<p>Test functions related to system-level features and protocols</p>"},{"location":"api/tests.system/#anta.tests.system.VerifyAgentLogs","title":"VerifyAgentLogs","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that no agent crash reports are present on the device.</p> Expected Results <ul> <li>success: The test will pass if there is NO agent crash reported.</li> <li>failure: The test will fail if any agent crashes are reported.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyAgentLogs(AntaTest):\n\"\"\"\n    This test verifies that no agent crash reports are present on the device.\n\n    Expected Results:\n      * success: The test will pass if there is NO agent crash reported.\n      * failure: The test will fail if any agent crashes are reported.\n    \"\"\"\n\n    name = \"VerifyAgentLogs\"\n    description = \"This test verifies that no agent crash reports are present on the device.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show agent logs crash\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyAgentLogs validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            pattern = re.compile(r\"^===&gt; (.*?) &lt;===$\", re.MULTILINE)\n            agents = \"\\n * \".join(pattern.findall(command_output))\n            self.result.is_failure(f\"Device has reported agent crashes:\\n * {agents}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyAgentLogs.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyAgentLogs validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyAgentLogs validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        pattern = re.compile(r\"^===&gt; (.*?) &lt;===$\", re.MULTILINE)\n        agents = \"\\n * \".join(pattern.findall(command_output))\n        self.result.is_failure(f\"Device has reported agent crashes:\\n * {agents}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCPUUtilization","title":"VerifyCPUUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies whether the CPU utilization is below 75%.</p> Expected Results <ul> <li>success: The test will pass if the CPU utilization is below 75%.</li> <li>failure: The test will fail if the CPU utilization is over 75%.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCPUUtilization(AntaTest):\n\"\"\"\n    This test verifies whether the CPU utilization is below 75%.\n\n    Expected Results:\n      * success: The test will pass if the CPU utilization is below 75%.\n      * failure: The test will fail if the CPU utilization is over 75%.\n    \"\"\"\n\n    name = \"VerifyCPUUtilization\"\n    description = \"This test verifies whether the CPU utilization is below 75%.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show processes top once\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyCPUUtilization validation\n        \"\"\"\n        command_output = self.instance_commands[0].json_output\n        command_output_data = command_output[\"cpuInfo\"][\"%Cpu(s)\"][\"idle\"]\n\n        if command_output_data &gt; 25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device has reported a high CPU utilization: {100 - command_output_data}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCPUUtilization.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyCPUUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyCPUUtilization validation\n    \"\"\"\n    command_output = self.instance_commands[0].json_output\n    command_output_data = command_output[\"cpuInfo\"][\"%Cpu(s)\"][\"idle\"]\n\n    if command_output_data &gt; 25:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device has reported a high CPU utilization: {100 - command_output_data}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCoredump","title":"VerifyCoredump","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if there are core files saved in the /var/core directory.</p> Expected Results <ul> <li>success: The test will pass if there are NO core files saved in the directory.</li> <li>failure: The test will fail if there are core files saved in the directory.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCoredump(AntaTest):\n\"\"\"\n    This test verifies if there are core files saved in the /var/core directory.\n\n    Expected Results:\n      * success: The test will pass if there are NO core files saved in the directory.\n      * failure: The test will fail if there are core files saved in the directory.\n    \"\"\"\n\n    name = \"VerifyCoredump\"\n    description = \"This test verifies if there are core files saved in the /var/core directory.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"bash timeout 10 ls /var/core\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyCoredump validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            command_output = command_output.replace(\"\\n\", \"\")\n            self.result.is_failure(f\"Core-dump(s) have been found: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCoredump.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyCoredump validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyCoredump validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        command_output = command_output.replace(\"\\n\", \"\")\n        self.result.is_failure(f\"Core-dump(s) have been found: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyFileSystemUtilization","title":"VerifyFileSystemUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that no partition is utilizing more than 75% of its disk space.</p> Expected Results <ul> <li>success: The test will pass if all partitions are using less than 75% of its disk space.</li> <li>failure: The test will fail if any partitions are using more than 75% of its disk space.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyFileSystemUtilization(AntaTest):\n\"\"\"\n    This test verifies that no partition is utilizing more than 75% of its disk space.\n\n    Expected Results:\n      * success: The test will pass if all partitions are using less than 75% of its disk space.\n      * failure: The test will fail if any partitions are using more than 75% of its disk space.\n    \"\"\"\n\n    name = \"VerifyFileSystemUtilization\"\n    description = \"This test verifies that no partition is utilizing more than 75% of its disk space.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"bash timeout 10 df -h\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyFileSystemUtilization validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        self.result.is_success()\n\n        for line in command_output.split(\"\\n\")[1:]:\n            if \"loop\" not in line and len(line) &gt; 0 and (percentage := int(line.split()[4].replace(\"%\", \"\"))) &gt; 75:\n                self.result.is_failure(f\"Mount point {line} is higher than 75%: reported {percentage}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyFileSystemUtilization.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyFileSystemUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyFileSystemUtilization validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    self.result.is_success()\n\n    for line in command_output.split(\"\\n\")[1:]:\n        if \"loop\" not in line and len(line) &gt; 0 and (percentage := int(line.split()[4].replace(\"%\", \"\"))) &gt; 75:\n            self.result.is_failure(f\"Mount point {line} is higher than 75%: reported {percentage}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyMemoryUtilization","title":"VerifyMemoryUtilization","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies whether the memory utilization is below 75%.</p> Expected Results <ul> <li>success: The test will pass if the memory utilization is below 75%.</li> <li>failure: The test will fail if the memory utilization is over 75%.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyMemoryUtilization(AntaTest):\n\"\"\"\n    This test verifies whether the memory utilization is below 75%.\n\n    Expected Results:\n      * success: The test will pass if the memory utilization is below 75%.\n      * failure: The test will fail if the memory utilization is over 75%.\n    \"\"\"\n\n    name = \"VerifyMemoryUtilization\"\n    description = \"This test verifies whether the memory utilization is below 75%.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show version\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMemoryUtilization validation\n        \"\"\"\n        command_output = self.instance_commands[0].json_output\n\n        memory_usage = command_output[\"memFree\"] / command_output[\"memTotal\"]\n        if memory_usage &gt; 0.25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device has reported a high memory usage: {(1 - memory_usage)*100:.2f}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyMemoryUtilization.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyMemoryUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMemoryUtilization validation\n    \"\"\"\n    command_output = self.instance_commands[0].json_output\n\n    memory_usage = command_output[\"memFree\"] / command_output[\"memTotal\"]\n    if memory_usage &gt; 0.25:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device has reported a high memory usage: {(1 - memory_usage)*100:.2f}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyNTP","title":"VerifyNTP","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that the Network Time Protocol (NTP) is synchronized.</p> Expected Results <ul> <li>success: The test will pass if the NTP is synchronised.</li> <li>failure: The test will fail if the NTP is NOT synchronised.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyNTP(AntaTest):\n\"\"\"\n    This test verifies that the Network Time Protocol (NTP) is synchronized.\n\n    Expected Results:\n      * success: The test will pass if the NTP is synchronised.\n      * failure: The test will fail if the NTP is NOT synchronised.\n    \"\"\"\n\n    name = \"VerifyNTP\"\n    description = \"This test verifies if NTP is synchronised.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show ntp status\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyNTP validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if command_output.split(\"\\n\")[0].split(\" \")[0] == \"synchronised\":\n            self.result.is_success()\n        else:\n            data = command_output.split(\"\\n\")[0]\n            self.result.is_failure(f\"NTP server is not synchronized: '{data}'\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyNTP.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyNTP validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyNTP validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if command_output.split(\"\\n\")[0].split(\" \")[0] == \"synchronised\":\n        self.result.is_success()\n    else:\n        data = command_output.split(\"\\n\")[0]\n        self.result.is_failure(f\"NTP server is not synchronized: '{data}'\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyReloadCause","title":"VerifyReloadCause","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies the last reload cause of the device.</p> Expected Results <ul> <li>success: The test will pass if there are NO reload causes or if the last reload was caused by the user or after an FPGA upgrade.</li> <li>failure: The test will fail if the last reload was NOT caused by the user or after an FPGA upgrade.</li> <li>error: The test will report an error if the reload cause is NOT available.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyReloadCause(AntaTest):\n\"\"\"\n    This test verifies the last reload cause of the device.\n\n    Expected Results:\n      * success: The test will pass if there are NO reload causes or if the last reload was caused by the user or after an FPGA upgrade.\n      * failure: The test will fail if the last reload was NOT caused by the user or after an FPGA upgrade.\n      * error: The test will report an error if the reload cause is NOT available.\n    \"\"\"\n\n    name = \"VerifyReloadCause\"\n    description = \"This test verifies the last reload cause of the device.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show reload cause\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyReloadCause validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if \"resetCauses\" not in command_output.keys():\n            self.result.is_error(\"No reload causes available\")\n            return\n\n        if len(command_output[\"resetCauses\"]) == 0:\n            # No reload causes\n            self.result.is_success()\n            return\n\n        reset_causes = command_output[\"resetCauses\"]\n        command_output_data = reset_causes[0].get(\"description\")\n        if command_output_data in [\n            \"Reload requested by the user.\",\n            \"Reload requested after FPGA upgrade\",\n        ]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Reload cause is: '{command_output_data}'\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyReloadCause.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyReloadCause validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyReloadCause validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if \"resetCauses\" not in command_output.keys():\n        self.result.is_error(\"No reload causes available\")\n        return\n\n    if len(command_output[\"resetCauses\"]) == 0:\n        # No reload causes\n        self.result.is_success()\n        return\n\n    reset_causes = command_output[\"resetCauses\"]\n    command_output_data = reset_causes[0].get(\"description\")\n    if command_output_data in [\n        \"Reload requested by the user.\",\n        \"Reload requested after FPGA upgrade\",\n    ]:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Reload cause is: '{command_output_data}'\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifySyslog","title":"VerifySyslog","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies there are no syslog messages with a severity of WARNING or higher in the last 7 days.</p> Expected Results <ul> <li>success: The test will pass if there are NO syslog messages with a severity of WARNING or higher in the last 7 days.</li> <li>failure: The test will fail if WARNING or higher syslog messages are present in the last 7 days.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifySyslog(AntaTest):\n\"\"\"\n    This test verifies there are no syslog messages with a severity of WARNING or higher in the last 7 days.\n\n    Expected Results:\n      * success: The test will pass if there are NO syslog messages with a severity of WARNING or higher in the last 7 days.\n      * failure: The test will fail if WARNING or higher syslog messages are present in the last 7 days.\n    \"\"\"\n\n    name = \"VerifySyslog\"\n    description = \"This test verifies there are no syslog messages with a severity of WARNING or higher in the last 7 days.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show logging last 7 days threshold warnings\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySyslog validation\n        \"\"\"\n        command_output = self.instance_commands[0].text_output\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Device has reported some log messages with WARNING or higher severity\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifySyslog.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifySyslog validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySyslog validation\n    \"\"\"\n    command_output = self.instance_commands[0].text_output\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Device has reported some log messages with WARNING or higher severity\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime","title":"VerifyUptime","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if the device uptime is higher than the provided minimum uptime value.</p> Expected Results <ul> <li>success: The test will pass if the device uptime is higher than the provided value.</li> <li>failure: The test will fail if the device uptime is lower than the provided value.</li> <li>skipped: The test will be skipped if the provided uptime value is invalid or negative.</li> </ul> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyUptime(AntaTest):\n\"\"\"\n    This test verifies if the device uptime is higher than the provided minimum uptime value.\n\n    Expected Results:\n      * success: The test will pass if the device uptime is higher than the provided value.\n      * failure: The test will fail if the device uptime is lower than the provided value.\n      * skipped: The test will be skipped if the provided uptime value is invalid or negative.\n    \"\"\"\n\n    name = \"VerifyUptime\"\n    description = \"This test verifies if the device uptime is higher than the provided minimum uptime value.\"\n    categories = [\"system\"]\n    commands = [AntaCommand(command=\"show uptime\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n        Run VerifyUptime validation\n\n        Args:\n            minimum: Minimum uptime in seconds.\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if not (isinstance(minimum, (int, float))) or minimum &lt; 0:\n            self.result.is_skipped(f\"{self.__class__.name} was not run since the provided uptime value is invalid or negative\")\n            return\n\n        if command_output[\"upTime\"] &gt; minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device uptime is {command_output['upTime']} seconds\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime.test","title":"test","text":"<pre><code>test(minimum: Optional[int] = None) -&gt; None\n</code></pre> <p>Run VerifyUptime validation</p> <p>Parameters:</p> Name Type Description Default <code>minimum</code> <code>Optional[int]</code> <p>Minimum uptime in seconds.</p> <code>None</code> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: Optional[int] = None) -&gt; None:\n\"\"\"\n    Run VerifyUptime validation\n\n    Args:\n        minimum: Minimum uptime in seconds.\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if not (isinstance(minimum, (int, float))) or minimum &lt; 0:\n        self.result.is_skipped(f\"{self.__class__.name} was not run since the provided uptime value is invalid or negative\")\n        return\n\n    if command_output[\"upTime\"] &gt; minimum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device uptime is {command_output['upTime']} seconds\")\n</code></pre>"},{"location":"api/tests.vxlan/","title":"VXLAN","text":""},{"location":"api/tests.vxlan/#anta-catalog-for-vxlan-tests","title":"ANTA catalog for VXLAN tests","text":"<p>Test functions related to VXLAN</p>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlan1Interface","title":"VerifyVxlan1Interface","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies if the Vxlan1 interface is configured and \u2018up/up\u2019.</p> <p>Warning</p> <p>The name of this test has been updated from \u2018VerifyVxlan\u2019 for better representation.</p> Expected Results <ul> <li>success: The test will pass if the Vxlan1 interface is configured with line protocol status and interface status \u2018up\u2019.</li> <li>failure: The test will fail if the Vxlan1 interface line protocol status or interface status are not \u2018up\u2019.</li> <li>skipped: The test will be skipped if the Vxlan1 interface is not configured.</li> </ul> Source code in <code>anta/tests/vxlan.py</code> <pre><code>class VerifyVxlan1Interface(AntaTest):\n\"\"\"\n    This test verifies if the Vxlan1 interface is configured and 'up/up'.\n\n    !!! warning\n        The name of this test has been updated from 'VerifyVxlan' for better representation.\n\n    Expected Results:\n      * success: The test will pass if the Vxlan1 interface is configured with line protocol status and interface status 'up'.\n      * failure: The test will fail if the Vxlan1 interface line protocol status or interface status are not 'up'.\n      * skipped: The test will be skipped if the Vxlan1 interface is not configured.\n    \"\"\"\n\n    name = \"VerifyVxlan1Interface\"\n    description = \"This test verifies if the Vxlan1 interface is configured and 'up/up'.\"\n    categories = [\"vxlan\"]\n    commands = [AntaCommand(command=\"show interfaces description\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyVxlan1Interface validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if \"Vxlan1\" not in command_output[\"interfaceDescriptions\"]:\n            self.result.is_skipped(\"Vxlan1 interface is not configured\")\n        elif (\n            command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"lineProtocolStatus\"] == \"up\"\n            and command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"interfaceStatus\"] == \"up\"\n        ):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\n                f\"Vxlan1 interface is {command_output['interfaceDescriptions']['Vxlan1']['lineProtocolStatus']}\"\n                f\"/{command_output['interfaceDescriptions']['Vxlan1']['interfaceStatus']}\"\n            )\n</code></pre>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlan1Interface.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyVxlan1Interface validation</p> Source code in <code>anta/tests/vxlan.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyVxlan1Interface validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if \"Vxlan1\" not in command_output[\"interfaceDescriptions\"]:\n        self.result.is_skipped(\"Vxlan1 interface is not configured\")\n    elif (\n        command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"lineProtocolStatus\"] == \"up\"\n        and command_output[\"interfaceDescriptions\"][\"Vxlan1\"][\"interfaceStatus\"] == \"up\"\n    ):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\n            f\"Vxlan1 interface is {command_output['interfaceDescriptions']['Vxlan1']['lineProtocolStatus']}\"\n            f\"/{command_output['interfaceDescriptions']['Vxlan1']['interfaceStatus']}\"\n        )\n</code></pre>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlanConfigSanity","title":"VerifyVxlanConfigSanity","text":"<p>             Bases: <code>AntaTest</code></p> <p>This test verifies that no issues are detected with the VXLAN configuration.</p> Expected Results <ul> <li>success: The test will pass if no issues are detected with the VXLAN configuration.</li> <li>failure: The test will fail if issues are detected with the VXLAN configuration.</li> <li>skipped: The test will be skipped if VXLAN is not configured on the device.</li> </ul> Source code in <code>anta/tests/vxlan.py</code> <pre><code>class VerifyVxlanConfigSanity(AntaTest):\n\"\"\"\n    This test verifies that no issues are detected with the VXLAN configuration.\n\n    Expected Results:\n      * success: The test will pass if no issues are detected with the VXLAN configuration.\n      * failure: The test will fail if issues are detected with the VXLAN configuration.\n      * skipped: The test will be skipped if VXLAN is not configured on the device.\n    \"\"\"\n\n    name = \"VerifyVxlanConfigSanity\"\n    description = \"This test verifies that no issues are detected with the VXLAN configuration.\"\n    categories = [\"vxlan\"]\n    commands = [AntaCommand(command=\"show vxlan config-sanity\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyVxlanConfigSanity validation\n        \"\"\"\n\n        command_output = self.instance_commands[0].json_output\n\n        if \"categories\" not in command_output or len(command_output[\"categories\"]) == 0:\n            self.result.is_skipped(\"VXLAN is not configured\")\n            return\n\n        failed_categories = {\n            category: content\n            for category, content in command_output[\"categories\"].items()\n            if category in [\"localVtep\", \"mlag\", \"pd\"] and content[\"allCheckPass\"] is not True\n        }\n\n        if len(failed_categories) &gt; 0:\n            self.result.is_failure(f\"VXLAN config sanity check is not passing: {failed_categories}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.vxlan/#anta.tests.vxlan.VerifyVxlanConfigSanity.test","title":"test","text":"<pre><code>test() -&gt; None\n</code></pre> <p>Run VerifyVxlanConfigSanity validation</p> Source code in <code>anta/tests/vxlan.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyVxlanConfigSanity validation\n    \"\"\"\n\n    command_output = self.instance_commands[0].json_output\n\n    if \"categories\" not in command_output or len(command_output[\"categories\"]) == 0:\n        self.result.is_skipped(\"VXLAN is not configured\")\n        return\n\n    failed_categories = {\n        category: content\n        for category, content in command_output[\"categories\"].items()\n        if category in [\"localVtep\", \"mlag\", \"pd\"] and content[\"allCheckPass\"] is not True\n    }\n\n    if len(failed_categories) &gt; 0:\n        self.result.is_failure(f\"VXLAN config sanity check is not passing: {failed_categories}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"cli/debug/","title":"Helpers","text":""},{"location":"cli/debug/#anta-debug-commands","title":"ANTA debug commands","text":"<p>The ANTA CLI includes a set of debugging tools, making it easier to build and test ANTA content. This functionality is accessed via the <code>debug</code> subcommand and offers the following options:</p> <ul> <li>Executing a command on a device from your inventory and retrieving the result.</li> <li>Running a templated command on a device from your inventory and retrieving the result.</li> </ul> <p>These tools are especially helpful in building the tests, as they give a visual access to the output received from the eAPI. They also facilitate the extraction of output content for use in unit tests, as described in our contribution guide.</p> <p>Warning</p> <p>The <code>debug</code> tools require a device from your inventory. Thus, you MUST use a valid ANTA Inventory.</p>"},{"location":"cli/debug/#executing-an-eos-command","title":"Executing an EOS command","text":"<p>You can use the <code>run-cmd</code> entrypoint to run a command, which includes the following options:</p>"},{"location":"cli/debug/#command-overview","title":"Command overview","text":"<pre><code>$ anta debug run-cmd --help\nUsage: anta debug run-cmd [OPTIONS]\n\nRun arbitrary command to an ANTA device\n\nOptions:\n  -c, --command TEXT        Command to run  [required]\n--ofmt [json|text]        EOS eAPI format to use. can be text or json\n  -v, --version [1|latest]  EOS eAPI version\n  -r, --revision INTEGER    eAPI command revision\n  -d, --device TEXT         Device from inventory to use  [required]\n--help                    Show this message and exit.\n</code></pre>"},{"location":"cli/debug/#example","title":"Example","text":"<p>This example illustrates how to run the <code>show interfaces description</code> command with a <code>JSON</code> format (default):</p> <pre><code>anta debug run-cmd --command \"show interfaces description\" --device DC1-SPINE1\nRun command show interfaces description on DC1-SPINE1\n{\n'interfaceDescriptions': {\n'Ethernet1': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-LEAF1A_Ethernet1', 'interfaceStatus': 'up'},\n        'Ethernet2': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-LEAF1B_Ethernet1', 'interfaceStatus': 'up'},\n        'Ethernet3': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-BL1_Ethernet1', 'interfaceStatus': 'up'},\n        'Ethernet4': {'lineProtocolStatus': 'up', 'description': 'P2P_LINK_TO_DC1-BL2_Ethernet1', 'interfaceStatus': 'up'},\n        'Loopback0': {'lineProtocolStatus': 'up', 'description': 'EVPN_Overlay_Peering', 'interfaceStatus': 'up'},\n        'Management0': {'lineProtocolStatus': 'up', 'description': 'oob_management', 'interfaceStatus': 'up'}\n}\n}\n</code></pre>"},{"location":"cli/debug/#executing-an-eos-command-using-templates","title":"Executing an EOS command using templates","text":"<p>The <code>run-template</code> entrypoint allows the user to provide an <code>f-string</code> templated command. It is followed by a list of arguments (key-value pairs) that build a dictionary used as template parameters.</p>"},{"location":"cli/debug/#command-overview_1","title":"Command overview","text":"<pre><code>$ anta debug run-template --help\nUsage: anta debug run-template [OPTIONS] PARAMS...\n\n  Run arbitrary templated command to an ANTA device.\n\n  Takes a list of arguments (keys followed by a value) to build a dictionary\n  used as template parameters. Example:\n\n  anta debug run-template -d leaf1a -t 'show vlan {vlan_id}' vlan_id 1\n\nOptions:\n  -t, --template TEXT       Command template to run. E.g. 'show vlan\n                            {vlan_id}'  [required]\n--ofmt [json|text]        EOS eAPI format to use. can be text or json\n  -v, --version [1|latest]  EOS eAPI version\n  -r, --revision INTEGER    eAPI command revision\n  -d, --device TEXT         Device from inventory to use  [required]\n--help                    Show this message and exit.\n</code></pre>"},{"location":"cli/debug/#example_1","title":"Example","text":"<p>This example uses the <code>show vlan {vlan_id}</code> command in a <code>JSON</code> format:</p> <pre><code>anta debug run-template --template \"show vlan {vlan_id}\" vlan_id 10 --device DC1-LEAF1A\nRun templated command 'show vlan {vlan_id}' with {'vlan_id': '10'} on DC1-LEAF1A\n{\n'vlans': {\n'10': {\n'name': 'VRFPROD_VLAN10',\n            'dynamic': False,\n            'status': 'active',\n            'interfaces': {\n'Cpu': {'privatePromoted': False, 'blocked': None},\n                'Port-Channel11': {'privatePromoted': False, 'blocked': None},\n                'Vxlan1': {'privatePromoted': False, 'blocked': None}\n}\n}\n},\n    'sourceDetail': ''\n}\n</code></pre> <p>Warning</p> <p>If multiple arguments of the same key are provided, only the last argument value will be kept in the template parameters.</p>"},{"location":"cli/debug/#example-of-multiple-arguments","title":"Example of multiple arguments","text":"<pre><code>anta --log DEBUG debug run-template --template \"ping {dst} source {src}\" dst \"8.8.8.8\" src Loopback0 --device DC1-SPINE1 \u00a0 \u00a0\n&gt; {'dst': '8.8.8.8', 'src': 'Loopback0'}\n\nanta --log DEBUG debug run-template --template \"ping {dst} source {src}\" dst \"8.8.8.8\" src Loopback0 dst \"1.1.1.1\" src Loopback1 --device DC1-SPINE1 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \n&gt; {'dst': '1.1.1.1', 'src': 'Loopback1'}\n# Notice how `src` and `dst` keep only the latest value\n</code></pre>"},{"location":"cli/exec/","title":"Execute commands","text":""},{"location":"cli/exec/#executing-commands-on-devices","title":"Executing Commands on Devices","text":"<p>ANTA CLI provides a set of entrypoints to facilitate remote command execution on EOS devices.</p>"},{"location":"cli/exec/#exec-command-overview","title":"EXEC Command overview","text":"<pre><code>anta exec --help\nUsage: anta exec [OPTIONS] COMMAND [ARGS]...\n\n  Execute commands to inventory devices\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  clear-counters        Clear counter statistics on EOS devices\n  collect-tech-support  Collect scheduled tech-support from EOS devices\n  snapshot              Collect commands output from devices in inventory\n</code></pre>"},{"location":"cli/exec/#clear-interfaces-counters","title":"Clear interfaces counters","text":"<p>This command clears interface counters on EOS devices specified in your inventory.</p>"},{"location":"cli/exec/#command-overview","title":"Command overview","text":"<pre><code>anta exec clear-counters --help\nUsage: anta exec clear-counters [OPTIONS]\n\nClear counter statistics on EOS devices\n\nOptions:\n  -t, --tags TEXT  List of tags using comma as separator: tag1,tag2,tag3\n  --help           Show this message and exit.\n</code></pre>"},{"location":"cli/exec/#example","title":"Example","text":"<pre><code>anta exec clear-counters --tags SPINE\n[20:19:13] INFO     Connecting to devices...                                                                                                                         utils.py:43\n           INFO     Clearing counters on remote devices...                                                                                                           utils.py:46\n           INFO     Cleared counters on DC1-SPINE2 (cEOSLab)                                                                                                         utils.py:41\n           INFO     Cleared counters on DC2-SPINE1 (cEOSLab)                                                                                                         utils.py:41\n           INFO     Cleared counters on DC1-SPINE1 (cEOSLab)                                                                                                         utils.py:41\n           INFO     Cleared counters on DC2-SPINE2 (cEOSLab)\n</code></pre>"},{"location":"cli/exec/#collect-a-set-of-commands","title":"Collect a set of commands","text":"<p>This command collects all the commands specified in a commands-list file, which can be in either <code>json</code> or <code>text</code> format.</p>"},{"location":"cli/exec/#command-overview_1","title":"Command overview","text":"<pre><code>anta exec snapshot --help\nUsage: anta exec snapshot [OPTIONS]\n\nCollect commands output from devices in inventory\n\nOptions:\n  -t, --tags TEXT           List of tags using comma as separator:\n                            tag1,tag2,tag3\n  -c, --commands-list FILE  File with list of commands to collect  [env var:\n                            ANTA_EXEC_SNAPSHOT_COMMANDS_LIST; required]\n-o, --output DIRECTORY    Directory to save commands output. Will have a\n                            suffix with the format _YEAR-MONTH-DAY_HOUR-\n                            MINUTES-SECONDS'  [env var:\n                            ANTA_EXEC_SNAPSHOT_OUTPUT; default: anta_snapshot]\n--help                    Show this message and exit.\n</code></pre> <p>The commands-list file should follow this structure:</p> <pre><code>---\njson_format:\n- show version\ntext_format:\n- show bfd peers\n</code></pre>"},{"location":"cli/exec/#example_1","title":"Example","text":"<pre><code>anta exec snapshot --tags SPINE --commands-list ./commands.yaml --output ./\n[20:25:15] INFO     Connecting to devices...                                                                                                                         utils.py:78\n           INFO     Collecting commands from remote devices                                                                                                          utils.py:81\n           INFO     Collected command 'show version' from device DC2-SPINE1 (cEOSLab)                                                                                utils.py:76\n           INFO     Collected command 'show version' from device DC2-SPINE2 (cEOSLab)                                                                                utils.py:76\n           INFO     Collected command 'show version' from device DC1-SPINE1 (cEOSLab)                                                                                utils.py:76\n           INFO     Collected command 'show version' from device DC1-SPINE2 (cEOSLab)                                                                                utils.py:76\n[20:25:16] INFO     Collected command 'show bfd peers' from device DC2-SPINE2 (cEOSLab)                                                                              utils.py:76\n           INFO     Collected command 'show bfd peers' from device DC2-SPINE1 (cEOSLab)                                                                              utils.py:76\n           INFO     Collected command 'show bfd peers' from device DC1-SPINE1 (cEOSLab)                                                                              utils.py:76\n           INFO     Collected command 'show bfd peers' from device DC1-SPINE2 (cEOSLab)\n</code></pre> <p>The results of the executed commands will be stored in the output directory specified during command execution:</p> <pre><code>tree _2023-07-14_20_25_15\n_2023-07-14_20_25_15\n\u251c\u2500\u2500 DC1-SPINE1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 text\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 show bfd peers.log\n\u251c\u2500\u2500 DC1-SPINE2\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 text\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 show bfd peers.log\n\u251c\u2500\u2500 DC2-SPINE1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 json\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 text\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 show bfd peers.log\n\u2514\u2500\u2500 DC2-SPINE2\n    \u251c\u2500\u2500 json\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 show version.json\n    \u2514\u2500\u2500 text\n        \u2514\u2500\u2500 show bfd peers.log\n\n12 directories, 8 files\n</code></pre>"},{"location":"cli/exec/#get-scheduled-tech-support","title":"Get Scheduled tech-support","text":"<p>EOS offers a feature that automatically creates a tech-support archive every hour by default. These archives are stored under <code>/mnt/flash/schedule/tech-support</code>.</p> <pre><code>leaf1#show schedule summary\nMaximum concurrent jobs  1\nPrepend host name to logfile: Yes\nName                 At Time       Last        Interval       Timeout        Max        Max     Logfile Location                  Status\n                                   Time         (mins)        (mins)         Log        Logs\n                                                                            Files       Size\n----------------- ------------- ----------- -------------- ------------- ----------- ---------- --------------------------------- ------\ntech-support           now         08:37          60            30           100         -      flash:schedule/tech-support/      Success\n\n\nleaf1#bash ls /mnt/flash/schedule/tech-support\nleaf1_tech-support_2023-03-09.1337.log.gz  leaf1_tech-support_2023-03-10.0837.log.gz  leaf1_tech-support_2023-03-11.0337.log.gz\n</code></pre> <p>For Network Readiness for Use (NRFU) tests and to keep a comprehensive report of the system state before going live, ANTA provides a command-line interface that efficiently retrieves these files.</p>"},{"location":"cli/exec/#command-overview_2","title":"Command overview","text":"<pre><code>anta exec collect-tech-support --help\nUsage: anta exec collect-tech-support [OPTIONS]\n\nCollect scheduled tech-support from EOS devices\n\nOptions:\n  -o, --output PATH              Path for tests catalog  [default: ./tech-\n                                 support]\n--latest INTEGER               Number of scheduled show-tech to retrieve\n  --configure        Ensure devices have 'aaa authorization exec default\n                     local' configured (required for SCP on EOS). THIS WILL\n                     CHANGE THE CONFIGURATION OF YOUR NETWORK.\n  -t, --tags TEXT                List of tags using comma as separator:\n                                 tag1,tag2,tag3\n  --help                         Show this message and exit.\n</code></pre> <p>When executed, this command fetches tech-support files and downloads them locally into a device-specific subfolder within the designated folder. You can specify the output folder with the <code>--output</code> option.</p> <p>ANTA uses SCP to download files from devices; ensure that all SSH Host Keys are trusted before running the command. Use the <code>anta --insecure</code> option if they are not.</p> <p>The configuration <code>aaa authorization exec default local</code> must be enabled on devices for SCP to function. ANTA will not automatically configure this unless <code>--configure</code> is specified.</p> <p>The <code>--latest</code> option allows retrieval of a specific number of the most recent tech-support files.</p> <p>Warning</p> <p>By default all the tech-support files present on the devices are retrieved.</p>"},{"location":"cli/exec/#example_2","title":"Example","text":"<pre><code>anta --insecure exec collect-tech-support\n[15:27:19] INFO     Connecting to devices...\nINFO     Copying '/mnt/flash/schedule/tech-support/spine1_tech-support_2023-06-09.1315.log.gz' from device spine1 to 'tech-support/spine1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf3_tech-support_2023-06-09.1315.log.gz' from device leaf3 to 'tech-support/leaf3' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf1_tech-support_2023-06-09.1315.log.gz' from device leaf1 to 'tech-support/leaf1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf2_tech-support_2023-06-09.1315.log.gz' from device leaf2 to 'tech-support/leaf2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/spine2_tech-support_2023-06-09.1315.log.gz' from device spine2 to 'tech-support/spine2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf4_tech-support_2023-06-09.1315.log.gz' from device leaf4 to 'tech-support/leaf4' locally\nINFO     Collected 1 scheduled tech-support from leaf2\nINFO     Collected 1 scheduled tech-support from spine2\nINFO     Collected 1 scheduled tech-support from leaf3\nINFO     Collected 1 scheduled tech-support from spine1\nINFO     Collected 1 scheduled tech-support from leaf1\nINFO     Collected 1 scheduled tech-support from leaf4\n</code></pre> <p>The output folder structure is as follows:</p> <pre><code>tree tech-support/\ntech-support/\n\u251c\u2500\u2500 leaf1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf1_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf2\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf2_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf3\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf3_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf4\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf4_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 spine1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 spine1_tech-support_2023-06-09.1315.log.gz\n\u2514\u2500\u2500 spine2\n    \u2514\u2500\u2500 spine2_tech-support_2023-06-09.1315.log.gz\n\n6 directories, 6 files\n</code></pre> <p>Each device has its own subdirectory containing the collected tech-support files.</p>"},{"location":"cli/get-inventory-information/","title":"Get Inventory Information","text":""},{"location":"cli/get-inventory-information/#retrieving-inventory-information","title":"Retrieving Inventory Information","text":"<p>The ANTA CLI offers multiple entrypoints to access data from your local inventory.</p>"},{"location":"cli/get-inventory-information/#inventory-used-of-examples","title":"Inventory used of examples","text":"<p>Let\u2019s consider the following inventory:</p> <pre><code>---\nanta_inventory:\nhosts:\n- host: 172.20.20.101\nname: DC1-SPINE1\ntags: [\"SPINE\", \"DC1\"]\n\n- host: 172.20.20.102\nname: DC1-SPINE2\ntags: [\"SPINE\", \"DC1\"]\n\n- host: 172.20.20.111\nname: DC1-LEAF1A\ntags: [\"LEAF\", \"DC1\"]\n\n- host: 172.20.20.112\nname: DC1-LEAF1B\ntags: [\"LEAF\", \"DC1\"]\n\n- host: 172.20.20.121\nname: DC1-BL1\ntags: [\"BL\", \"DC1\"]\n\n- host: 172.20.20.122\nname: DC1-BL2\ntags: [\"BL\", \"DC1\"]\n\n- host: 172.20.20.201\nname: DC2-SPINE1\ntags: [\"SPINE\", \"DC2\"]\n\n- host: 172.20.20.202\nname: DC2-SPINE2\ntags: [\"SPINE\", \"DC2\"]\n\n- host: 172.20.20.211\nname: DC2-LEAF1A\ntags: [\"LEAF\", \"DC2\"]\n\n- host: 172.20.20.212\nname: DC2-LEAF1B\ntags: [\"LEAF\", \"DC2\"]\n\n- host: 172.20.20.221\nname: DC2-BL1\ntags: [\"BL\", \"DC2\"]\n\n- host: 172.20.20.222\nname: DC2-BL2\ntags: [\"BL\", \"DC2\"]\n</code></pre>"},{"location":"cli/get-inventory-information/#obtaining-all-configured-tags","title":"Obtaining all configured tags","text":"<p>As most of ANTA\u2019s commands accommodate tag filtering, this particular command is useful for enumerating all tags configured in the inventory. Running the <code>anta get tags</code> command will return a list of all tags that have been configured in the inventory.</p>"},{"location":"cli/get-inventory-information/#command-overview","title":"Command overview","text":"<pre><code>anta get tags --help\nUsage: anta get tags [OPTIONS]\n\nGet list of configured tags in user inventory.\n\nOptions:\n  --help  Show this message and exit.\n</code></pre>"},{"location":"cli/get-inventory-information/#example","title":"Example","text":"<p>To get the list of all configured tags in the inventory, run the following command:</p> <pre><code>anta get tags\nTags found:\n[\n\"BL\",\n  \"DC1\",\n  \"DC2\",\n  \"LEAF\",\n  \"SPINE\",\n  \"all\"\n]\n\n* note that tag all has been added by anta\n</code></pre> <p>Note</p> <p>Even if you haven\u2019t explicitly configured the <code>all</code> tag in the inventory, it is automatically added. This default tag allows to execute commands on all devices in the inventory when no tag is specified.</p>"},{"location":"cli/get-inventory-information/#list-devices-in-inventory","title":"List devices in inventory","text":"<p>This command will list all devices available in the inventory. Using the <code>--tags</code> option, you can filter this list to only include devices with specific tags. The <code>--connected</code> option allows to display only the devices where a connection has been established.</p>"},{"location":"cli/get-inventory-information/#command-overview_1","title":"Command overview","text":"<pre><code>anta get inventory --help\nUsage: anta get inventory [OPTIONS]\n\nShow inventory loaded in ANTA.\n\nOptions:\n  -t, --tags TEXT                List of tags using comma as separator:\n                                 tag1,tag2,tag3\n  --connected / --not-connected  Display inventory after connection has been\n                                 created\n  --help                         Show this message and exit.\n</code></pre> <p>Tip</p> <p>In its default mode, <code>anta get inventory</code> provides only information that doesn\u2019t rely on a device connection. If you are interested in obtaining connection-dependent details, like the hardware model, please use the <code>--connected</code> option.</p>"},{"location":"cli/get-inventory-information/#example_1","title":"Example","text":"<p>To retrieve a comprehensive list of all devices along with their details, execute the following command. It will provide all the data loaded into the ANTA inventory from your inventory file.</p> <pre><code>anta get inventory --tags SPINE\nCurrent inventory content is:\n{\n'DC1-SPINE1': AsyncEOSDevice(\nname='DC1-SPINE1',\n        tags=['SPINE', 'DC1', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.101',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    ),\n    'DC1-SPINE2': AsyncEOSDevice(\nname='DC1-SPINE2',\n        tags=['SPINE', 'DC1', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.102',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    ),\n    'DC2-SPINE1': AsyncEOSDevice(\nname='DC2-SPINE1',\n        tags=['SPINE', 'DC2', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.201',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    ),\n    'DC2-SPINE2': AsyncEOSDevice(\nname='DC2-SPINE2',\n        tags=['SPINE', 'DC2', 'all'],\n        hw_model=None,\n        is_online=False,\n        established=False,\n        host='172.20.20.202',\n        eapi_port=443,\n        username='arista',\n        password='arista',\n        enable=True,\n        enable_password='arista',\n        insecure=False\n    )\n}\n</code></pre>"},{"location":"cli/inv-from-ansible/","title":"Inventory from Ansible","text":""},{"location":"cli/inv-from-ansible/#create-an-inventory-from-ansible-inventory","title":"Create an Inventory from Ansible inventory","text":"<p>In large setups, it might be beneficial to construct your inventory based on your Ansible inventory. The <code>from-ansible</code> entrypoint of the <code>get</code> command enables the user to create an ANTA inventory from Ansible.</p>"},{"location":"cli/inv-from-ansible/#command-overview","title":"Command overview","text":"<pre><code>anta get from-ansible --help\nUsage: anta get from-ansible [OPTIONS]\n\nBuild ANTA inventory from an ansible inventory YAML file\n\nOptions:\n  -g, --ansible-group TEXT        Ansible group to filter\n  -i, --ansible-inventory FILENAME\n                                  Path to your ansible inventory file to read\n-o, --output FILENAME           Path to save inventory file\n  -d, --inventory-directory PATH  Directory to save inventory file\n  --help                          Show this message and exit.\n</code></pre> <p>The output is an inventory where the name of the container is added as a tag for each host:</p> <pre><code>anta_inventory:\nhosts:\n- host: 10.73.252.41\nname: srv-pod01\n- host: 10.73.252.42\nname: srv-pod02\n- host: 10.73.252.43\nname: srv-pod03\n</code></pre> <p>Warning</p> <p>The current implementation only considers devices directly attached to a specific Ansible group and does not support inheritence when using the <code>--ansible-group</code> option.</p> <p><code>host</code> value is coming from the <code>ansible_host</code> key in your inventory while <code>name</code> is the name you defined for your host. Below is an ansible inventory example used to generate previous inventory:</p> <pre><code>---\ntooling:\nchildren:\nendpoints:\nhosts:\nsrv-pod01:\nansible_httpapi_port: 9023\nansible_port: 9023\nansible_host: 10.73.252.41\ntype: endpoint\nsrv-pod02:\nansible_httpapi_port: 9024\nansible_port: 9024\nansible_host: 10.73.252.42\ntype: endpoint\nsrv-pod03:\nansible_httpapi_port: 9025\nansible_port: 9025\nansible_host: 10.73.252.43\ntype: endpoint\n</code></pre>"},{"location":"cli/inv-from-cvp/","title":"Inventory from CVP","text":""},{"location":"cli/inv-from-cvp/#create-an-inventory-from-cloudvision","title":"Create an Inventory from CloudVision","text":"<p>In large setups, it might be beneficial to construct your inventory based on CloudVision. The <code>from-cvp</code> entrypoint of the <code>get</code> command enables the user to create an ANTA inventory from CloudVision.</p>"},{"location":"cli/inv-from-cvp/#command-overview","title":"Command overview","text":"<pre><code>anta get from-cvp --help\nUsage: anta get from-cvp [OPTIONS]\n\nBuild ANTA inventory from Cloudvision\n\nOptions:\n  -ip, --cvp-ip TEXT              CVP IP Address  [required]\n-u, --cvp-username TEXT         CVP Username  [required]\n-p, --cvp-password TEXT         CVP Password / token  [required]\n-c, --cvp-container TEXT        Container where devices are configured\n  -d, --inventory-directory PATH  Path to save inventory file\n  --help                          Show this message and exit.\n</code></pre> <p>The output is an inventory where the name of the container is added as a tag for each host:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.13\nname: leaf2\ntags:\n- pod1\n- host: 192.168.0.15\nname: leaf4\ntags:\n- pod2\n</code></pre> <p>Warning</p> <p>The current implementation only considers devices directly attached to a specific container when using the <code>--cvp-container</code> option.</p>"},{"location":"cli/inv-from-cvp/#creating-an-inventory-from-multiple-containers","title":"Creating an inventory from multiple containers","text":"<p>If you need to create an inventory from multiple containers, you can use a bash command and then manually concatenate files to create a single inventory file:</p> <pre><code>$ for container in pod01 pod02 spines; do anta get from-cvp -ip &lt;cvp-ip&gt; -u cvpadmin -p cvpadmin -c $container -d test-inventory; done\n\n[12:25:35] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:36] INFO     Creating inventory folder /home/tom/Projects/arista/network-test-automation/test-inventory\n           WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:37] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:38] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:38] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:39] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n           INFO     Inventory file has been created in /home/tom/Projects/arista/network-test-automation/test-inventory/inventory-spines.yml\n</code></pre>"},{"location":"cli/nrfu/","title":"NRFU","text":""},{"location":"cli/nrfu/#execute-network-readiness-for-use-nrfu-testing","title":"Execute Network Readiness For Use (NRFU) Testing","text":"<p>ANTA provides a set of commands for performing NRFU tests on devices. These commands are under the <code>anta nrfu</code> namespace and offer multiple output format options:</p> <ul> <li>Text view</li> <li>Table view</li> <li>JSON view</li> <li>Custom template view</li> </ul>"},{"location":"cli/nrfu/#nrfu-command-overview","title":"NRFU Command overview","text":"<pre><code>anta nrfu --help\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  -c, --catalog FILE  Path to the tests catalog YAML file  [env var:\n                      ANTA_NRFU_CATALOG; required]\n--help              Show this message and exit.\n\nCommands:\n  json        ANTA command to check network state with JSON result\n  table       ANTA command to check network states with table result\n  text        ANTA command to check network states with text result\n  tpl-report  ANTA command to check network state with templated report\n</code></pre> <p>All commands under the <code>anta nrfu</code> namespace require a catalog yaml file specified with the <code>--catalog</code> option.</p>"},{"location":"cli/nrfu/#performing-nrfu-with-text-rendering","title":"Performing NRFU with text rendering","text":"<p>The <code>text</code> subcommand provides a straightforward text report for each test executed on all devices in your inventory.</p>"},{"location":"cli/nrfu/#command-overview","title":"Command overview","text":"<pre><code>anta nrfu text --help\nUsage: anta nrfu text [OPTIONS]\n\nANTA command to check network states with text result\n\nOptions:\n  -t, --tags TEXT    List of tags using comma as separator: tag1,tag2,tag3\n  -s, --search TEXT  Regular expression to search in both name and test\n--skip-error       Hide tests in errors due to connectivity issue\n  --help             Show this message and exit.\n</code></pre> <p>The <code>--tags</code> option allows to target specific devices in your inventory, while the <code>--search</code> option permits filtering based on a regular expression pattern in both the hostname and the test name.</p> <p>The <code>--skip-error</code> option can be used to exclude tests that failed due to connectivity issues or unsupported commands.</p>"},{"location":"cli/nrfu/#example","title":"Example","text":"<p><pre><code>anta nrfu text --tags LEAF --search DC1-LEAF1A\n</code></pre> </p>"},{"location":"cli/nrfu/#performing-nrfu-with-table-rendering","title":"Performing NRFU with table rendering","text":"<p>The <code>table</code> command under the <code>anta nrfu</code> namespace offers a clear and organized table view of the test results, suitable for filtering. It also has its own set of options for better control over the output.</p>"},{"location":"cli/nrfu/#command-overview_1","title":"Command overview","text":"<pre><code>anta nrfu table --help\nUsage: anta nrfu table [OPTIONS]\n\nANTA command to check network states with table result\n\nOptions:\n  --tags TEXT               List of tags using comma as separator:\n                            tag1,tag2,tag3\n  -d, --device TEXT         Show a summary for this device\n  -t, --test TEXT           Show a summary for this test\n--group-by [device|test]  Group result by test or host. default none\n  --help                    Show this message and exit.\n</code></pre> <p>The <code>--tags</code> option can be used to target specific devices in your inventory.</p> <p>The <code>--device</code> and <code>--test</code> options show a summarized view of the test results for a specific host or test case, respectively.</p> <p>The <code>--group-by</code> option show a summarized view of the test results per host or per test.</p>"},{"location":"cli/nrfu/#examples","title":"Examples","text":"<p><pre><code>anta nrfu table --tags LEAF\n</code></pre> </p> <p>For larger setups, you can also group the results by host or test to get a summarized view:</p> <p><pre><code>anta nrfu table --group-by device\n</code></pre> </p> <p><pre><code>anta nrfu table --group-by test\n</code></pre> </p> <p>To get more specific information, it is possible to filter on a single device or a single test:</p> <p><pre><code>anta nrfu table --device spine1\n</code></pre> </p> <p><pre><code>anta nrfu table --test VerifyZeroTouch\n</code></pre> </p>"},{"location":"cli/nrfu/#performing-nrfu-with-json-rendering","title":"Performing NRFU with JSON rendering","text":"<p>The JSON rendering command in NRFU testing is useful in generating a JSON output that can subsequently be passed on to another tool for reporting purposes.</p>"},{"location":"cli/nrfu/#command-overview_2","title":"Command overview","text":"<pre><code>anta nrfu json --help\nUsage: anta nrfu json [OPTIONS]\n\nANTA command to check network state with JSON result\n\nOptions:\n  -t, --tags TEXT    List of tags using comma as separator: tag1,tag2,tag3\n  -o, --output FILE  Path to save report as a file  [env var:\n                     ANTA_NRFU_JSON_OUTPUT]\n--help             Show this message and exit.\n</code></pre> <p>The <code>--tags</code> option can be used to target specific devices in your inventory.</p> <p>The <code>--output</code> option allows you to save the JSON report as a file.</p>"},{"location":"cli/nrfu/#example_1","title":"Example","text":"<p><pre><code>anta nrfu json --tags LEAF\n</code></pre> </p>"},{"location":"cli/nrfu/#performing-nrfu-with-custom-reports","title":"Performing NRFU with custom reports","text":"<p>ANTA offers a CLI option for creating custom reports. This leverages the Jinja2 template system, allowing you to tailor reports to your specific needs.</p>"},{"location":"cli/nrfu/#command-overview_3","title":"Command overview","text":"<p><pre><code>anta nrfu tpl-report --help\nUsage: anta nrfu tpl-report [OPTIONS]\n\nANTA command to check network state with templated report\n\nOptions:\n  -tpl, --template FILE  Path to the template to use for the report  [env var:\n                         ANTA_NRFU_TPL_REPORT_TEMPLATE; required]\n-o, --output FILE      Path to save report as a file  [env var:\n                         ANTA_NRFU_TPL_REPORT_OUTPUT]\n-t, --tags TEXT        List of tags using comma as separator: tag1,tag2,tag3\n  --help                 Show this message and exit.\n</code></pre> The <code>--template</code> option is used to specify the Jinja2 template file for generating the custom report.</p> <p>The <code>--output</code> option allows you to choose the path where the final report will be saved.</p> <p>The <code>--tags</code> option can be used to target specific devices in your inventory.</p>"},{"location":"cli/nrfu/#example_2","title":"Example","text":"<p><pre><code>anta nrfu tpl-report --tags LEAF --template ./custom_template.j2\n</code></pre> </p> <p>The template <code>./custom_template.j2</code> is a simple Jinja2 template:</p> <pre><code>{% for d in data %}\n* {{ d.test }} is [green]{{ d.result | upper}}[/green] for {{ d.name }}\n{% endfor %}\n</code></pre> <p>The Jinja2 template has access to all <code>TestResult</code> elements and their values, as described in this documentation.</p> <p>You can also save the report result to a file using the <code>--output</code> option:</p> <pre><code>anta nrfu tpl-report --tags LEAF --template ./custom_template.j2 --output nrfu-tpl-report.txt\n</code></pre> <p>The resulting output might look like this:</p> <pre><code>cat nrfu-tpl-report.txt\n* VerifyMlagStatus is [green]SUCCESS[/green] for DC1-LEAF1A\n* VerifyMlagInterfaces is [green]SUCCESS[/green] for DC1-LEAF1A\n* VerifyMlagConfigSanity is [green]SUCCESS[/green] for DC1-LEAF1A\n* VerifyMlagReloadDelay is [green]SUCCESS[/green] for DC1-LEAF1A\n</code></pre>"},{"location":"cli/overview/","title":"Overview","text":""},{"location":"cli/overview/#overview-of-antas-command-line-interface-cli","title":"Overview of ANTA\u2019s Command-Line Interface (CLI)","text":"<p>ANTA provides a powerful Command-Line Interface (CLI) to perform a wide range of operations. This document provides a comprehensive overview of ANTA CLI usage and its commands.</p> <p>ANTA can also be used as a Python library, allowing you to build your own tools based on it. Visit this page for more details.</p> <p>To start using the ANTA CLI, open your terminal and type <code>anta</code>.</p>"},{"location":"cli/overview/#invoking-anta-cli","title":"Invoking ANTA CLI","text":"<pre><code>$ anta --help\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test Automation (ANTA) CLI\n\nOptions:\n  --version                       Show the version and exit.\n  --username TEXT                 Username to connect to EOS  [env var:\n                                  ANTA_USERNAME; required]\n--password TEXT                 Password to connect to EOS  [env var:\n                                  ANTA_PASSWORD; required]\n--timeout INTEGER               Global connection timeout  [env var:\n                                  ANTA_TIMEOUT; default: 5]\n--insecure                      Disable SSH Host Key validation  [env var:\n                                  ANTA_INSECURE]\n--enable                        Add enable mode towards the devices if\nrequired to connect  [env var: ANTA_ENABLE]\n--enable-password TEXT          Enable password if required to connect,\n                                  --enable MUST be set  [env var:\n                                  ANTA_ENABLE_PASSWORD]\n-i, --inventory FILE            Path to the inventory YAML file  [env var:\n                                  ANTA_INVENTORY; required]\n--log-level, --log [CRITICAL|ERROR|WARNING|INFO|DEBUG]\nANTA logging level  [env var:\n                                  ANTA_LOG_LEVEL; default: INFO]\n--ignore-status                 Always exit with success  [env var:\n                                  ANTA_IGNORE_STATUS]\n--ignore-error                  Only report failures and not errors  [env\n                                  var: ANTA_IGNORE_ERROR]\n--help                          Show this message and exit.\n\nCommands:\n  debug  Debug commands for building ANTA\n  exec   Execute commands to inventory devices\n  get    Get data from/to ANTA\n  nrfu   Run NRFU against inventory devices\n</code></pre>"},{"location":"cli/overview/#anta-global-parameters","title":"ANTA Global Parameters","text":"<p>Certain parameters are globally required and can be either passed to the ANTA CLI or set as an environment variable (ENV VAR).</p> <p>To pass the parameters via the CLI:</p> <pre><code>anta --username tom --password arista123 --inventory inventory.yml &lt;anta cli&gt;\n</code></pre> <p>To set them as ENV VAR:</p> <pre><code>export ANTA_USERNAME=tom\nexport ANTA_PASSWORD=arista123\nexport ANTA_INVENTORY=inventory.yml\n</code></pre> <p>Then, run the CLI:</p> <pre><code>anta &lt;anta cli&gt;\n</code></pre>"},{"location":"cli/overview/#anta-exit-codes","title":"ANTA Exit Codes","text":"<p>ANTA utilizes different exit codes to indicate the status of the test runs.</p> <p>For all subcommands, ANTA will return the exit code 0, indicating a successful operation, except for the nrfu command.</p> <p>For the nrfu command, ANTA uses the following exit codes:</p> <ul> <li><code>Exit code 0</code> - All tests passed successfully.</li> <li><code>Exit code 1</code> - Tests were run, but at least one test returned a failure.</li> <li><code>Exit code 2</code> - Tests were run, but at least one test returned an error.</li> <li><code>Exit code 3</code> - An internal error occurred while executing tests.</li> </ul> <p>To ignore the test status, use <code>anta --ignore-status nrfu</code>, and the exit code will always be 0.</p> <p>To ignore errors, use <code>anta --ignore-error nrfu</code>, and the exit code will be 0 if all tests succeeded or 1 if any test failed.</p>"},{"location":"cli/overview/#shell-completion","title":"Shell Completion","text":"<p>You can enable shell completion for the ANTA CLI:</p> ZSHBASH <p>If you use ZSH shell, add the following line in your <code>~/.zshrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=zsh_source anta)\" &gt; /dev/null\n</code></pre> <p>With bash, add the following line in your <code>~/.bashrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=bash_source anta)\" &gt; /dev/null\n</code></pre>"}]}