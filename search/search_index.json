{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#anta-documentation","title":"ANTA Documentation","text":"<p>This website provides generic documentation related to the Arista Network Test Automation framework (ANTA)</p> <p></p>"},{"location":"#arista-network-test-automation-anta-framework","title":"Arista Network Test Automation (ANTA) Framework","text":"<p>This repository is a Python package to automate tests on Arista devices.</p> <ul> <li>The package name is ANTA, which stands for Arista Network Test Automation.</li> <li>This package provides a set of tests to validate the state of your network.</li> <li>This package can be imported in Python scripts:<ul> <li>To automate NRFU (Network Ready For Use) test on a preproduction network</li> <li>To automate tests on a live network (periodically or on demand)</li> </ul> </li> </ul> <p>This repository comes with a cli to run Arista Network Test Automation (ANTA) framework using your preferred shell:</p> <pre><code># Install ANTA\npip install anta\n\n# Run ANTA cli\n$ anta\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test CLI\n\nOptions:\n  --username TEXT         Username to connect to EOS  [env var: ANTA_USERNAME]\n--password TEXT         Password to connect to EOS  [env var: ANTA_PASSWORD]\n--timeout INTEGER       Connection timeout (default 5)  [env var: ANTA_TIMEOUT]\n--enable-password TEXT  Enable password if required to connect  [env var: ANTA_ENABLE_PASSWORD]\n-i, --inventory PATH    Path to your inventory file  [env var: ANTA_INVENTORY]\n--timeout INTEGER       Connection timeout (default 5)  [env var: ANTA_TIMEOUT]\n--help                  Show this message and exit.\n\nCommands:\n  exec  Execute commands to inventory devices\n  get   Get data from/to ANTA\n  nrfu  Run NRFU against inventory devices\n</code></pre>"},{"location":"contribution/","title":"Contributions","text":""},{"location":"contribution/#how-to-contribute-to-anta","title":"How to contribute to ANTA","text":"<p>Contribution model is based on a fork-model. Don\u2019t push to arista-netdevops-community/anta directly. Always do a branch in your repository and create a PR.</p> <p>To help development, open your PR as soon as possible even in draft mode. It helps other to know on what you are working on and avoid duplicate PRs.</p>"},{"location":"contribution/#install-repository","title":"Install repository","text":"<p>Run these commands to install:</p> <ul> <li>The package ANTA and its dependencies</li> <li>ANTA cli executable.</li> </ul> <pre><code># Clone repository\ngit clone https://github.com/arista-netdevops-community/anta.git\ncd network-test-automation\n\n# Install module in editable mode\npip install -e .\n</code></pre> <p>Run these commands to verify:</p> <pre><code># Check python installation\n$ pip list\n\n# Check version using cli\n$ anta --version\nanta, version 0.5.0\n</code></pre>"},{"location":"contribution/#install-development-requirements","title":"Install development requirements","text":"<p>Run pip to install anta and its developement tools.</p> <pre><code>pip install 'anta[dev]'\n</code></pre> <p>This command has to be done after you install repository with commands provided in previous section.</p> <p>Then, tox is configued with few environment to run CI locally:</p> <pre><code>tox list\ndefault environments:\nclean  -&gt; run the test driver with /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/bin/python3.9\npy38   -&gt; run the test driver with py38\npy39   -&gt; run the test driver with py39\npy310  -&gt; run the test driver with py310\nlint   -&gt; check the code style\ntype   -&gt; check typing\nreport -&gt; run the test driver with /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/bin/python3.9\n\nadditional environments:\n3.8    -&gt; run the test driver with 3.8\n3.9    -&gt; run the test driver with 3.9\n3.10   -&gt; run the test driver with 3.10\n</code></pre>"},{"location":"contribution/#code-linting","title":"Code linting","text":"<pre><code>tox -e lint\n[...]\nlint: commands[0]&gt; flake8 --max-line-length=165 --config=/dev/null anta\nlint: commands[1]&gt; flake8 --max-line-length=165 --config=/dev/null scripts\nlint: commands[2]&gt; flake8 --max-line-length=165 --config=/dev/null tests\nlint: commands[3]&gt; pylint anta\n\n--------------------------------------------------------------------\nYour code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)\n\nlint: commands[4]&gt; pylint scripts\n\n-------------------------------------------------------------------\nYour code has been rated at 10.00/10 (previous run: 7.15/10, +2.85)\n\n.pkg: _exit&gt; python /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/lib/python3.9/site-packages/\\\npyproject_api/_backend.py True setuptools.build_meta\n  lint: OK (28.37=setup[7.03]+cmd[0.38,0.23,0.25,11.07,9.41] seconds)\ncongratulations :) (28.45 seconds)\n</code></pre>"},{"location":"contribution/#code-typing","title":"Code Typing","text":"<pre><code>tox -e type\n\ntype: commands[0]&gt; mypy --config-file=pyproject.toml anta\nSuccess: no issues found in 38 source files\ntype: commands[1]&gt; mypy --config-file=pyproject.toml scripts\nSuccess: no issues found in 6 source files\n.pkg: _exit&gt; python /home/tom/.pyenv/versions/3.9.9/envs/arista-anta/lib/python3.9/site-packages/\\\npyproject_api/_backend.py True setuptools.build_meta\n  type: OK (28.80=setup[24.54]+cmd[3.35,0.90] seconds)\ncongratulations :) (28.89 seconds)\n</code></pre>"},{"location":"contribution/#unit-tests","title":"Unit tests","text":"<p>To keep high quality code, we require to provide a Pytest for every tests implemented in ANTA.</p> <p>All submodule should have its own pytest section under <code>tests/units/anta_tests/&lt;submodule-name&gt;</code>. In this directory, you should have 3 files:</p> <ul> <li><code>__init__.py</code>: Just because it is used as a python module</li> <li><code>data.py</code>: Where all your parametrize go. So all your test information should be located here</li> <li><code>test_exc.py</code>: Pytest file with test definition.</li> </ul> <p>A pytest definition should be similar to this template:</p> <pre><code># -*- coding: utf-8 -*-\n\n\"\"\"\nTests for anta.tests.hardware.py\n\"\"\"\nfrom __future__ import annotations\n\nimport asyncio\nimport logging\nfrom typing import Any\nfrom unittest.mock import MagicMock\n\nimport pytest\n\nfrom anta.tests.hardware import VerifyAdverseDrops\nfrom tests.lib.utils import generate_test_ids_list\n\nfrom .data import INPUT_&lt;TEST_NAME&gt;\n\n@pytest.mark.parametrize(\"test_data\", INPUT_&lt;TEST_NAME&gt;, ids=generate_test_ids_list(INPUT_&lt;TEST_NAME&gt;))\ndef test_&lt;TEST_CASE&gt;(mocked_device: MagicMock, test_data: Any) -&gt; None:\n\"\"\"Check &lt;TEST_CASE&gt;.\"\"\"\n\n    logging.info(f\"Mocked device is: {mocked_device.host}\")\n    logging.info(f\"Mocked HW is: {mocked_device.hw_model}\")\n\n    test = &lt;TEST_CASE&gt;(mocked_device, eos_data=test_data[\"eos_data\"])\n    asyncio.run(test.test())\n\n    logging.debug(f\"test result is: {test.result}\")\n\n    assert str(test.result.name) == mocked_device.name\n    assert test.result.result == test_data[\"expected_result\"]\n</code></pre> <p>The <code>mocked_device</code> object is a fixture defined in Pytest to represent an InventoryDevice and the parametrize <code>test_data</code> is a list of dictionries with structure:</p> <pre><code>INPUT_RUNNING_CONFIG: List[Dict[str, Any]] = [\n  # Test Case #1\n    {\n        \"name\": \"failure\",\n        \"eos_data\": [\"blah blah\"],\n        \"side_effect\": None,\n        \"expected_result\": \"failure\",\n        \"expected_messages\": [\"blah blah\"]\n    },\n    # Test Case #2\n    {\n      ...\n    },\n]\n</code></pre> <p>Where we have:</p> <ul> <li><code>name</code>: Name of the test displayed by Pytest</li> <li><code>eos_data</code>: a list of data coming from EOS.</li> <li><code>side_effect</code>: defined for futur use.</li> <li><code>expected_result</code>: Result we expect for this test</li> <li><code>expected_messages</code>: Optional messages we expect for the test.</li> </ul> <p>Use Anta CLI to get test data</p> <p>To complete this block, you can use <code>anta debug</code> commands to get <code>AntaTestCommand</code> output to use in your test.</p>"},{"location":"contribution/#git-pre-commit-hook","title":"Git Pre-commit hook","text":"<pre><code>pip install pre-commit\npre-commit install\n</code></pre> <p>When running a commit or a pre-commit check:</p> <pre><code>\u276f echo \"import foobaz\" &gt; test.py &amp;&amp; git add test.py\n\u276f pre-commit\npylint...................................................................Failed\n- hook id: pylint\n- exit code: 22\n\n************* Module test\ntest.py:1:0: C0114: Missing module docstring (missing-module-docstring)\ntest.py:1:0: E0401: Unable to import 'foobaz' (import-error)\ntest.py:1:0: W0611: Unused import foobaz (unused-import)\n</code></pre>"},{"location":"contribution/#test-your-documentation","title":"Test your documentation","text":"<p>Writing documentation is crucial but managing links can be cumbersome. To be sure there is no 404, you can use <code>muffet</code> with this cli:</p> <pre><code>muffet -c 2 --color=always http://127.0.0.1:8000 -e fonts.gstatic.com\n</code></pre>"},{"location":"contribution/#continuous-integration","title":"Continuous Integration","text":"<p>GitHub actions is used to test git pushes and pull requests. The workflows are defined in this directory. We can view the result here</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#getting-started","title":"Getting Started","text":"<p>This section shows how to use ANTA with basic configuration. All examples are based on Arista Test Drive (ATD) topology you can access by reaching out to your prefered SE.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>The easiest way to intall ANTA package is to run Python (<code>&gt;=3.8</code>) and its pip package to install:</p> <pre><code>pip install anta\n</code></pre> <p>For more details about how to install package, please see the requirements and intallation section.</p>"},{"location":"getting-started/#configure-arista-eos-devices","title":"Configure Arista EOS devices","text":"<p>First, you need to configure your management interface</p> <pre><code>vrf instance MGMT\n!\ninterface Management0\n   description oob_management\n   vrf MGMT\n   ip address 192.168.0.10/24\n!\n</code></pre> <p>Then, configure access to eAPI:</p> <pre><code>!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n   !\n!\n</code></pre>"},{"location":"getting-started/#create-your-inventory","title":"Create your inventory","text":"<p>First, we need to list devices we want to test. You can create a file manually with this format:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>You can read more details about how to build your inventory here</p>"},{"location":"getting-started/#test-catalog","title":"Test Catalog","text":"<p>To test your network, it is important to define a test catalog to list all the tests to run against your inventory. Test catalog references python functions into a yaml file. This file can be loaded by anta.loader.py</p> <p>The structure to follow is like:</p> <pre><code>&lt;anta_tests_submodule&gt;:\n- &lt;anta_tests_submodule function name&gt;:\n&lt;test function option&gt;:\n&lt;test function option value&gt;\n</code></pre> <p>You can read more details about how to build your catalog here</p> <p>Here is an example for basic things:</p> <pre><code># Load anta.tests.software\nanta.tests.software:\n- VerifyEosVersion: # Verifies the device is running one of the allowed EOS version.\nversions: # List of allowed EOS versions.\n- 4.25.4M\n- 4.26.1F\n- '4.28.3M-28837868.4283M (engineering build)'\n- VerifyTerminAttrVersion:\nversions:\n- v1.22.1\n\nanta.tests.system:\n- VerifyUptime: # Verifies the device uptime is higher than a value.\nminimum: 1\n- VerifyNtp:\n- VerifySyslog:\n\nanta.tests.mlag:\n- VerifyMlagStatus:\n- VerifyMlagInterface:\n- VerifyMlagConfigSanity:\n\nanta.tests.configuration:\n- VerifyZeroTouch: # Verifies ZeroTouch is disabled.\n- VerifyRunningConfigDiffs:\n</code></pre>"},{"location":"getting-started/#test-your-network","title":"Test your network","text":"<p>To test EOS devices, this package comes with a generic CLI entrypoint to run tests in your network. It requires an inventory file as well as a test catalog.</p> <p>This entrypoint has multiple options to manage test coverage and reporting.</p> <pre><code># Generic ANTA options\n$ anta\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test CLI\n\nOptions:\n  --version               Show the version and exit.\n  --username TEXT         Username to connect to EOS  [env var: ANTA_USERNAME;\nrequired]\n--password TEXT         Password to connect to EOS  [env var: ANTA_PASSWORD;\nrequired]\n--timeout INTEGER       Connection timeout (default 5)  [env var:\n                          ANTA_TIMEOUT]\n--enable-password TEXT  Enable password if required to connect  [env var:\n                          ANTA_ENABLE_PASSWORD]\n-i, --inventory PATH    Path to your inventory file  [env var:\n                          ANTA_INVENTORY; required]\n--help                  Show this message and exit.\n\nCommands:\n  exec  Execute commands to inventory devices\n  get   Get data from/to ANTA\n  nrfu  Run NRFU against inventory devices\n\n\n\n# NRFU part of ANTA\n$ anta nrfu\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  json   ANTA command to check network state with JSON result\n  table  ANTA command to check network states with table result\n  text   ANTA command to check network states with text result\n</code></pre> <p>Default output is a table format listing all test results, and it can be changed to a report per test case or per host</p>"},{"location":"getting-started/#default-report-using-table","title":"Default report using table","text":"<pre><code>anta \\\n--username tom \\\n--password arista123 \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu table --tags leaf --catalog .personal/tests-bases.yml\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running check-devices with:                              \u2502\n\u2502               - Inventory: .personal/inventory_atd.yml   \u2502\n\u2502               - Tests catalog: .personal/tests-bases.yml \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n                                                                            All tests results\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Device IP \u2503 Test Name                          \u2503 Test Status \u2503 Message(s)                                                     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 leaf01    \u2502 VerifyEosVersion                   \u2502 success     \u2502                                                                \u2502\n\u2502 leaf01    \u2502 VerifyTerminAttrVersion            \u2502 success     \u2502                                                                \u2502\n\u2502 leaf01    \u2502 VerifyUptime                       \u2502 success     \u2502                                                                \u2502\n\u2502 leaf01    \u2502 VerifyNtp                          \u2502 failure     \u2502 not sync with NTP server (NTP is disabled.)                    \u2502\n\u2502 leaf01    \u2502 VerifySyslog                       \u2502 failure     \u2502 Device has some log messages with a severity WARNING or higher \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/#report-in-text-mode","title":"Report in text mode","text":"<pre><code>$ anta \\\n    --username tom \\\n    --password arista123 \\\n    --enable-password t \\\n    --inventory .personal/inventory_atd.yml \\\n    nrfu text --tags leaf --catalog .personal/tests-bases.yml\n\nleaf01 :: VerifyEosVersion :: SUCCESS\nleaf01 :: VerifyTerminAttrVersion :: SUCCESS\nleaf01 :: VerifyUptime :: SUCCESS\nleaf01 :: VerifyNtp :: FAILURE (not sync with NTP server (NTP is disabled.))\nleaf01 :: VerifySyslog :: FAILURE (Device has some log messages with a severity WARNING or higher)\n...\n</code></pre>"},{"location":"getting-started/#report-per-host","title":"Report per host","text":"<pre><code>$ anta \\\n--username tom \\\n--password arista123 \\\n--enable-password t \\\n--inventory .personal/inventory_atd.yml \\\nnrfu json --tags leaf --catalog .personal/tests-bases.yml\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 JSON results of all tests                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[\n{\n\"name\": \"leaf01\",\n    \"test\": \"VerifyEosVersion\",\n    \"result\": \"success\",\n    \"messages\": \"[]\"\n},\n  {\n\"name\": \"leaf01\",\n    \"test\": \"VerifyTerminAttrVersion\",\n    \"result\": \"success\",\n    \"messages\": \"[]\"\n},\n...\n]\n</code></pre> <p>You can find more information under the usage section of the website</p>"},{"location":"requirements-and-installation/","title":"Installation","text":""},{"location":"requirements-and-installation/#anta-requirements","title":"ANTA Requirements","text":""},{"location":"requirements-and-installation/#python-version","title":"Python version","text":"<p>Python 3 (<code>&gt;=3.8</code> and <code>=&lt;3.10</code>) is required:</p> <pre><code>python --version\nPython 3.9.9\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-package","title":"Install ANTA package","text":"<p>This installation will deploy tests collection, scripts and all their Python requirements.</p> <p>The ANTA package and the cli require some packages that are not part of the Python standard library. They are indicated in the pyproject.toml file</p>"},{"location":"requirements-and-installation/#install-from-pypi-server","title":"Install from Pypi server","text":"<pre><code>pip install anta\n</code></pre>"},{"location":"requirements-and-installation/#install-anta-from-github","title":"Install ANTA from github","text":"<pre><code>pip install git+https://github.com/arista-netdevops-community/anta.git\n</code></pre> <p>You can even specify the branch, tag or commit:</p> <ul> <li><code>&lt;anta-repository&gt;@&lt;cool-feature-branch&gt;</code></li> <li><code>&lt;anta-repository&gt;@&lt;cool-tag&gt;</code></li> <li><code>&lt;anta-repository&gt;@&lt;cool-hash&gt;</code></li> </ul>"},{"location":"requirements-and-installation/#check-installation","title":"Check installation","text":"<p>Run these commands to verify:</p> <pre><code># Check ANTA has been installed in your python path\npip list | grep anta\n\n# Check scripts are in your $PATH\n# Path may differ but it means CLI is in your path\nwhich anta\n/home/tom/.pyenv/shims/anta\n\n# Chck ANTA version\nanta --version\nanta, version 0.5.0\n</code></pre>"},{"location":"requirements-and-installation/#eos-requirements","title":"EOS Requirements","text":"<p>To get ANTA working, your Arista EOS devices must have the following configuration (assuming you connect to the device using Management interface in MGMT VRF):</p> <pre><code>configure\n!\nvrf instance MGMT\n!\ninterface Management1\n   description oob_management\n   vrf MGMT\n   ip address 10.73.1.105/24\n!\nend\n</code></pre> <p>Enable eAPI on the MGMT vrf:</p> <pre><code>configure\n!\nmanagement api http-commands\n   protocol https port 443\n   no shutdown\n   vrf MGMT\n      no shutdown\n!\nend\n</code></pre> <p>Now the swicth accepts on port 443 in the MGMT VRF HTTPS requests containing a list of CLI commands.</p> <p>Run these EOS commands to verify:</p> <pre><code>show management http-server\nshow management api http-commands\n</code></pre>"},{"location":"usage-inventory-catalog/","title":"Inventory & Tests catalog","text":""},{"location":"usage-inventory-catalog/#inventory-catalog-definition","title":"Inventory &amp; Catalog definition","text":"<p>This page describes how to create an inventory and a tests catalog.</p>"},{"location":"usage-inventory-catalog/#create-an-inventory-file","title":"Create an inventory file","text":"<p><code>anta</code> cli needs an inventory file to list all devices to tests. This inventory is a YAML file with the folowing keys:</p> <pre><code>anta_inventory:\nhosts:\n- host: &lt; ip address value &gt;\nport: &lt; TCP port for eAPI. Default is 443 (Optional)&gt;\nname: &lt; name to display in report. Default is host:port (Optional) &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nnetworks:\n- network: &lt; network using CIDR notation &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\nranges:\n- start: &lt; first ip address value of the range &gt;\nend: &lt; last ip address value of the range &gt;\ntags: &lt; list of tags to use to filter inventory during tests. Default is ['all']. (Optional) &gt;\n</code></pre> <p>Your inventory file can be based on any of these 3 keys and shall start with <code>anta_inventory</code> key. A full description of inventory model is available in API documentation</p> <p>The next output is an inventory example:</p> <pre><code>---\nanta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\nnetworks:\n- network: '192.168.110.0/24'\ntags: ['fabric', 'leaf']\nranges:\n- start: 10.0.0.9\nend: 10.0.0.11\ntags: ['fabric', 'l2leaf']\n</code></pre>"},{"location":"usage-inventory-catalog/#test-catalog","title":"Test Catalog","text":"<p>In addition to your inventory file, you also have to define a catalog of tests to execute against all your devices. This catalogue list all your tests and their parameters.</p> <p>Its format is a YAML file and keys are tests functions inherited from the python path. Let\u2019s take an example below:</p>"},{"location":"usage-inventory-catalog/#default-tests-catalog","title":"Default tests catalog","text":"<p>All tests are located under <code>anta.tests</code> module and are categorised per family (one submodule). So to run test for software version, you can do:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n</code></pre> <p>It will load the test <code>VerifyEosVersion</code> located in <code>anta.tests.software</code>. But since this function has parameters, we will create a catalog with the following structure:</p> <pre><code>anta.tests.software:\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n</code></pre> <p>To get a list of all available tests and their respective parameters, you can read the tests section of this website.</p> <p>The following example gives a very minimal tests catalog you can use in almost any situation</p> <pre><code>---\n# Load anta.tests.software\nanta.tests.software:\n# Verifies the device is running one of the allowed EOS version.\n- VerifyEosVersion:\n# List of allowed EOS versions.\nversions:\n- 4.25.4M\n- 4.26.1F\n\n# Load anta.tests.system\nanta.tests.system:\n# Verifies the device uptime is higher than a value.\n- VerifyUptime:\nminimum: 1\n\n# Load anta.tests.configuration\nanta.tests.configuration:\n# Verifies ZeroTouch is disabled.\n- VerifyZeroTouch:\n- VerifyRunningConfigDiffs:\n</code></pre> <p>If your test is based on <code>AntaTestTemplate</code>, you have to provide inputs for EOS CLI template by using <code>tpl_options</code> list:</p> <pre><code>anta.tests.routing.bgp:\n- VerifyBGPIPv4UnicastCount:\nnumber: 3\ntemplate_params:\n- vrf: default\n- vrf: customer-01\n</code></pre> <p>Which is required for the following test definition:</p> <pre><code>class VerifyBGPIPv4UnicastCount(AntaTest):\n\"\"\"\n    ...\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastCount\"\n    description = \"...\"\n    categories = [\"routing\", \"bgp\"]\n    template = AntaTestTemplate(template=\"show bgp ipv4 unicast summary vrf {vrf}\")\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n        pass\n</code></pre>"},{"location":"usage-inventory-catalog/#custom-tests-catalog","title":"Custom tests catalog","text":"<p>In case you want to leverage your own tests collection, you can use the following syntax:</p> <pre><code>&lt;your package name&gt;:\n- &lt;your test in your package name&gt;:\n</code></pre> <p>So for instance, it could be:</p> <pre><code>titom73.tests.system:\n- VerifyPlatform:\ntype: ['cEOS-LAB']\n</code></pre> <p>How to create custom tests</p> <p>To create your custom tests, you should refer to this following documentation</p>"},{"location":"advanced_usages/as-python-lib/","title":"ANTA as python lib","text":""},{"location":"advanced_usages/as-python-lib/#how-to-use-anta-as-a-python-library","title":"How to use ANTA as a Python Library","text":"<p>ANTA has been built to allow user to embeded its tools in your own application. This section describes how you can leverage ANTA modules to help you create your own NRFU solution.</p>"},{"location":"advanced_usages/as-python-lib/#inventory-manager","title":"Inventory Manager","text":"<p>Inventory class is in charge of creating a list of hosts with their information and an eAPI session ready to be consummed. To do that, it connects to all devices to check reachability and ensure eAPI is running.</p> <pre><code>from anta.inventory import AntaInventory\n\ninventory = AntaInventory(\n    inventory_file=\"inventory.yml\",\n    username=\"username\",\n    password=\"password\",\n    enable_password=\"enable\",\n    auto_connect=True,\n    timeout=1,\n)\n</code></pre> <p>Then it is easy to get all devices or only active devices with the following method:</p> <pre><code># print the non reachable devices\nfor device in inventory.get_inventory(established_only=False):\n    if device.established is False:\n        print(f\"Could not connect to device {device.host}\")\n\n# run an EOS commands list on the reachable devices from the inventory\nfor device in inventory.get_inventory(established_only=True):\n    device.session.runCmds(\n        1, [\"show version\", \"show ip bgp summary\"]\n    )\n</code></pre> <p>You can find data model for anta.inventory.AntaInventory in the auto-generated documentation.</p> How to create your inventory file <p>Please visit this dedicated section for how to use inventory and catalog files.</p>"},{"location":"advanced_usages/as-python-lib/#use-tests-from-anta","title":"Use tests from ANTA","text":"<p>All the test functions are based on the exact same input and returns a generic structure with different information.</p>"},{"location":"advanced_usages/as-python-lib/#test-input","title":"Test input","text":"<p>Any test input is based on an <code>InventoryDevice</code> object and a list of options. Here is an example to check uptime and check it is higher than <code>minimum</code> option.</p> <pre><code>def verify_uptime(device: InventoryDevice, minimum: int = None) -&gt; TestResult:\n</code></pre> <p>In general, <code>InventoryDevice</code> is an object created by <code>AntaInventory</code>. But it can be manually generated by following required data model.</p> <p>Here is an example of a list of <code>InventoryDevice</code></p> <pre><code>[\n    {\n        \"InventoryDevice(host=IPv4Address('192.168.0.17')\",\n        \"username='ansible'\",\n        \"password='ansible'\",\n        \"session=&lt;ServerProxy for ansible:ansible@192.168.0.17/command-api&gt;\",\n        \"url='https://ansible:ansible@192.168.0.17/command-api'\",\n        \"established=True\",\n        \"is_online=True\",\n        \"hw_model=cEOS-LAB\",\n    },\n\n    {\n        \"InventoryDevice(host=IPv4Address('192.168.0.2')\",\n        \"username='ansible'\",\n        \"password='ansible'\",\n        \"session=None\",\n        \"url='https://ansible:ansible@192.168.0.2/command-api'\",\n        \"established=False\"\n        \"is_online=False\",\n        \"tags\": ['dc1', 'spine', 'pod01'],\n        \"hw_model=unset\",\n    }\n]\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#test-output","title":"Test output","text":"<p>All tests return a TestResult structure with the following elements:</p> <ul> <li><code>result</code>: Can be <code>success</code>, <code>skipped</code>, <code>failure</code>, <code>error</code> and report result of the test</li> <li><code>host</code>: IP address of the tested device</li> <li><code>test</code>: Test name runs on <code>host</code></li> <li><code>message</code>: Optional message returned by the test.</li> </ul>"},{"location":"advanced_usages/as-python-lib/#test-structure","title":"Test structure","text":"<p>All tests are built on a class named <code>AntaTest</code> which provides a complete toolset for a test:</p> <ul> <li>Object creation</li> <li>Test definition</li> <li>TestResult definition</li> <li>Abstracted method to collect data</li> </ul> <p>This approach means each time you create a test it will be based on this <code>AntaTest</code> class. Besides that, you will have to provide some elements:</p> <ul> <li><code>name</code>: Name of the test</li> <li><code>description</code>: A human readable description of your test</li> <li><code>categories</code>: a list of categories to sort test.</li> <li><code>commands</code>: a list of command to run. This list must be a list of <code>AntaTestCommand</code> which is described in the next part of this document.</li> </ul> <p>Here is an example of a hardware test related to device temperature:</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaTestCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre> <p>When you run the test, object will automatically call its <code>anta.models.AntaTest.collect()</code> method to get device output. This method does a loop to call <code>anta.inventory.models.InventoryDevice.collect()</code> methods which is in charge of managing device connection and how to get data.</p> run test offline <p>You can also pass eos data directly to your test if you want to validate data collected in a different workflow. An example is provided below just for information:</p> <pre><code>test = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\n</code></pre> <p>test function is always the same and must be defined with the <code>@AntaTest.anta_test</code> decorator. This function takes at least one argument which is a <code>anta.inventory.models.InventoryDevice</code> object and can have multiple additional parameters depending of your test definition. All parameters must come with a default value and the test function should validate the parameters values.</p> <pre><code>class VerifyTemperature(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n\nclass VerifyTransceiversManufacturers(AntaTest):\n    ...\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n        pass\n</code></pre> <p>The test itself does not return any value, but the result is directly availble from your object and exposes a <code>anta.result_manager.models.TestResult</code> object with result, name of the test and optional messages.</p> <pre><code>from anta.tests.hardware import VerifyTemperature\n\ntest = VerifyTemperature(mocked_device, eos_data=test_data[\"eos_data\"])\nasyncio.run(test.test())\nassert test.result.result == \"success\"\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#commands-for-test","title":"Commands for test","text":"<p>To make it easier to get data, ANTA defines 2 different classes to manage commands to send to device:</p>"},{"location":"advanced_usages/as-python-lib/#antamodelsantatestcommand","title":"<code>anta.models.AntaTestCommand</code>","text":"<p>Abstract a command with following information:</p> <ul> <li>Command to run,</li> <li>Ouput format expected</li> <li>eAPI version</li> <li>Output of the command</li> </ul> <p>Usage example:</p> <pre><code>from anta.models import AntaTestCommand\n\ncmd1 = AntaTestCommand(command=\"show zerotouch\")\ncmd2 = AntaTestCommand(command=\"show running-config diffs\", ofmt=\"text\")\n</code></pre>"},{"location":"advanced_usages/as-python-lib/#antamodelsantatesttemplate","title":"<code>anta.models.AntaTestTemplate</code>","text":"<p>Because some command can require more dynamic than just a command with no parameter provided by user, ANTA supports command template: you define a template in your test class and user provide parameters when creating test object.</p> <pre><code>class RunArbitraryTemplateCommand(AntaTest):\n\"\"\"\n    Run an EOS command and return result\n    Based on AntaTest to build relevant output for pytest\n    \"\"\"\n\n    name = \"Run aributrary EOS command\"\n    description = \"To be used only with anta debug commands\"\n    template = AntaTestTemplate(template=\"show interfaces {ifd}\")\n    categories = [\"debug\"]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        errdisabled_interfaces = [interface for interface, value in response[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n        ...\n\n\nparams = [{\"ifd\": \"Ethernet2\"}, {\"ifd\": \"Ethernet49/1\"}]\nrun_command1 = RunArbitraryTemplateCommand(device_anta, params)\n</code></pre> <p>In this example, test waits for interfaces to check from user setup and will only check for interfaces in <code>params</code></p>"},{"location":"advanced_usages/custom-tests/","title":"Create your own Library","text":""},{"location":"advanced_usages/custom-tests/#create-your-own-custom-tests","title":"Create your own custom tests","text":"<p>This documentation applies for both create tests in ANTA package or your custom package.</p> <p>ANTA is not only a CLI with a collection of built-in tests, it is also a framework you can extend by building your own tests library.</p> <p>For that, you need to create your own Python package as described in this hitchhiker\u2019s guide to package Python code. We assume it is well known and we won\u2019t focus on this aspect. Thus, your package must be impartable by ANTA hence available in <code>$PYTHONPATH</code> by any method.</p>"},{"location":"advanced_usages/custom-tests/#generic-approach","title":"Generic approach","text":"<p>ANTA comes with a class to use to build test. This class provides all the toolset required to define, collect and test data. The next code is an example of how to use ANTA to build a test</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaTestCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"advanced_usages/custom-tests/#python-imports","title":"Python imports","text":""},{"location":"advanced_usages/custom-tests/#mandatory-imports","title":"Mandatory imports","text":"<p>The following elements have to be imported:</p> <ul> <li><code>InventoryDevice</code>: Where the eAPI session lives. It is used to send commands over HTTP/HTTPS define in your test.</li> <li><code>anta.models.AntaTest</code>: class that gives you all the tooling for your test</li> <li><code>anta.models.AntaTestCommand</code>: A class to abstract an Arista EOS command</li> </ul> <pre><code>from anta.models import AntaTest, AntaTestCommand\n\n\nclass VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK.\n    \"\"\"\n    ...\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#optional-anta-imports","title":"Optional ANTA imports","text":"<p>Besides these 3 main imports, anta provides some additional and optional decorators:</p> <ul> <li><code>anta.test.skip_on_platforms</code>: To skip a test for a function not available for some platform</li> <li><code>anta.tests.check_bgp_family_enable</code>: To run tests only if specific BGP family is active.</li> </ul> <pre><code>from anta.decorators import skip_on_platforms\n\n\nclass VerifyTransceiversManufacturers(AntaTest):\n    ...\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#optional-python-imports","title":"Optional python imports","text":"<p>And finally, you are free to import any other python library you may want to use in your package.</p> <p>logging function</p> <p>It is strongly recommended to import <code>logging</code> to help development process and being able to log some outputs usefull for test development.</p> <p>If your test development is part of a pull request for ANTA, it is stringly advised to also import <code>typing</code> since our code testing requires to be compatible with Mypy.</p>"},{"location":"advanced_usages/custom-tests/#code-for-a-test","title":"Code for a test","text":"<p>A test is a python class where a test function is defined and will be run by the framework. So first you need to declare your class and then define your test function.</p>"},{"location":"advanced_usages/custom-tests/#create-test-class","title":"Create Test Class","text":"<p>To create class, you have to provide 4 elements:</p> <p>Metadata information</p> <ul> <li><code>name</code>: Name of the test</li> <li><code>description</code>: A human readable description of your test</li> <li><code>categories</code>: a list of categories to sort test.</li> </ul> <p>Commands to run</p> <ul> <li><code>commands</code>: a list of command to run. This list must be a list of <code>AntaTestCommand</code> which is described in the next part of this document.</li> <li><code>template</code>: a command template (<code>AntaTestTemplate</code>) to run where variables are provided during test execution.</li> </ul> <p>It is either <code>commands</code> or <code>template</code>. But not both.</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any, Dict, List, Optional, cast\n\nfrom anta.models import AntaTest, AntaTestCommand\n\n\nclass &lt;YourTestName&gt;(AntaTest):\n\"\"\"\n    &lt;a docstring description of your test&gt;\n    \"\"\"\n\n    name = \"YourTestName\"                                           # should be your class name\n    description = \"&lt;test description in human reading format&gt;\"\n    categories = [\"&lt;a list of arbitrary categories&gt;\"]\n    commands = [\n        AntaTestCommand(\n            command=\"&lt;eos command to run&gt;\",\n            ofmt=\"&lt;command format output&gt;\",\n            version=\"&lt;eapi version to use&gt;\"\n        )\n    ]\n</code></pre> <p>This class will inherit methods from AntaTest and specfically the <code>__init__(self,...)</code> method to build your object. This function takes following arguments when you instantiate an object:</p> <ul> <li><code>device (InventoryDevice)</code>: Device object where to test happens.</li> <li><code>template_params</code>: If template is used in the test definition, then we provide data to build list of commands.</li> <li><code>eos_data</code>: Potential EOS data to pass if we don\u2019t want to connect to device to grab data.</li> <li><code>labels</code>: a list of labels. It is not used yet and it is for futur use.</li> </ul>"},{"location":"advanced_usages/custom-tests/#function-definition","title":"Function definition","text":"<p>The code here can be very simple as well as very complex and will depend of what you expect to do. But in all situation, the same baseline can be leverage:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    def test(self) -&gt; None:\n        pass\n</code></pre> <p>If you want to support option in your test, just declare your options in your test method:</p> <pre><code>class &lt;YourTestName&gt;(AntaTest):\n    ...\n    def test(self, my_param1: str) -&gt; None:\n        pass\n</code></pre>"},{"location":"advanced_usages/custom-tests/#check-inputs","title":"Check inputs","text":"<p>If your test has some user inputs, you first have to validate the supplied values are valid. If it is not valid, we expect <code>TestResult</code> to return <code>skipped</code> with a custom message.</p> <pre><code># Check if test option is correct\nif not minimum:\n    self.result.is_skipped(\"verify_dynamic_vlan was run without minimum value set\")\nelse:\n    ...\n</code></pre>"},{"location":"advanced_usages/custom-tests/#implement-your-logic","title":"Implement your logic","text":"<p>Here you implement your own logic. In general, the first action is to send command to devices and capture its response.</p> <p>In the example below, we request the list of vlans configured on device and then count all the vlans marked as dynamic</p> <pre><code># Grab data for your command\ncommand_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n# Do your test: In this example we count number of vlans with field dynamic set to true\nnum_dyn_vlan = len([ vlan for vlan,data in command_output['vlans'].items() if command_output['dynamic'] is True])\nif num_dyn_vlan &gt;= minimum:\n    self.result.is_success()\nelse:\n    self.result.is_failure(f\"Device has {num_dyn_vlan} configured, we expect at least {minimum}\")\n</code></pre> <p>As you can see there is no error management to do in your code. Everything is packaged in <code>anta_tests</code> and below is a simple example of error captured with an incorrect JSON key in the code above:</p> <pre><code>ERROR    Exception raised for test verify_dynamic_vlan (on device 192.168.0.10) - KeyError ('vlans')\n</code></pre> <p>Get stack trace for debugging</p> <p>If you want to access to the full exception stack, you can run your test with logging level set to <code>DEBUG</code>. With ANTA cli, it is available with following option: <pre><code>$ anta nrfu text --catalog test_custom.yml --log-level debug\n</code></pre></p>"},{"location":"advanced_usages/custom-tests/#create-your-catalog","title":"Create your catalog","text":"<p>This section is required only if you are not merging your development into ANTA. Otherwise, just follow contribution guide.</p> <p>It is very similar to what is documented in catalog section but you have to use your own package name.</p> <p>Let say the custom catalog is <code>anta_titom73</code> and the test is configured in <code>anta_titom73.dc_project</code>, the test catalog would look like:</p> <p><pre><code>anta_titom73.dc_project:\n- VerifyFeatureX:\nminimum: 1\n</code></pre> And now you can run your NRFU tests with the CLI:</p> <pre><code>anta nrfu text --catalog test_custom.yml\nspine01 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nspine02 :: verify_dynamic_vlan :: FAILURE (Device has 0 configured, we expect at least 1)\nleaf01 :: verify_dynamic_vlan :: SUCCESS\nleaf02 :: verify_dynamic_vlan :: SUCCESS\nleaf03 :: verify_dynamic_vlan :: SUCCESS\nleaf04 :: verify_dynamic_vlan :: SUCCESS\n</code></pre> <p>Install your python package</p> <p>Anta uses Python path to access to your test. So it is critical to have your tests library installed correctly as explained at the begining of this page.</p>"},{"location":"api/inventory/","title":"Inventory module","text":""},{"location":"api/inventory/#anta-inventory-module","title":"ANTA Inventory module","text":"<p>Inventory Abstraction for ANTA framework.</p> <p>Attributes:</p> Name Type Description <code>timeout</code> <code>float</code> <p>Connection to device timeout.</p> <code>INVENTORY_ROOT_KEY</code> <code>str, Optional</code> <p>head of the YAML inventory. Default is anta_inventory</p> <code>EAPI_SESSION_TPL</code> <code>str, Optional</code> <p>Template for eAPI URL builder</p> <code>INVENTORY_OUTPUT_FORMAT</code> <code>List[str], Optional</code> <p>List of supported output format. Default [\u2018native\u2019, \u2018json\u2019]</p> <code>HW_MODEL_KEY</code> <code>str, Optional</code> <p>Name of the key in Arista eAPI JSON provided by device.</p> <p>Examples:</p> <p>Inventory file input</p> <pre><code>print(inventory.yml)\nanta_inventory:\n  hosts:\n    - hosts: 1.1.1.1\n- host: 2.2.2.2\ntags: ['dc1', 'spine', 'pod01']\n  networks:\n    - network: 10.0.0.0/8\n- network: 192.168.0.0/16\ntags: ['dc1', 'spine', 'pod01']\n  ranges:\n    - start: 10.0.0.1\nend: 10.0.0.11\ntags: ['dc1', 'spine', 'pod01']\n</code></pre> <p>Inventory result:</p> <pre><code>test = AntaInventory(\n... inventory_file='examples/inventory.yml',\n... username='ansible',\n... password='ansible',\n... auto_connect=True)\ntest.get_inventory()\n[\n\"InventoryDevice(host=IPv4Address('192.168.0.17')\",\n\"username='ansible'\",\n\"password='ansible'\",\n\"session=&lt;ServerProxy for ansible:ansible@192.168.0.17/command-api&gt;\",\n\"url='https://ansible:ansible@192.168.0.17/command-api'\",\n\"established=True\",\n\"is_online=True\",\n\"hw_model=cEOS-LAB\",\n...\n\"InventoryDevice(host=IPv4Address('192.168.0.2')\",\n\"username='ansible'\",\n\"password='ansible'\",\n\"session=None\",\n\"url='https://ansible:ansible@192.168.0.2/command-api'\",\n\"established=False\"\n\"is_online=False\",\n\"tags\": ['dc1', 'spine', 'pod01'],\n\"hw_model=unset\",\n]\n</code></pre> <p>Raises:</p> Type Description <code>InventoryRootKeyErrors</code> <p>Root key of inventory is missing.</p> <code>InventoryIncorrectSchema</code> <p>Inventory file is not following AntaInventory Schema.</p> <code>InventoryUnknownFormat</code> <p>Output format is not supported.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>class AntaInventory:\n\"\"\"\n    Inventory Abstraction for ANTA framework.\n\n    Attributes:\n        timeout (float): Connection to device timeout.\n        INVENTORY_ROOT_KEY (str, Optional): head of the YAML inventory. Default is anta_inventory\n        EAPI_SESSION_TPL (str, Optional): Template for eAPI URL builder\n        INVENTORY_OUTPUT_FORMAT (List[str],Optional): List of supported output format. Default ['native', 'json']\n        HW_MODEL_KEY (str,Optional): Name of the key in Arista eAPI JSON provided by device.\n\n    Examples:\n\n        Inventory file input\n\n            print(inventory.yml)\n            anta_inventory:\n              hosts:\n                - hosts: 1.1.1.1\n                - host: 2.2.2.2\n                  tags: ['dc1', 'spine', 'pod01']\n              networks:\n                - network: 10.0.0.0/8\n                - network: 192.168.0.0/16\n                  tags: ['dc1', 'spine', 'pod01']\n              ranges:\n                - start: 10.0.0.1\n                  end: 10.0.0.11\n                  tags: ['dc1', 'spine', 'pod01']\n\n        Inventory result:\n\n            test = AntaInventory(\n                ... inventory_file='examples/inventory.yml',\n                ... username='ansible',\n                ... password='ansible',\n                ... auto_connect=True)\n            test.get_inventory()\n            [\n                    \"InventoryDevice(host=IPv4Address('192.168.0.17')\",\n                    \"username='ansible'\",\n                    \"password='ansible'\",\n                    \"session=&lt;ServerProxy for ansible:ansible@192.168.0.17/command-api&gt;\",\n                    \"url='https://ansible:ansible@192.168.0.17/command-api'\",\n                    \"established=True\",\n                    \"is_online=True\",\n                    \"hw_model=cEOS-LAB\",\n                 ...\n                    \"InventoryDevice(host=IPv4Address('192.168.0.2')\",\n                    \"username='ansible'\",\n                    \"password='ansible'\",\n                    \"session=None\",\n                    \"url='https://ansible:ansible@192.168.0.2/command-api'\",\n                    \"established=False\"\n                    \"is_online=False\",\n                    \"tags\": ['dc1', 'spine', 'pod01'],\n                    \"hw_model=unset\",\n                ]\n\n    Raises:\n        InventoryRootKeyErrors: Root key of inventory is missing.\n        InventoryIncorrectSchema: Inventory file is not following AntaInventory Schema.\n        InventoryUnknownFormat: Output format is not supported.\n\n    \"\"\"\n\n    # Root key of inventory part of the inventory file\n    INVENTORY_ROOT_KEY = \"anta_inventory\"\n    # Supported Output format\n    INVENTORY_OUTPUT_FORMAT = [\"native\", \"json\"]\n    # HW model definition in show version\n    HW_MODEL_KEY = \"modelName\"\n\n    # pylint: disable=R0913\n    def __init__(\n        self,\n        inventory_file: str,\n        username: str,\n        password: str,\n        enable_password: Optional[str] = None,\n        timeout: Optional[float] = None,\n        filter_hosts: Optional[List[str]] = None,\n    ) -&gt; None:\n\"\"\"Class constructor.\n\n        Args:\n            inventory_file (str): Path to inventory YAML file where user has described his inputs\n            username (str): Username to use to connect to devices\n            password (str): Password to use to connect to devices\n            timeout (float, optional): timeout in seconds for every API call.\n            filter_hosts (str, optional): create inventory only with matching host name in this list.\n        \"\"\"\n        self._username = username\n        self._password = password\n        self._enable_password = enable_password\n        self.timeout = timeout\n        self._inventory = InventoryDevices()\n\n        with open(inventory_file, \"r\", encoding=\"UTF-8\") as fd:\n            data = yaml.load(fd, Loader=SafeLoader)\n\n        # Load data using Pydantic\n        try:\n            self._read_inventory = AntaInventoryInput(**data[self.INVENTORY_ROOT_KEY])\n        except KeyError as exc:\n            logger.error(f\"Inventory root key is missing: {self.INVENTORY_ROOT_KEY}\")\n            raise InventoryRootKeyErrors(f\"Inventory root key ({self.INVENTORY_ROOT_KEY}) is not defined in your inventory\") from exc\n        except ValidationError as exc:\n            logger.error(\"Inventory data are not compliant with inventory models\")\n            raise InventoryIncorrectSchema(\"Inventory is not following schema\") from exc\n\n        # Read data from input\n        if self._read_inventory.dict()[\"hosts\"] is not None:\n            self._inventory_read_hosts()\n        if self._read_inventory.dict()[\"networks\"] is not None:\n            self._inventory_read_networks()\n        if self._read_inventory.dict()[\"ranges\"] is not None:\n            self._inventory_read_ranges()\n\n        if filter_hosts:\n            for device in self._inventory:\n                # TODO - @gmuloc - device does not have url anymore - does this work\n                # if device.url.host not in filter_hosts:\n                if str(device.host) not in filter_hosts:\n                    del device\n\n    ###########################################################################\n    # Boolean methods\n    ###########################################################################\n\n    def _is_ip_exist(self, ip: str) -&gt; bool:  # TODO mtache: unused, remove this ?\n\"\"\"Check if an IP is part of the current inventory.\n\n        Args:\n            ip (str): IP address to search in our inventory\n\n        Returns:\n            bool: True if device is in our inventory, False if not\n        \"\"\"\n        logger.debug(f\"Checking if device {ip} is in our inventory\")\n        return len([str(dev.host) for dev in self._inventory if str(ip) == str(dev.host)]) == 1\n\n    ###########################################################################\n    # Internal methods\n    ###########################################################################\n\n    async def _read_device_hw(self, device: InventoryDevice) -&gt; None:\n\"\"\"\n        _read_device_hw Get HW model name from show version and update the hw_model attribute.\n\n        Args:\n            device (InventoryDevice): Device to update\n        \"\"\"\n        logger.debug(f\"Reading HW information for {device.name}\")\n        try:\n            response = await device.session.cli(command=\"show version\")\n        except EapiCommandError as e:\n            logger.warning(f\"Cannot get HW information from device {device.name}: {e.errmsg}\")\n        except (HTTPError, ConnectError) as e:\n            logger.warning(f\"Cannot get HW information from device {device.name}: {type(e).__name__}{'' if not str(e) else f' ({str(e)})'}\")\n        else:\n            if self.HW_MODEL_KEY in response:\n                device.hw_model = response[self.HW_MODEL_KEY]\n            else:\n                logger.warning(f\"Cannot get HW information from device {device.name}: cannot parse 'show version'\")\n\n    async def _refresh_device_fact(self, device: InventoryDevice) -&gt; None:\n\"\"\"\n        _get_from_device Update the is_online and established flags for InventoryDevice.\n\n        It updates following keys:\n        - is_online: When a device IP is reachable and a port can be open\n        - established: When a CLI command in EXEC mode succeed using eAPI\n        - hw_model: The hardware model string of the device\n\n        Args:\n            device (InventoryDevice): Device to check using InventoryDevice structure.\n\n        Returns:\n            InventoryDevice: Updated structure with devices information\n        \"\"\"\n        logger.debug(f\"Refreshing device {device.name}\")\n        device.is_online = await device.session.check_connection()\n        if device.is_online:\n            await self._read_device_hw(device=device)\n        else:\n            logger.warning(f\"Could not connect to device {device.name}: cannot open eAPI port\")\n        device.established = bool(device.is_online and device.hw_model)\n\n    def _add_device_to_inventory(\n        self,\n        host: str,\n        port: Optional[int] = None,\n        name: Optional[str] = None,\n        tags: Optional[List[str]] = None,\n    ) -&gt; None:\n\"\"\"Add a InventoryDevice to final inventory.\n\n        Create InventoryDevice and append to existing inventory\n\n        Args:\n            host (str): IP address or hostname of the device\n            port (int): eAPI port of the device\n            name (str): Optional name of the device\n        \"\"\"\n        kwargs: Dict[str, Any] = {\n            \"host\": host,\n            \"username\": self._username,\n            \"password\": self._password,\n        }\n        if name:\n            kwargs[\"name\"] = name\n        if port:\n            kwargs[\"port\"] = port\n        if self._enable_password:\n            kwargs[\"enable_password\"] = self._enable_password\n        if tags:\n            kwargs[\"tags\"] = tags\n        if self.timeout:\n            kwargs[\"timeout\"] = self.timeout\n        device = InventoryDevice(**kwargs)\n        self._inventory.append(device)\n\n    def _inventory_read_hosts(self) -&gt; None:\n\"\"\"Read input data from hosts section and create inventory structure.\n\n        Build InventoryDevice structure for all hosts under hosts section\n        \"\"\"\n        assert self._read_inventory.hosts is not None\n        for host in self._read_inventory.hosts:\n            self._add_device_to_inventory(str(host.host), host.port, host.name, tags=host.tags)\n\n    def _inventory_read_networks(self) -&gt; None:\n\"\"\"Read input data from networks section and create inventory structure.\n\n        Build InventoryDevice structure for all IPs available in each declared subnet\n        \"\"\"\n        assert self._read_inventory.networks is not None\n        for network in self._read_inventory.networks:\n            for host_ip in IPNetwork(str(network.network)):\n                self._add_device_to_inventory(host_ip, tags=network.tags)\n\n    def _inventory_read_ranges(self) -&gt; None:\n\"\"\"Read input data from ranges section and create inventory structure.\n\n        Build InventoryDevice structure for all IPs available in each declared range\n        \"\"\"\n        assert self._read_inventory.ranges is not None\n        for range_def in self._read_inventory.ranges:\n            range_increment = IPAddress(str(range_def.start))\n            range_stop = IPAddress(str(range_def.end))\n            while range_increment &lt;= range_stop:\n                self._add_device_to_inventory(str(range_increment), tags=range_def.tags)\n                range_increment += 1\n\n    ###########################################################################\n    # Public methods\n    ###########################################################################\n\n    ###########################################################################\n    # GET methods\n    ###########################################################################\n\n    def get_inventory(self, established_only: bool = False, tags: Optional[List[str]] = None) -&gt; InventoryDevices:\n\"\"\"\n        get_inventory Returns a new filtered inventory.\n\n        Args:\n            established_only (bool, optional): Whether or not including non-established devices in the Inventory.\n                                               Default False.\n            tags (List[str], optional): List of tags to use to filter devices.\n\n        Returns:\n            InventoryDevices: An inventory with concerned devices\n        \"\"\"\n\n        def _filter_devices(device: InventoryDevice) -&gt; bool:\n\"\"\"\n            Helper function to select the devices based on the input tags\n            and the requirement for an established connection.\n            \"\"\"\n            if tags is not None and all(tag not in tags for tag in device.tags):\n                return False\n            return bool(not established_only or device.established)\n\n        result = InventoryDevices()\n        result.__root__ = list(filter(_filter_devices, self._inventory))\n        return result\n\n    ###########################################################################\n    # MISC methods\n    ###########################################################################\n\n    async def connect_inventory(self) -&gt; None:\n\"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\"\n        logger.debug(\"Refreshing facts for current inventory\")\n        results = await asyncio.gather(\n            *(self._refresh_device_fact(device) for device in self._inventory),\n            return_exceptions=True,\n        )\n        for r in results:\n            if isinstance(r, Exception):\n                logger.error(f\"Error when initiating inventory: {r.__class__.__name__}{'' if not str(r) else f' ({str(r)})'}\")\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.__init__","title":"<code>__init__(inventory_file, username, password, enable_password=None, timeout=None, filter_hosts=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>inventory_file</code> <code>str</code> <p>Path to inventory YAML file where user has described his inputs</p> required <code>username</code> <code>str</code> <p>Username to use to connect to devices</p> required <code>password</code> <code>str</code> <p>Password to use to connect to devices</p> required <code>timeout</code> <code>float</code> <p>timeout in seconds for every API call.</p> <code>None</code> <code>filter_hosts</code> <code>str</code> <p>create inventory only with matching host name in this list.</p> <code>None</code> Source code in <code>anta/inventory/__init__.py</code> <pre><code>def __init__(\n    self,\n    inventory_file: str,\n    username: str,\n    password: str,\n    enable_password: Optional[str] = None,\n    timeout: Optional[float] = None,\n    filter_hosts: Optional[List[str]] = None,\n) -&gt; None:\n\"\"\"Class constructor.\n\n    Args:\n        inventory_file (str): Path to inventory YAML file where user has described his inputs\n        username (str): Username to use to connect to devices\n        password (str): Password to use to connect to devices\n        timeout (float, optional): timeout in seconds for every API call.\n        filter_hosts (str, optional): create inventory only with matching host name in this list.\n    \"\"\"\n    self._username = username\n    self._password = password\n    self._enable_password = enable_password\n    self.timeout = timeout\n    self._inventory = InventoryDevices()\n\n    with open(inventory_file, \"r\", encoding=\"UTF-8\") as fd:\n        data = yaml.load(fd, Loader=SafeLoader)\n\n    # Load data using Pydantic\n    try:\n        self._read_inventory = AntaInventoryInput(**data[self.INVENTORY_ROOT_KEY])\n    except KeyError as exc:\n        logger.error(f\"Inventory root key is missing: {self.INVENTORY_ROOT_KEY}\")\n        raise InventoryRootKeyErrors(f\"Inventory root key ({self.INVENTORY_ROOT_KEY}) is not defined in your inventory\") from exc\n    except ValidationError as exc:\n        logger.error(\"Inventory data are not compliant with inventory models\")\n        raise InventoryIncorrectSchema(\"Inventory is not following schema\") from exc\n\n    # Read data from input\n    if self._read_inventory.dict()[\"hosts\"] is not None:\n        self._inventory_read_hosts()\n    if self._read_inventory.dict()[\"networks\"] is not None:\n        self._inventory_read_networks()\n    if self._read_inventory.dict()[\"ranges\"] is not None:\n        self._inventory_read_ranges()\n\n    if filter_hosts:\n        for device in self._inventory:\n            # TODO - @gmuloc - device does not have url anymore - does this work\n            # if device.url.host not in filter_hosts:\n            if str(device.host) not in filter_hosts:\n                del device\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.connect_inventory","title":"<code>connect_inventory()</code>  <code>async</code>","text":"<p>connect_inventory Helper to prepare inventory with network data.</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>async def connect_inventory(self) -&gt; None:\n\"\"\"connect_inventory Helper to prepare inventory with network data.\"\"\"\n    logger.debug(\"Refreshing facts for current inventory\")\n    results = await asyncio.gather(\n        *(self._refresh_device_fact(device) for device in self._inventory),\n        return_exceptions=True,\n    )\n    for r in results:\n        if isinstance(r, Exception):\n            logger.error(f\"Error when initiating inventory: {r.__class__.__name__}{'' if not str(r) else f' ({str(r)})'}\")\n</code></pre>"},{"location":"api/inventory/#anta.inventory.AntaInventory.get_inventory","title":"<code>get_inventory(established_only=False, tags=None)</code>","text":"<p>get_inventory Returns a new filtered inventory.</p> <p>Parameters:</p> Name Type Description Default <code>established_only</code> <code>bool</code> <p>Whether or not including non-established devices in the Inventory.                                Default False.</p> <code>False</code> <code>tags</code> <code>List[str]</code> <p>List of tags to use to filter devices.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>InventoryDevices</code> <code>InventoryDevices</code> <p>An inventory with concerned devices</p> Source code in <code>anta/inventory/__init__.py</code> <pre><code>def get_inventory(self, established_only: bool = False, tags: Optional[List[str]] = None) -&gt; InventoryDevices:\n\"\"\"\n    get_inventory Returns a new filtered inventory.\n\n    Args:\n        established_only (bool, optional): Whether or not including non-established devices in the Inventory.\n                                           Default False.\n        tags (List[str], optional): List of tags to use to filter devices.\n\n    Returns:\n        InventoryDevices: An inventory with concerned devices\n    \"\"\"\n\n    def _filter_devices(device: InventoryDevice) -&gt; bool:\n\"\"\"\n        Helper function to select the devices based on the input tags\n        and the requirement for an established connection.\n        \"\"\"\n        if tags is not None and all(tag not in tags for tag in device.tags):\n            return False\n        return bool(not established_only or device.established)\n\n    result = InventoryDevices()\n    result.__root__ = list(filter(_filter_devices, self._inventory))\n    return result\n</code></pre>"},{"location":"api/inventory/#exceptions","title":"Exceptions","text":"<p>Manage Exception in Inventory module.</p>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryIncorrectSchema","title":"<code>InventoryIncorrectSchema</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Error when user data does not follow ANTA schema.</p> Source code in <code>anta/inventory/exceptions.py</code> <pre><code>class InventoryIncorrectSchema(Exception):\n\"\"\"Error when user data does not follow ANTA schema.\"\"\"\n</code></pre>"},{"location":"api/inventory/#anta.inventory.exceptions.InventoryRootKeyErrors","title":"<code>InventoryRootKeyErrors</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Error raised when inventory root key is not found.</p> Source code in <code>anta/inventory/exceptions.py</code> <pre><code>class InventoryRootKeyErrors(Exception):\n\"\"\"Error raised when inventory root key is not found.\"\"\"\n</code></pre>"},{"location":"api/inventory.models.input/","title":"User Inventory data model","text":""},{"location":"api/inventory.models.input/#data-models-for-antainventory","title":"Data models for anta.inventory","text":"<p>         Bases: <code>BaseModel</code></p> <p>User\u2019s inventory model.</p> <p>Attributes:</p> Name Type Description <code>networks</code> <code>List[AntaInventoryNetwork], Optional</code> <p>List of AntaInventoryNetwork objects for networks.</p> <code>hosts</code> <code>List[AntaInventoryHost], Optional</code> <p>List of AntaInventoryHost objects for hosts.</p> <code>range</code> <code>List[AntaInventoryRange], Optional</code> <p>List of AntaInventoryRange objects for ranges.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryInput(BaseModel):\n\"\"\"\n    User's inventory model.\n\n    Attributes:\n        networks (List[AntaInventoryNetwork],Optional): List of AntaInventoryNetwork objects for networks.\n        hosts (List[AntaInventoryHost],Optional): List of AntaInventoryHost objects for hosts.\n        range (List[AntaInventoryRange],Optional): List of AntaInventoryRange objects for ranges.\n    \"\"\"\n\n    networks: Optional[List[AntaInventoryNetwork]]\n    hosts: Optional[List[AntaInventoryHost]]\n    ranges: Optional[List[AntaInventoryRange]]\n</code></pre>"},{"location":"api/inventory.models.input/#user-inventory-components","title":"User inventory components","text":"<p>         Bases: <code>BaseModel</code></p> <p>Host definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>host</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address of the device</p> <code>port</code> <code>int</code> <p>(Optional) eAPI port to use Default is 443.</p> <code>name</code> <code>str</code> <p>(Optional) Name to display during tests report. Default is hostname:port</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryHost(BaseModel):\n\"\"\"\n    Host definition for user's inventory.\n\n    Attributes:\n        host (IPvAnyAddress): IPv4 or IPv6 address of the device\n        port (int): (Optional) eAPI port to use Default is 443.\n        name (str): (Optional) Name to display during tests report. Default is hostname:port\n        tags (List[str]): List of attached tags read from inventory file.\n    \"\"\"\n\n    name: Optional[str]\n    host: Union[constr(regex=RFC_1123_REGEX), IPvAnyAddress]  # type: ignore\n    port: Optional[conint(gt=1, lt=65535)]  # type: ignore\n    tags: List[str] = [DEFAULT_TAG]\n</code></pre> <p>         Bases: <code>BaseModel</code></p> <p>Network definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>network</code> <code>IPvAnyNetwork</code> <p>Subnet to use for testing.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryNetwork(BaseModel):\n\"\"\"\n    Network definition for user's inventory.\n\n    Attributes:\n        network (IPvAnyNetwork): Subnet to use for testing.\n        tags (List[str]): List of attached tags read from inventory file.\n    \"\"\"\n\n    network: IPvAnyNetwork\n    tags: List[str] = [DEFAULT_TAG]\n</code></pre> <p>         Bases: <code>BaseModel</code></p> <p>IP Range definition for user\u2019s inventory.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the begining of the range.</p> <code>stop</code> <code>IPvAnyAddress</code> <p>IPv4 or IPv6 address for the end of the range.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class AntaInventoryRange(BaseModel):\n\"\"\"\n    IP Range definition for user's inventory.\n\n    Attributes:\n        start (IPvAnyAddress): IPv4 or IPv6 address for the begining of the range.\n        stop (IPvAnyAddress): IPv4 or IPv6 address for the end of the range.\n        tags (List[str]): List of attached tags read from inventory file.\n    \"\"\"\n\n    start: IPvAnyAddress\n    end: IPvAnyAddress\n    tags: List[str] = [DEFAULT_TAG]\n</code></pre>"},{"location":"api/inventory.models/","title":"Generated Inventory data model","text":""},{"location":"api/inventory.models/#inventory-entry","title":"Inventory Entry","text":"<p>         Bases: <code>BaseModel</code></p> <p>Inventory model exposed by Inventory class.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name</p> <code>username</code> <code>str</code> <p>Username to use for connection.</p> <code>password</code> <code>password</code> <p>Password to use for connection.</p> <code>enable_password</code> <code>Optional[str]</code> <p>enable_password to use on the device, required for some tests</p> <code>session</code> <code>Any</code> <p>JSONRPC session.</p> <code>established</code> <code>bool</code> <p>Flag to mark if connection is established (True) or not (False). Default: False.</p> <code>is_online</code> <code>bool</code> <p>Flag to mark if host is alive (True) or not (False). Default: False.</p> <code>hw_model</code> <code>str</code> <p>HW name gathered during device discovery.</p> <code>url</code> <code>str</code> <p>eAPI URL to use to build session.</p> <code>tags</code> <code>List[str]</code> <p>List of attached tags read from inventory file.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class InventoryDevice(BaseModel):\n\"\"\"\n    Inventory model exposed by Inventory class.\n\n    Attributes:\n        name (str): Device name\n        username (str): Username to use for connection.\n        password (password): Password to use for connection.\n        enable_password (Optional[str]): enable_password to use on the device, required for some tests\n        session (Any): JSONRPC session.\n        established (bool): Flag to mark if connection is established (True) or not (False). Default: False.\n        is_online (bool): Flag to mark if host is alive (True) or not (False). Default: False.\n        hw_model (str): HW name gathered during device discovery.\n        url (str): eAPI URL to use to build session.\n        tags (List[str]): List of attached tags read from inventory file.\n    \"\"\"\n\n    class Config:  # pylint: disable=too-few-public-methods\n\"\"\"Pydantic model configuration\"\"\"\n\n        arbitrary_types_allowed = True\n\n    name: str\n    host: Union[constr(regex=RFC_1123_REGEX), IPvAnyAddress]  # type: ignore[valid-type]\n    username: str\n    password: str\n    port: conint(gt=1, lt=65535)  # type: ignore[valid-type]\n    enable_password: Optional[str]\n    session: Device\n    established: bool = False\n    is_online: bool = False\n    hw_model: str = DEFAULT_HW_MODEL\n    tags: List[str] = [DEFAULT_TAG]\n    timeout: float = 10.0\n\n    @root_validator(pre=True)\n    def build_device(cls: BaseModel, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Build the device session object\"\"\"\n        if not values.get(\"host\"):\n            values[\"host\"] = \"localhost\"\n        if not values.get(\"port\"):\n            values[\"port\"] = \"8080\" if values[\"host\"] == \"localhost\" else \"443\"\n        if values.get(\"tags\") is not None:\n            values[\"tags\"].append(DEFAULT_TAG)\n        else:\n            values[\"tags\"] = [DEFAULT_TAG]\n        if values.get(\"session\") is None:\n            proto = \"http\" if values[\"port\"] in [\"80\", \"8080\"] else \"https\"\n            values[\"session\"] = Device(\n                host=values[\"host\"],\n                port=values[\"port\"],\n                username=values.get(\"username\"),\n                password=values.get(\"password\"),\n                proto=proto,\n                timeout=values.get(\"timeout\"),\n            )\n        if values.get(\"name\") is None:\n            values[\"name\"] = f\"{values['host']}:{values['port']}\"\n        return values\n\n    def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        Two InventoryDevice objects are equal if the hostname and the port are the same.\n        This covers the use case of port forwarding when the host is localhost and the devices have different ports.\n        \"\"\"\n        if not isinstance(other, InventoryDevice):\n            return False\n        return self.session.host == other.session.host and self.session.port == other.session.port\n\n    def assert_enable_password_is_not_none(self, test_name: Optional[str] = None) -&gt; None:\n\"\"\"\n        raise ValueError is enable_password is None\n        \"\"\"\n        if not self.enable_password:\n            if test_name:\n                message = f\"{test_name} requires `enable_password` to be set\"\n            else:\n                message = \"`enable_password` is not set\"\n            raise ValueError(message)\n\n    async def collect(self, command: AntaTestCommand) -&gt; Any:\n\"\"\"Collect device command result\n        FIXME: Under development / testing\n        TODO: Build documentation\n        \"\"\"\n        logger.debug(f\"run collect from device {self.name} for {command}\")\n\n        try:\n            if self.enable_password is not None:\n                enable_cmd = {\n                    \"cmd\": \"enable\",\n                    \"input\": str(self.enable_password),\n                }\n            else:\n                enable_cmd = {\"cmd\": \"enable\"}\n            # FIXME: RuntimeError: Event loop is closed\n            # When sending commands over 2 asyncio.run, the first call\n            # of the second run fails\n            # Workaround in cli.debug.run_template\n            response = await self.session.cli(\n                commands=[enable_cmd, command.command],\n                ofmt=command.ofmt,\n                version=command.version,\n            )\n            # remove first dict related to enable command\n            # only applicable to json output\n            if command.ofmt in [\"json\", \"text\"]:\n                # selecting only our command output\n                response = response[1]\n            command.output = response\n\n        except EapiCommandError as e:\n            logger.error(f\"Command failed on {self.name}: {e.errmsg}\")\n        except (HTTPError, ConnectError) as e:\n            logger.error(f\"Cannot connect to device {self.name}: {type(e).__name__}{exc_to_str(e)}\")\n            logger.debug(traceback.format_exc())\n        except Exception as e:  # pylint: disable=broad-exception-caught\n            logger.error(f\"Exception raised while collecting data for test {self.name} (on device {self.name}) - {exc_to_str(e)}\")\n            logger.debug(traceback.format_exc())\n        else:\n            return command\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevice.Config","title":"<code>Config</code>","text":"<p>Pydantic model configuration</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class Config:  # pylint: disable=too-few-public-methods\n\"\"\"Pydantic model configuration\"\"\"\n\n    arbitrary_types_allowed = True\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevice.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Two InventoryDevice objects are equal if the hostname and the port are the same. This covers the use case of port forwarding when the host is localhost and the devices have different ports.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    Two InventoryDevice objects are equal if the hostname and the port are the same.\n    This covers the use case of port forwarding when the host is localhost and the devices have different ports.\n    \"\"\"\n    if not isinstance(other, InventoryDevice):\n        return False\n    return self.session.host == other.session.host and self.session.port == other.session.port\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevice.assert_enable_password_is_not_none","title":"<code>assert_enable_password_is_not_none(test_name=None)</code>","text":"<p>raise ValueError is enable_password is None</p> Source code in <code>anta/inventory/models.py</code> <pre><code>def assert_enable_password_is_not_none(self, test_name: Optional[str] = None) -&gt; None:\n\"\"\"\n    raise ValueError is enable_password is None\n    \"\"\"\n    if not self.enable_password:\n        if test_name:\n            message = f\"{test_name} requires `enable_password` to be set\"\n        else:\n            message = \"`enable_password` is not set\"\n        raise ValueError(message)\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevice.build_device","title":"<code>build_device(values)</code>","text":"<p>Build the device session object</p> Source code in <code>anta/inventory/models.py</code> <pre><code>@root_validator(pre=True)\ndef build_device(cls: BaseModel, values: Dict[str, Any]) -&gt; Dict[str, Any]:\n\"\"\"Build the device session object\"\"\"\n    if not values.get(\"host\"):\n        values[\"host\"] = \"localhost\"\n    if not values.get(\"port\"):\n        values[\"port\"] = \"8080\" if values[\"host\"] == \"localhost\" else \"443\"\n    if values.get(\"tags\") is not None:\n        values[\"tags\"].append(DEFAULT_TAG)\n    else:\n        values[\"tags\"] = [DEFAULT_TAG]\n    if values.get(\"session\") is None:\n        proto = \"http\" if values[\"port\"] in [\"80\", \"8080\"] else \"https\"\n        values[\"session\"] = Device(\n            host=values[\"host\"],\n            port=values[\"port\"],\n            username=values.get(\"username\"),\n            password=values.get(\"password\"),\n            proto=proto,\n            timeout=values.get(\"timeout\"),\n        )\n    if values.get(\"name\") is None:\n        values[\"name\"] = f\"{values['host']}:{values['port']}\"\n    return values\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevice.collect","title":"<code>collect(command)</code>  <code>async</code>","text":"<p>Collect device command result FIXME: Under development / testing TODO: Build documentation</p> Source code in <code>anta/inventory/models.py</code> <pre><code>async def collect(self, command: AntaTestCommand) -&gt; Any:\n\"\"\"Collect device command result\n    FIXME: Under development / testing\n    TODO: Build documentation\n    \"\"\"\n    logger.debug(f\"run collect from device {self.name} for {command}\")\n\n    try:\n        if self.enable_password is not None:\n            enable_cmd = {\n                \"cmd\": \"enable\",\n                \"input\": str(self.enable_password),\n            }\n        else:\n            enable_cmd = {\"cmd\": \"enable\"}\n        # FIXME: RuntimeError: Event loop is closed\n        # When sending commands over 2 asyncio.run, the first call\n        # of the second run fails\n        # Workaround in cli.debug.run_template\n        response = await self.session.cli(\n            commands=[enable_cmd, command.command],\n            ofmt=command.ofmt,\n            version=command.version,\n        )\n        # remove first dict related to enable command\n        # only applicable to json output\n        if command.ofmt in [\"json\", \"text\"]:\n            # selecting only our command output\n            response = response[1]\n        command.output = response\n\n    except EapiCommandError as e:\n        logger.error(f\"Command failed on {self.name}: {e.errmsg}\")\n    except (HTTPError, ConnectError) as e:\n        logger.error(f\"Cannot connect to device {self.name}: {type(e).__name__}{exc_to_str(e)}\")\n        logger.debug(traceback.format_exc())\n    except Exception as e:  # pylint: disable=broad-exception-caught\n        logger.error(f\"Exception raised while collecting data for test {self.name} (on device {self.name}) - {exc_to_str(e)}\")\n        logger.debug(traceback.format_exc())\n    else:\n        return command\n</code></pre>"},{"location":"api/inventory.models/#inventory","title":"Inventory","text":"<p>         Bases: <code>BaseModel</code></p> <p>Inventory model to list all InventoryDevice entries.</p> <p>Attributes:</p> Name Type Description <code>__root__(List[InventoryDevice])</code> <p>A list of InventoryDevice objects.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>class InventoryDevices(BaseModel):\n\"\"\"\n    Inventory model to list all InventoryDevice entries.\n\n    Attributes:\n        __root__(List[InventoryDevice]): A list of InventoryDevice objects.\n    \"\"\"\n\n    # pylint: disable=R0801\n\n    __root__: List[InventoryDevice] = []\n\n    def append(self, value: InventoryDevice) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n        self.__root__.append(value)\n\n    def __iter__(self) -&gt; Iterator[InventoryDevice]:\n\"\"\"Use custom iter method.\"\"\"\n        # TODO - mypy is not happy because we overwrite BaseModel.__iter__\n        # return type and are breaking Liskov Substitution Principle.\n        return iter(self.__root__)\n\n    def __getitem__(self, item: int) -&gt; InventoryDevice:\n\"\"\"Use custom getitem method.\"\"\"\n        return self.__root__[item]\n\n    def __len__(self) -&gt; int:\n\"\"\"Support for length of __root__\"\"\"\n        return len(self.__root__)\n\n    def json(self, **kwargs: Any) -&gt; str:\n\"\"\"Returns a JSON representation of the devices\"\"\"\n        return super().json(exclude={\"__root__\": {\"__all__\": {\"session\"}}}, **kwargs)\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Use custom getitem method.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>def __getitem__(self, item: int) -&gt; InventoryDevice:\n\"\"\"Use custom getitem method.\"\"\"\n    return self.__root__[item]\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__iter__","title":"<code>__iter__()</code>","text":"<p>Use custom iter method.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>def __iter__(self) -&gt; Iterator[InventoryDevice]:\n\"\"\"Use custom iter method.\"\"\"\n    # TODO - mypy is not happy because we overwrite BaseModel.__iter__\n    # return type and are breaking Liskov Substitution Principle.\n    return iter(self.__root__)\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.__len__","title":"<code>__len__()</code>","text":"<p>Support for length of root</p> Source code in <code>anta/inventory/models.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Support for length of __root__\"\"\"\n    return len(self.__root__)\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.append","title":"<code>append(value)</code>","text":"<p>Add support for append method.</p> Source code in <code>anta/inventory/models.py</code> <pre><code>def append(self, value: InventoryDevice) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n    self.__root__.append(value)\n</code></pre>"},{"location":"api/inventory.models/#anta.inventory.models.InventoryDevices.json","title":"<code>json(**kwargs)</code>","text":"<p>Returns a JSON representation of the devices</p> Source code in <code>anta/inventory/models.py</code> <pre><code>def json(self, **kwargs: Any) -&gt; str:\n\"\"\"Returns a JSON representation of the devices\"\"\"\n    return super().json(exclude={\"__root__\": {\"__all__\": {\"session\"}}}, **kwargs)\n</code></pre>"},{"location":"api/models/","title":"Test models","text":""},{"location":"api/models/#antatest-definition","title":"AntaTest definition","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract class defining a test for Anta</p> <p>The goal of this class is to handle the heavy lifting and make writing a test as simple as possible.</p> <p>TODO - complete doctstring with example</p> Source code in <code>anta/models.py</code> <pre><code>class AntaTest(ABC):\n\"\"\"Abstract class defining a test for Anta\n\n    The goal of this class is to handle the heavy lifting and make\n    writing a test as simple as possible.\n\n    TODO - complete doctstring with example\n    \"\"\"\n\n    # Mandatory class attributes\n    # TODO - find a way to tell mypy these are mandatory for child classes - maybe Protocol\n    name: ClassVar[str]\n    description: ClassVar[str]\n    categories: ClassVar[list[str]]\n    # Or any child type\n    commands: ClassVar[list[AntaTestCommand]]\n    # TODO - today we support only one template per Test\n    template: ClassVar[AntaTestTemplate]\n\n    # Optional class attributes\n    test_filters: ClassVar[list[AntaTestFilter]]\n\n    def __init__(\n        self,\n        device: InventoryDevice,\n        template_params: list[dict[str, Any]] | None = None,\n        # TODO document very well the order of eos_data\n        eos_data: list[dict[Any, Any] | str] | None = None,\n        labels: list[str] | None = None,\n    ):\n\"\"\"Class constructor\"\"\"\n        self.logger = logging.getLogger(__name__).getChild(self.__class__.__name__)\n        self.logger.setLevel(level=\"INFO\")\n        self.device = device\n        self.result = TestResult(name=device.name, test=self.name, test_category=self.categories, test_description=self.description)\n        self.labels = labels or []\n\n        # TODO - check optimization for deepcopy\n        # Generating instance_commands from list of commands and template\n        self.instance_commands = []\n        if hasattr(self.__class__, \"commands\") and (cmds := self.__class__.commands) is not None:\n            self.instance_commands.extend(deepcopy(cmds))\n        if hasattr(self.__class__, \"template\") and (tpl := self.__class__.template) is not None:\n            if template_params is None:\n                self.result.is_error(\"Command has template but no params were given\")\n                return\n            self.template_params = template_params\n            self.instance_commands.extend(\n                AntaTestCommand(\n                    command=tpl.template.format(**param),\n                    ofmt=tpl.ofmt,\n                    version=tpl.version,\n                    template=tpl,\n                    template_params=param,\n                )\n                for param in template_params\n            )\n\n        if eos_data is not None:\n            self.logger.debug(\"Test initialized with input data\")\n            self.save_commands_data(eos_data)\n\n    def save_commands_data(self, eos_data: list[dict[Any, Any] | str]) -&gt; None:\n\"\"\"Called at init or at test execution time\"\"\"\n        if len(eos_data) != len(self.instance_commands):\n            self.result.is_error(\"Test initialization error: Trying to save more data than there are commands for the test\")\n            return\n        for index, data in enumerate(eos_data or []):\n            self.instance_commands[index].output = data\n\n    def all_data_collected(self) -&gt; bool:\n\"\"\"returns True if output is populated for every command\"\"\"\n        return all(command.output is not None for command in self.instance_commands)\n\n    def __init_subclass__(cls) -&gt; None:\n\"\"\"\n        Verify that the mandatory class attributes are defined\n        \"\"\"\n        mandatory_attributes = [\"name\", \"description\", \"categories\"]\n        for attr in mandatory_attributes:\n            if not hasattr(cls, attr):\n                raise NotImplementedError(f\"Class {cls} is missing required class attribute {attr}\")\n        # Check that either commands or template exist\n        if not (hasattr(cls, \"commands\") or hasattr(cls, \"template\")):\n            raise NotImplementedError(f\"Class {cls} is missing required either commands or template attribute\")\n\n    async def collect(self) -&gt; None:\n\"\"\"\n        Private collection methids used in anta_assert to handle collection failures\n\n        it calls the collect co-routing define in InventoryDevice to collect ouput per command\n\n        FIXME: to be tested and review\n        \"\"\"\n        for command in self.instance_commands:\n            await self.device.collect(command=command)\n\n    @staticmethod\n    def anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]:\n\"\"\"\n        Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing\n        \"\"\"\n\n        @wraps(function)\n        async def wrapper(\n            self: AntaTest,\n            eos_data: list[dict[Any, Any] | str] | None = None,\n            **kwargs: dict[str, Any],\n        ) -&gt; TestResult:\n\"\"\"\n            This method will call assert\n\n            Returns:\n                TestResult: self.result, populated with the correct exit status\n            \"\"\"\n            if self.result.result != \"unset\":\n                return self.result\n\n            # TODO maybe_skip decorators\n\n            # Data\n            if eos_data is not None:\n                self.logger.debug(\"Test initialized with input data\")\n                self.save_commands_data(eos_data)\n\n            # No test data is present, try to collect\n            if not self.all_data_collected():\n                await self.collect()\n                if self.result.result != \"unset\":\n                    return self.result\n\n            self.logger.debug(f\"Running asserts for test {self.name} for device {self.device.name}: running collect\")\n            try:\n                if not self.all_data_collected():\n                    raise ValueError(\"Some command output is missing\")\n                function(self, **kwargs)\n            except Exception as e:  # pylint: disable=broad-exception-caught\n                self.logger.error(f\"Exception raised during 'assert' for test {self.name} (on device {self.device.name}) - {exc_to_str(e)}\")\n                self.logger.debug(traceback.format_exc())\n                self.result.is_error(exc_to_str(e))\n            return self.result\n\n        return wrapper\n\n    @abstractmethod\n    def test(self) -&gt; Coroutine[Any, Any, TestResult]:\n\"\"\"\n        This abstract method is the core of the test.\n        It MUST set the correct status of self.result with the appropriate error messages\n\n        it must be implemented as follow\n\n        @AntaTest.anta_test\n        def test(self) -&gt; None:\n           '''\n           assert code\n           '''\n        \"\"\"\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.__init__","title":"<code>__init__(device, template_params=None, eos_data=None, labels=None)</code>","text":"<p>Class constructor</p> Source code in <code>anta/models.py</code> <pre><code>def __init__(\n    self,\n    device: InventoryDevice,\n    template_params: list[dict[str, Any]] | None = None,\n    # TODO document very well the order of eos_data\n    eos_data: list[dict[Any, Any] | str] | None = None,\n    labels: list[str] | None = None,\n):\n\"\"\"Class constructor\"\"\"\n    self.logger = logging.getLogger(__name__).getChild(self.__class__.__name__)\n    self.logger.setLevel(level=\"INFO\")\n    self.device = device\n    self.result = TestResult(name=device.name, test=self.name, test_category=self.categories, test_description=self.description)\n    self.labels = labels or []\n\n    # TODO - check optimization for deepcopy\n    # Generating instance_commands from list of commands and template\n    self.instance_commands = []\n    if hasattr(self.__class__, \"commands\") and (cmds := self.__class__.commands) is not None:\n        self.instance_commands.extend(deepcopy(cmds))\n    if hasattr(self.__class__, \"template\") and (tpl := self.__class__.template) is not None:\n        if template_params is None:\n            self.result.is_error(\"Command has template but no params were given\")\n            return\n        self.template_params = template_params\n        self.instance_commands.extend(\n            AntaTestCommand(\n                command=tpl.template.format(**param),\n                ofmt=tpl.ofmt,\n                version=tpl.version,\n                template=tpl,\n                template_params=param,\n            )\n            for param in template_params\n        )\n\n    if eos_data is not None:\n        self.logger.debug(\"Test initialized with input data\")\n        self.save_commands_data(eos_data)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.__init_subclass__","title":"<code>__init_subclass__()</code>","text":"<p>Verify that the mandatory class attributes are defined</p> Source code in <code>anta/models.py</code> <pre><code>def __init_subclass__(cls) -&gt; None:\n\"\"\"\n    Verify that the mandatory class attributes are defined\n    \"\"\"\n    mandatory_attributes = [\"name\", \"description\", \"categories\"]\n    for attr in mandatory_attributes:\n        if not hasattr(cls, attr):\n            raise NotImplementedError(f\"Class {cls} is missing required class attribute {attr}\")\n    # Check that either commands or template exist\n    if not (hasattr(cls, \"commands\") or hasattr(cls, \"template\")):\n        raise NotImplementedError(f\"Class {cls} is missing required either commands or template attribute\")\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.all_data_collected","title":"<code>all_data_collected()</code>","text":"<p>returns True if output is populated for every command</p> Source code in <code>anta/models.py</code> <pre><code>def all_data_collected(self) -&gt; bool:\n\"\"\"returns True if output is populated for every command\"\"\"\n    return all(command.output is not None for command in self.instance_commands)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.anta_test","title":"<code>anta_test(function)</code>  <code>staticmethod</code>","text":"<p>Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing</p> Source code in <code>anta/models.py</code> <pre><code>@staticmethod\ndef anta_test(function: F) -&gt; Callable[..., Coroutine[Any, Any, TestResult]]:\n\"\"\"\n    Decorator for anta_test that handles injecting test data if given and collecting it using asyncio if missing\n    \"\"\"\n\n    @wraps(function)\n    async def wrapper(\n        self: AntaTest,\n        eos_data: list[dict[Any, Any] | str] | None = None,\n        **kwargs: dict[str, Any],\n    ) -&gt; TestResult:\n\"\"\"\n        This method will call assert\n\n        Returns:\n            TestResult: self.result, populated with the correct exit status\n        \"\"\"\n        if self.result.result != \"unset\":\n            return self.result\n\n        # TODO maybe_skip decorators\n\n        # Data\n        if eos_data is not None:\n            self.logger.debug(\"Test initialized with input data\")\n            self.save_commands_data(eos_data)\n\n        # No test data is present, try to collect\n        if not self.all_data_collected():\n            await self.collect()\n            if self.result.result != \"unset\":\n                return self.result\n\n        self.logger.debug(f\"Running asserts for test {self.name} for device {self.device.name}: running collect\")\n        try:\n            if not self.all_data_collected():\n                raise ValueError(\"Some command output is missing\")\n            function(self, **kwargs)\n        except Exception as e:  # pylint: disable=broad-exception-caught\n            self.logger.error(f\"Exception raised during 'assert' for test {self.name} (on device {self.device.name}) - {exc_to_str(e)}\")\n            self.logger.debug(traceback.format_exc())\n            self.result.is_error(exc_to_str(e))\n        return self.result\n\n    return wrapper\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.collect","title":"<code>collect()</code>  <code>async</code>","text":"<p>Private collection methids used in anta_assert to handle collection failures</p> <p>it calls the collect co-routing define in InventoryDevice to collect ouput per command</p> <p>FIXME: to be tested and review</p> Source code in <code>anta/models.py</code> <pre><code>async def collect(self) -&gt; None:\n\"\"\"\n    Private collection methids used in anta_assert to handle collection failures\n\n    it calls the collect co-routing define in InventoryDevice to collect ouput per command\n\n    FIXME: to be tested and review\n    \"\"\"\n    for command in self.instance_commands:\n        await self.device.collect(command=command)\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.save_commands_data","title":"<code>save_commands_data(eos_data)</code>","text":"<p>Called at init or at test execution time</p> Source code in <code>anta/models.py</code> <pre><code>def save_commands_data(self, eos_data: list[dict[Any, Any] | str]) -&gt; None:\n\"\"\"Called at init or at test execution time\"\"\"\n    if len(eos_data) != len(self.instance_commands):\n        self.result.is_error(\"Test initialization error: Trying to save more data than there are commands for the test\")\n        return\n    for index, data in enumerate(eos_data or []):\n        self.instance_commands[index].output = data\n</code></pre>"},{"location":"api/models/#anta.models.AntaTest.test","title":"<code>test()</code>  <code>abstractmethod</code>","text":"<p>This abstract method is the core of the test. It MUST set the correct status of self.result with the appropriate error messages</p> <p>it must be implemented as follow</p> <p>@AntaTest.anta_test def test(self) -&gt; None:    \u2018\u2019\u2018    assert code    \u2018\u2019\u2018</p> Source code in <code>anta/models.py</code> <pre><code>@abstractmethod\ndef test(self) -&gt; Coroutine[Any, Any, TestResult]:\n\"\"\"\n    This abstract method is the core of the test.\n    It MUST set the correct status of self.result with the appropriate error messages\n\n    it must be implemented as follow\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n       '''\n       assert code\n       '''\n    \"\"\"\n</code></pre>"},{"location":"api/models/#antatestcommand-definition","title":"AntaTestCommand definition","text":"<p>         Bases: <code>BaseModel</code></p> <p>Class to define a test command with its API version</p> <p>Attributes:</p> Name Type Description <code>command(str)</code> <p>Test command</p> <code>version</code> <code>Union[int, Literal['latest']]</code> <p>eAPI version - valid values are integers or the string \u201clatest\u201d - default is \u201clatest\u201d</p> <code>ofmt(str)</code> <code>Union[int, Literal['latest']]</code> <p>eAPI output - json or text - default is json</p> <code>output</code> <code>Optional[Union[Dict[str, Any], str]]</code> <p>collected output either dict for json or str for text</p> <code>template</code> <code>Optional(AntaTestTemplate</code> <p>Template used to generate the command</p> <code>template_params</code> <code>Optional(dict</code> <p>params used in the template to generate the command</p> Source code in <code>anta/models.py</code> <pre><code>class AntaTestCommand(BaseModel):\n\"\"\"Class to define a test command with its API version\n\n    Attributes:\n        command(str): Test command\n        version: eAPI version - valid values are integers or the string \"latest\" - default is \"latest\"\n        ofmt(str):  eAPI output - json or text - default is json\n        output: collected output either dict for json or str for text\n        template Optional(AntaTestTemplate): Template used to generate the command\n        template_params Optional(dict): params used in the template to generate the command\n    \"\"\"\n\n    command: str\n    version: Union[int, Literal[\"latest\"]] = \"latest\"\n    ofmt: str = \"json\"\n    output: Optional[Union[Dict[str, Any], str]]\n    template: Optional[AntaTestTemplate] = None\n    template_params: Optional[Dict[str, str]]\n\n    @validator(\"template_params\")\n    def prevent_none_when_template_is_set(cls: Type[AntaTestTemplate], value: Optional[Dict[str, str]]) -&gt; Optional[Dict[str, str]]:\n\"\"\"\n        Raises if template is set but no params are given\n        \"\"\"\n        if hasattr(cls, \"template\") and cls.template is not None:\n            assert value is not None\n\n        return value\n</code></pre>"},{"location":"api/models/#anta.models.AntaTestCommand.prevent_none_when_template_is_set","title":"<code>prevent_none_when_template_is_set(value)</code>","text":"<p>Raises if template is set but no params are given</p> Source code in <code>anta/models.py</code> <pre><code>@validator(\"template_params\")\ndef prevent_none_when_template_is_set(cls: Type[AntaTestTemplate], value: Optional[Dict[str, str]]) -&gt; Optional[Dict[str, str]]:\n\"\"\"\n    Raises if template is set but no params are given\n    \"\"\"\n    if hasattr(cls, \"template\") and cls.template is not None:\n        assert value is not None\n\n    return value\n</code></pre>"},{"location":"api/models/#antatesttemplate-definition","title":"AntaTestTemplate definition","text":"<p>         Bases: <code>BaseModel</code></p> <p>Class to define a test command with its API version</p> <p>Attributes:</p> Name Type Description <code>command(str)</code> <p>Test command</p> <code>version</code> <code>Union[int, Literal['latest']]</code> <p>eAPI version - valid values are integers or the string \u201clatest\u201d - default is \u201clatest\u201d</p> <code>ofmt(str)</code> <code>Union[int, Literal['latest']]</code> <p>eAPI output - json or text - default is json</p> <code>output</code> <code>Union[int, Literal['latest']]</code> <p>collected output either dict for json or str for text</p> Source code in <code>anta/models.py</code> <pre><code>class AntaTestTemplate(BaseModel):\n\"\"\"Class to define a test command with its API version\n\n    Attributes:\n        command(str): Test command\n        version: eAPI version - valid values are integers or the string \"latest\" - default is \"latest\"\n        ofmt(str):  eAPI output - json or text - default is json\n        output: collected output either dict for json or str for text\n    \"\"\"\n\n    template: str\n    version: Union[int, Literal[\"latest\"]] = \"latest\"\n    ofmt: str = \"json\"\n</code></pre>"},{"location":"api/report_manager/","title":"Report Manager module","text":""},{"location":"api/report_manager/#anta-reportmanager-module","title":"ANTA ReportManager module","text":"<p>TableReport Generate a Table based on TestResult.</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>class ReportTable:\n\"\"\"TableReport Generate a Table based on TestResult.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"\n        __init__ Class constructor\n        \"\"\"\n        self.colors = []\n        self.colors.append(ColorManager(level=\"success\", color=RICH_COLOR_PALETTE.SUCCESS))\n        self.colors.append(ColorManager(level=\"failure\", color=RICH_COLOR_PALETTE.FAILURE))\n        self.colors.append(ColorManager(level=\"error\", color=RICH_COLOR_PALETTE.ERROR))\n        self.colors.append(ColorManager(level=\"skipped\", color=RICH_COLOR_PALETTE.SKIPPED))\n\n    def _split_list_to_txt_list(self, usr_list: List[str], delimiter: Optional[str] = None) -&gt; str:\n\"\"\"\n        Split list to multi-lines string\n\n        Args:\n            usr_list (List[str]): List of string to concatenate\n            delimiter (str, optional): A delimiter to use to start string. Defaults to None.\n\n        Returns:\n            str: Multi-lines string\n        \"\"\"\n        if delimiter is not None:\n            return \"\\n\".join(f\"{delimiter} {line}\" for line in usr_list)\n        return \"\\n\".join(f\"{line}\" for line in usr_list)\n\n    def _build_headers(self, headers: List[str], table: Table) -&gt; Table:\n\"\"\"\n        Create headers for a table.\n\n        First key is considered as header and is colored using RICH_COLOR_PALETTE.HEADER\n\n        Args:\n            headers (List[str]): List of headers\n            table (Table): A rich Table instance\n\n        Returns:\n            Table: A rich Table instance with headers\n        \"\"\"\n        for idx, header in enumerate(headers):\n            if idx == 0:\n                table.add_column(header, justify=\"left\", style=RICH_COLOR_PALETTE.HEADER, no_wrap=True)\n            else:\n                table.add_column(header, justify=\"left\")\n        return table\n\n    def _color_result(self, status: str, output_type: str = \"Text\") -&gt; Any:\n\"\"\"\n        Helper to implement color based on test status.\n\n        It gives output for either standard str or Text() colorized with Style()\n\n        Args:\n            status (str): status value to colorized\n            output_type (str, optional): Which format to output code. Defaults to 'Text'.\n\n        Returns:\n            Any: Can be either str or Text with Style\n        \"\"\"\n        if len([result for result in self.colors if str(result.level).upper() == status.upper()]) == 1:\n            code: ColorManager = [result for result in self.colors if str(result.level).upper() == status.upper()][0]\n            return code.style_rich() if output_type == \"Text\" else code.string()\n        return None\n\n    def report_all(\n        self,\n        result_manager: ResultManager,\n        host: Optional[str] = None,\n        testcase: Optional[str] = None,\n        title: str = \"All tests results\",\n    ) -&gt; Table:\n\"\"\"\n        Create a table report with all tests for one or all devices.\n\n        Create table with full output: Host / Test / Status / Message\n\n        Args:\n            result_manager (ResultManager): A manager with a list of tests.\n            host (str, optional): IP Address of a host to search for. Defaults to None.\n            testcase (str, optional): A test name to search for. Defaults to None.\n            title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n        Returns:\n            Table: A fully populated rich Table\n        \"\"\"\n        table = Table(title=title)\n        headers = [\"Device IP\", \"Test Name\", \"Test Status\", \"Message(s)\"]\n        table = self._build_headers(headers=headers, table=table)\n\n        for result in result_manager.get_results(output_format=\"list\"):\n            # pylint: disable=R0916\n            if (host is None and testcase is None) or (host is not None and str(result.name) == host) or (testcase is not None and testcase == str(result.test)):\n                logger.debug(f\"adding new entry in table: {result.name} / {result.test} / {result.result}\")\n                state = self._color_result(status=str(result.result), output_type=\"str\")\n                message = self._split_list_to_txt_list(result.messages) if len(result.messages) &gt; 0 else \"\"\n                table.add_row(str(result.name), result.test, state, message)\n        return table\n\n    def report_summary_tests(\n        self,\n        result_manager: ResultManager,\n        testcase: Optional[str] = None,\n        title: str = \"Summary per test case\",\n    ) -&gt; Table:\n\"\"\"\n        Create a table report with result agregated per test.\n\n        Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n        Args:\n            result_manager (ResultManager): A manager with a list of tests.\n            testcase (str, optional): A test name to search for. Defaults to None.\n            title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n        Returns:\n            Table: A fully populated rich Table\n        \"\"\"\n        # sourcery skip: class-extract-method\n        table = Table(title=title)\n        headers = [\n            \"Test Case\",\n            \"# of success\",\n            \"# of skipped\",\n            \"# of failure\",\n            \"# of errors\",\n            \"List of failed or error nodes\",\n        ]\n        table = self._build_headers(headers=headers, table=table)\n        for testcase_read in result_manager.get_testcases():\n            if testcase is None or str(testcase_read) == testcase:\n                results = result_manager.get_result_by_test(testcase_read)\n                nb_failure = len([result for result in results if result.result == \"failure\"])\n                nb_error = len([result for result in results if result.result == \"error\"])\n                list_failure = [str(result.name) for result in results if result.result in [\"failure\", \"error\"]]\n                nb_success = len([result for result in results if result.result == \"success\"])\n                nb_skipped = len([result for result in results if result.result == \"skipped\"])\n                table.add_row(\n                    testcase_read,\n                    str(nb_success),\n                    str(nb_skipped),\n                    str(nb_failure),\n                    str(nb_error),\n                    str(list_failure),\n                )\n        return table\n\n    def report_summary_hosts(\n        self,\n        result_manager: ResultManager,\n        host: Optional[str] = None,\n        title: str = \"Summary per host\",\n    ) -&gt; Table:\n\"\"\"\n        Create a table report with result agregated per host.\n\n        Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n        Args:\n            result_manager (ResultManager): A manager with a list of tests.\n            host (str, optional): IP Address of a host to search for. Defaults to None.\n            title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n        Returns:\n            Table: A fully populated rich Table\n        \"\"\"\n        table = Table(title=title)\n        headers = [\n            \"Host IP\",\n            \"# of success\",\n            \"# of skipped\",\n            \"# of failure\",\n            \"# of errors\",\n            \"List of failed ortest case\",\n        ]\n        table = self._build_headers(headers=headers, table=table)\n        for host_read in result_manager.get_hosts():\n            if host is None or str(host_read) == host:\n                results = result_manager.get_result_by_host(host_read)\n                logger.debug(\"data to use for computation\")\n                logger.debug(f\"{host}: {results}\")\n                nb_failure = len([result for result in results if result.result == \"failure\"])\n                nb_error = len([result for result in results if result.result == \"error\"])\n                list_failure = [str(result.test) for result in results if result.result in [\"failure\", \"error\"]]\n                nb_success = len([result for result in results if result.result == \"success\"])\n                nb_skipped = len([result for result in results if result.result == \"skipped\"])\n                table.add_row(\n                    str(host_read),\n                    str(nb_success),\n                    str(nb_skipped),\n                    str(nb_failure),\n                    str(nb_error),\n                    str(list_failure),\n                )\n        return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.__init__","title":"<code>__init__()</code>","text":"<p>init Class constructor</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"\n    __init__ Class constructor\n    \"\"\"\n    self.colors = []\n    self.colors.append(ColorManager(level=\"success\", color=RICH_COLOR_PALETTE.SUCCESS))\n    self.colors.append(ColorManager(level=\"failure\", color=RICH_COLOR_PALETTE.FAILURE))\n    self.colors.append(ColorManager(level=\"error\", color=RICH_COLOR_PALETTE.ERROR))\n    self.colors.append(ColorManager(level=\"skipped\", color=RICH_COLOR_PALETTE.SKIPPED))\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_all","title":"<code>report_all(result_manager, host=None, testcase=None, title='All tests results')</code>","text":"<p>Create a table report with all tests for one or all devices.</p> <p>Create table with full output: Host / Test / Status / Message</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'All tests results'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_all(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    testcase: Optional[str] = None,\n    title: str = \"All tests results\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with all tests for one or all devices.\n\n    Create table with full output: Host / Test / Status / Message\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\"Device IP\", \"Test Name\", \"Test Status\", \"Message(s)\"]\n    table = self._build_headers(headers=headers, table=table)\n\n    for result in result_manager.get_results(output_format=\"list\"):\n        # pylint: disable=R0916\n        if (host is None and testcase is None) or (host is not None and str(result.name) == host) or (testcase is not None and testcase == str(result.test)):\n            logger.debug(f\"adding new entry in table: {result.name} / {result.test} / {result.result}\")\n            state = self._color_result(status=str(result.result), output_type=\"str\")\n            message = self._split_list_to_txt_list(result.messages) if len(result.messages) &gt; 0 else \"\"\n            table.add_row(str(result.name), result.test, state, message)\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_hosts","title":"<code>report_summary_hosts(result_manager, host=None, title='Summary per host')</code>","text":"<p>Create a table report with result agregated per host.</p> <p>Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>host</code> <code>str</code> <p>IP Address of a host to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per host'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_hosts(\n    self,\n    result_manager: ResultManager,\n    host: Optional[str] = None,\n    title: str = \"Summary per host\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per host.\n\n    Create table with full output: Host / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        host (str, optional): IP Address of a host to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    table = Table(title=title)\n    headers = [\n        \"Host IP\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed ortest case\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for host_read in result_manager.get_hosts():\n        if host is None or str(host_read) == host:\n            results = result_manager.get_result_by_host(host_read)\n            logger.debug(\"data to use for computation\")\n            logger.debug(f\"{host}: {results}\")\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.test) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                str(host_read),\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager/#anta.reporter.ReportTable.report_summary_tests","title":"<code>report_summary_tests(result_manager, testcase=None, title='Summary per test case')</code>","text":"<p>Create a table report with result agregated per test.</p> <p>Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure</p> <p>Parameters:</p> Name Type Description Default <code>result_manager</code> <code>ResultManager</code> <p>A manager with a list of tests.</p> required <code>testcase</code> <code>str</code> <p>A test name to search for. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the report. Defaults to \u2018All tests results\u2019.</p> <code>'Summary per test case'</code> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>A fully populated rich Table</p> Source code in <code>anta/reporter/__init__.py</code> <pre><code>def report_summary_tests(\n    self,\n    result_manager: ResultManager,\n    testcase: Optional[str] = None,\n    title: str = \"Summary per test case\",\n) -&gt; Table:\n\"\"\"\n    Create a table report with result agregated per test.\n\n    Create table with full output: Test / Number of success / Number of failure / Number of error / List of nodes in error or failure\n\n    Args:\n        result_manager (ResultManager): A manager with a list of tests.\n        testcase (str, optional): A test name to search for. Defaults to None.\n        title (str, optional): Title for the report. Defaults to 'All tests results'.\n\n    Returns:\n        Table: A fully populated rich Table\n    \"\"\"\n    # sourcery skip: class-extract-method\n    table = Table(title=title)\n    headers = [\n        \"Test Case\",\n        \"# of success\",\n        \"# of skipped\",\n        \"# of failure\",\n        \"# of errors\",\n        \"List of failed or error nodes\",\n    ]\n    table = self._build_headers(headers=headers, table=table)\n    for testcase_read in result_manager.get_testcases():\n        if testcase is None or str(testcase_read) == testcase:\n            results = result_manager.get_result_by_test(testcase_read)\n            nb_failure = len([result for result in results if result.result == \"failure\"])\n            nb_error = len([result for result in results if result.result == \"error\"])\n            list_failure = [str(result.name) for result in results if result.result in [\"failure\", \"error\"]]\n            nb_success = len([result for result in results if result.result == \"success\"])\n            nb_skipped = len([result for result in results if result.result == \"skipped\"])\n            table.add_row(\n                testcase_read,\n                str(nb_success),\n                str(nb_skipped),\n                str(nb_failure),\n                str(nb_error),\n                str(list_failure),\n            )\n    return table\n</code></pre>"},{"location":"api/report_manager_models/","title":"Report Manager models","text":""},{"location":"api/report_manager_models/#colormanager-entry","title":"ColorManager Entry","text":"<p>         Bases: <code>BaseModel</code></p> <p>Color management for status report.</p> <p>Attributes:</p> Name Type Description <code>level</code> <code>str</code> <p>Test result value.</p> <code>color</code> <code>str</code> <p>Associated color.</p> Source code in <code>anta/reporter/models.py</code> <pre><code>class ColorManager(BaseModel):\n\"\"\"Color management for status report.\n\n    Attributes:\n        level (str): Test result value.\n        color (str): Associated color.\n    \"\"\"\n\n    level: str\n    color: str\n\n    @validator(\"level\", allow_reuse=True)\n    def name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n        Status validator\n\n        Validate status is a supported one\n\n        Args:\n            v (str): User defined level\n\n        Raises:\n            ValueError: If level is unsupported\n\n        Returns:\n            str: level value\n        \"\"\"\n        if v not in RESULT_OPTIONS:\n            raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n        return v\n\n    def style_rich(self) -&gt; Text:\n\"\"\"\n        Build a rich Text syntax with color\n\n        Returns:\n            Text: object with level string and its associated color.\n        \"\"\"\n        return Text(self.level, style=self.color)\n\n    def string(self) -&gt; str:\n\"\"\"\n        Build an str with color code\n\n        Returns:\n            str: String with level and its associated color\n        \"\"\"\n        return f\"[{self.color}]{self.level}\"\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.name_must_be_in","title":"<code>name_must_be_in(v)</code>","text":"<p>Status validator</p> <p>Validate status is a supported one</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>User defined level</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If level is unsupported</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>level value</p> Source code in <code>anta/reporter/models.py</code> <pre><code>@validator(\"level\", allow_reuse=True)\ndef name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n    Status validator\n\n    Validate status is a supported one\n\n    Args:\n        v (str): User defined level\n\n    Raises:\n        ValueError: If level is unsupported\n\n    Returns:\n        str: level value\n    \"\"\"\n    if v not in RESULT_OPTIONS:\n        raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n    return v\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.string","title":"<code>string()</code>","text":"<p>Build an str with color code</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String with level and its associated color</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def string(self) -&gt; str:\n\"\"\"\n    Build an str with color code\n\n    Returns:\n        str: String with level and its associated color\n    \"\"\"\n    return f\"[{self.color}]{self.level}\"\n</code></pre>"},{"location":"api/report_manager_models/#anta.reporter.models.ColorManager.style_rich","title":"<code>style_rich()</code>","text":"<p>Build a rich Text syntax with color</p> <p>Returns:</p> Name Type Description <code>Text</code> <code>Text</code> <p>object with level string and its associated color.</p> Source code in <code>anta/reporter/models.py</code> <pre><code>def style_rich(self) -&gt; Text:\n\"\"\"\n    Build a rich Text syntax with color\n\n    Returns:\n        Text: object with level string and its associated color.\n    \"\"\"\n    return Text(self.level, style=self.color)\n</code></pre>"},{"location":"api/result_manager/","title":"Result Manager module","text":""},{"location":"api/result_manager/#anta-resultmanager-module","title":"ANTA ResultManager module","text":"<p>Helper to manage Test Results and generate reports.</p> <p>Examples:</p> <p>Create Inventory:</p> <pre><code>inventory_anta = AntaInventory(\n    inventory_file='examples/inventory.yml',\n    username='ansible',\n    password='ansible',\n    timeout=0.5,\n    auto_connect=True\n)\n</code></pre> <p>Create Result Manager:</p> <pre><code>manager = ResultManager()\n</code></pre> <p>Run tests for all connected devices:</p> <pre><code>for device in inventory_anta.get_inventory():\n    manager.add_test_result(\nVerifyNTP(device=device).test()\n)\nmanager.add_test_result(\nVerifyEOSVersion(device=device).test(version='4.28.3M')\n)\n</code></pre> <p>Print result in native format:</p> <pre><code>manager.get_results()\n[\n    TestResult(\n        host=IPv4Address('192.168.0.10'),\n        test='VerifyNTP',\n        result='failure',\n        message=\"device is not running NTP correctly\"\n    ),\n    TestResult(\n        host=IPv4Address('192.168.0.10'),\n        test='VerifyEOSVersion',\n        result='success',\n        message=None\n    ),\n]\n</code></pre> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>class ResultManager:\n\"\"\"\n    Helper to manage Test Results and generate reports.\n\n    Examples:\n\n        Create Inventory:\n\n            inventory_anta = AntaInventory(\n                inventory_file='examples/inventory.yml',\n                username='ansible',\n                password='ansible',\n                timeout=0.5,\n                auto_connect=True\n            )\n\n        Create Result Manager:\n\n            manager = ResultManager()\n\n        Run tests for all connected devices:\n\n            for device in inventory_anta.get_inventory():\n                manager.add_test_result(\n                    VerifyNTP(device=device).test()\n                )\n                manager.add_test_result(\n                    VerifyEOSVersion(device=device).test(version='4.28.3M')\n                )\n\n        Print result in native format:\n\n            manager.get_results()\n            [\n                TestResult(\n                    host=IPv4Address('192.168.0.10'),\n                    test='VerifyNTP',\n                    result='failure',\n                    message=\"device is not running NTP correctly\"\n                ),\n                TestResult(\n                    host=IPv4Address('192.168.0.10'),\n                    test='VerifyEOSVersion',\n                    result='success',\n                    message=None\n                ),\n            ]\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Class constructor.\"\"\"\n        logger.debug(\"Instantiate result-manager\")\n        self._result_entries = ListResult()\n\n    def __len__(self) -&gt; int:\n\"\"\"\n        Implement __len__ method to count number of results.\n        \"\"\"\n        return len(self._result_entries)\n\n    def add_test_result(self, entry: TestResult) -&gt; None:\n\"\"\"Add a result to the list\n\n        Args:\n            entry (TestResult): TestResult data to add to the report\n        \"\"\"\n        logger.info(f\"add new test result to manager: {entry}\")\n        self._result_entries.append(entry)\n\n    def add_test_results(self, entries: List[TestResult]) -&gt; None:\n\"\"\"Add a list of results to the list\n\n        Args:\n            entries (List[TestResult]): list of TestResult data to add to the report\n        \"\"\"\n        logger.info(f\"add new list of results to manager: {[r.result for r in entries if r is not None]}\")\n        self._result_entries.extend(entries)\n\n    def get_results(self, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n        Expose list of all test results in different format\n\n        Support multiple format:\n          - native: ListResults format\n          - list: a list of TestResult\n          - json: a native JSON format\n\n        Args:\n            output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'.\n\n        Returns:\n            any: List of results.\n        \"\"\"\n        logger.info(f\"retrieve list of result using output_format {output_format}\")\n        if output_format == \"list\":\n            return list(self._result_entries)\n\n        if output_format == \"json\":\n            return json.dumps(pydantic_to_dict(self._result_entries), indent=4)\n\n        # Default return for native format.\n        return self._result_entries\n\n    def get_result_by_test(self, test_name: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n        Get list of test result for a given test.\n\n        Args:\n            test_name (str): Test name to use to filter results\n            output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n        Returns:\n            list[TestResult]: List of results related to the test.\n        \"\"\"\n        logger.info(f\"retrieve list of result using output_format {output_format} for test {test_name}\")\n        if output_format == \"list\":\n            return [result for result in self._result_entries if str(result.test) == test_name]\n\n        result_manager_filtered = ListResult()\n        for result in self._result_entries:\n            if result.test == test_name:\n                result_manager_filtered.append(result)\n        return result_manager_filtered\n\n    def get_result_by_host(self, host_ip: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n        Get list of test result for a given host.\n\n        Args:\n            host_ip (str): IP Address of the host to use to filter results.\n            output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n        Returns:\n            Any: List of results related to the host.\n        \"\"\"\n        logger.info(f\"retrieve list of result using output_format {output_format} for host {host_ip}\")\n        if output_format == \"list\":\n            return [result for result in self._result_entries if str(result.name) == host_ip]\n\n        result_manager_filtered = ListResult()\n        for result in self._result_entries:\n            if str(result.name) == host_ip:\n                result_manager_filtered.append(result)\n        return result_manager_filtered\n\n    def get_testcases(self) -&gt; List[str]:\n\"\"\"\n        Get list of name of all test cases in current manager.\n\n        Returns:\n            List[str]: List of names for all tests.\n        \"\"\"\n        logger.info(\"build list of testcases registered in result-manager\")\n        result_list = []\n        for testcase in self._result_entries:\n            if str(testcase.test) not in result_list:\n                result_list.append(str(testcase.test))\n        logger.debug(f\"list of tests name: {result_list}\")\n        return result_list\n\n    def get_hosts(self) -&gt; List[str]:\n\"\"\"\n        Get list of IP addresses in current manager.\n\n        Returns:\n            List[str]: List of IP addresses.\n        \"\"\"\n        logger.info(\"build list of host ip registered in result-manager\")\n        result_list = []\n        for testcase in self._result_entries:\n            if str(testcase.name) not in result_list:\n                result_list.append(str(testcase.name))\n        logger.debug(f\"list of tests name: {result_list}\")\n        return result_list\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Class constructor.\"\"\"\n    logger.debug(\"Instantiate result-manager\")\n    self._result_entries = ListResult()\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.__len__","title":"<code>__len__()</code>","text":"<p>Implement len method to count number of results.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"\n    Implement __len__ method to count number of results.\n    \"\"\"\n    return len(self._result_entries)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_result","title":"<code>add_test_result(entry)</code>","text":"<p>Add a result to the list</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>TestResult</code> <p>TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_result(self, entry: TestResult) -&gt; None:\n\"\"\"Add a result to the list\n\n    Args:\n        entry (TestResult): TestResult data to add to the report\n    \"\"\"\n    logger.info(f\"add new test result to manager: {entry}\")\n    self._result_entries.append(entry)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.add_test_results","title":"<code>add_test_results(entries)</code>","text":"<p>Add a list of results to the list</p> <p>Parameters:</p> Name Type Description Default <code>entries</code> <code>List[TestResult]</code> <p>list of TestResult data to add to the report</p> required Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def add_test_results(self, entries: List[TestResult]) -&gt; None:\n\"\"\"Add a list of results to the list\n\n    Args:\n        entries (List[TestResult]): list of TestResult data to add to the report\n    \"\"\"\n    logger.info(f\"add new list of results to manager: {[r.result for r in entries if r is not None]}\")\n    self._result_entries.extend(entries)\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_hosts","title":"<code>get_hosts()</code>","text":"<p>Get list of IP addresses in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of IP addresses.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_hosts(self) -&gt; List[str]:\n\"\"\"\n    Get list of IP addresses in current manager.\n\n    Returns:\n        List[str]: List of IP addresses.\n    \"\"\"\n    logger.info(\"build list of host ip registered in result-manager\")\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.name) not in result_list:\n            result_list.append(str(testcase.name))\n    logger.debug(f\"list of tests name: {result_list}\")\n    return result_list\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_host","title":"<code>get_result_by_host(host_ip, output_format='native')</code>","text":"<p>Get list of test result for a given host.</p> <p>Parameters:</p> Name Type Description Default <code>host_ip</code> <code>str</code> <p>IP Address of the host to use to filter results.</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>List of results related to the host.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_host(self, host_ip: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given host.\n\n    Args:\n        host_ip (str): IP Address of the host to use to filter results.\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        Any: List of results related to the host.\n    \"\"\"\n    logger.info(f\"retrieve list of result using output_format {output_format} for host {host_ip}\")\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.name) == host_ip]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if str(result.name) == host_ip:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_result_by_test","title":"<code>get_result_by_test(test_name, output_format='native')</code>","text":"<p>Get list of test result for a given test.</p> <p>Parameters:</p> Name Type Description Default <code>test_name</code> <code>str</code> <p>Test name to use to filter results</p> required <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Type Description <code>Any</code> <p>list[TestResult]: List of results related to the test.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_result_by_test(self, test_name: str, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Get list of test result for a given test.\n\n    Args:\n        test_name (str): Test name to use to filter results\n        output_format (str, optional): format selector. Can be either native/list. Defaults to 'native'.\n\n    Returns:\n        list[TestResult]: List of results related to the test.\n    \"\"\"\n    logger.info(f\"retrieve list of result using output_format {output_format} for test {test_name}\")\n    if output_format == \"list\":\n        return [result for result in self._result_entries if str(result.test) == test_name]\n\n    result_manager_filtered = ListResult()\n    for result in self._result_entries:\n        if result.test == test_name:\n            result_manager_filtered.append(result)\n    return result_manager_filtered\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_results","title":"<code>get_results(output_format='native')</code>","text":"<p>Expose list of all test results in different format</p> Support multiple format <ul> <li>native: ListResults format</li> <li>list: a list of TestResult</li> <li>json: a native JSON format</li> </ul> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>str</code> <p>format selector. Can be either native/list/json. Defaults to \u2018native\u2019.</p> <code>'native'</code> <p>Returns:</p> Name Type Description <code>any</code> <code>Any</code> <p>List of results.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_results(self, output_format: str = \"native\") -&gt; Any:\n\"\"\"\n    Expose list of all test results in different format\n\n    Support multiple format:\n      - native: ListResults format\n      - list: a list of TestResult\n      - json: a native JSON format\n\n    Args:\n        output_format (str, optional): format selector. Can be either native/list/json. Defaults to 'native'.\n\n    Returns:\n        any: List of results.\n    \"\"\"\n    logger.info(f\"retrieve list of result using output_format {output_format}\")\n    if output_format == \"list\":\n        return list(self._result_entries)\n\n    if output_format == \"json\":\n        return json.dumps(pydantic_to_dict(self._result_entries), indent=4)\n\n    # Default return for native format.\n    return self._result_entries\n</code></pre>"},{"location":"api/result_manager/#anta.result_manager.ResultManager.get_testcases","title":"<code>get_testcases()</code>","text":"<p>Get list of name of all test cases in current manager.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of names for all tests.</p> Source code in <code>anta/result_manager/__init__.py</code> <pre><code>def get_testcases(self) -&gt; List[str]:\n\"\"\"\n    Get list of name of all test cases in current manager.\n\n    Returns:\n        List[str]: List of names for all tests.\n    \"\"\"\n    logger.info(\"build list of testcases registered in result-manager\")\n    result_list = []\n    for testcase in self._result_entries:\n        if str(testcase.test) not in result_list:\n            result_list.append(str(testcase.test))\n    logger.debug(f\"list of tests name: {result_list}\")\n    return result_list\n</code></pre>"},{"location":"api/result_manager_models/","title":"Result Manager models","text":""},{"location":"api/result_manager_models/#testresult-entry","title":"TestResult Entry","text":"<p>         Bases: <code>BaseModel</code></p> <p>Describe the result of a test from a single device.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Device name where the test has run.</p> <code>test</code> <code>str</code> <p>Test name runs on the device.</p> <code>test_category</code> <code>List[str]</code> <p>List of test categories the test belongs to.</p> <code>test_description</code> <code>str</code> <p>Test description.</p> <code>results</code> <code>str</code> <p>Result of the test. Can be one of [\u201cunset\u201d, \u201csuccess\u201d, \u201cfailure\u201d, \u201cerror\u201d, \u201cskipped\u201d].</p> <code>message</code> <code>str</code> <p>Message to report after the test if any.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>class TestResult(BaseModel):\n\"\"\"\n    Describe the result of a test from a single device.\n\n    Attributes:\n        name (str): Device name where the test has run.\n        test (str): Test name runs on the device.\n        test_category (List[str]): List of test categories the test belongs to.\n        test_description (str): Test description.\n        results (str): Result of the test. Can be one of [\"unset\", \"success\", \"failure\", \"error\", \"skipped\"].\n        message (str, optional): Message to report after the test if any.\n    \"\"\"\n\n    name: str\n    test: str\n    test_category: List[str]\n    test_description: str\n    result: str = \"unset\"\n    messages: List[str] = []\n\n    @classmethod\n    @validator(\"result\", allow_reuse=True)\n    def name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n        Status validator\n\n        Validate status is a supported one\n\n        Args:\n            v (str): User defined status\n\n        Raises:\n            ValueError: If status is unsupported\n\n        Returns:\n            str: status value\n        \"\"\"\n        if v not in RESULT_OPTIONS:\n            raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n        return v\n\n    def is_success(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to success\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"success\", message)\n\n    def is_failure(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to failure\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"failure\", message)\n\n    def is_skipped(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to skipped\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"skipped\", message)\n\n    def is_error(self, message: str = \"\") -&gt; bool:\n\"\"\"\n        Helper to set status to error\n\n        Args:\n            message (str): Optional message related to the test\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        return self._set_status(\"error\", message)\n\n    def _set_status(self, status: str, message: str = \"\") -&gt; bool:\n\"\"\"\n        Set status and insert optional message\n\n        Args:\n            status (str): status of the test\n            message (str): optional message\n\n        Returns:\n            bool: Always true\n        \"\"\"\n        self.result = status\n        if message != \"\":\n            self.messages.append(message)\n        return True\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_error","title":"<code>is_error(message='')</code>","text":"<p>Helper to set status to error</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_error(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to error\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"error\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_failure","title":"<code>is_failure(message='')</code>","text":"<p>Helper to set status to failure</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_failure(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to failure\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"failure\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_skipped","title":"<code>is_skipped(message='')</code>","text":"<p>Helper to set status to skipped</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_skipped(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to skipped\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"skipped\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.is_success","title":"<code>is_success(message='')</code>","text":"<p>Helper to set status to success</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Optional message related to the test</p> <code>''</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always true</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def is_success(self, message: str = \"\") -&gt; bool:\n\"\"\"\n    Helper to set status to success\n\n    Args:\n        message (str): Optional message related to the test\n\n    Returns:\n        bool: Always true\n    \"\"\"\n    return self._set_status(\"success\", message)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.TestResult.name_must_be_in","title":"<code>name_must_be_in(v)</code>  <code>classmethod</code>","text":"<p>Status validator</p> <p>Validate status is a supported one</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>User defined status</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If status is unsupported</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>status value</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>@classmethod\n@validator(\"result\", allow_reuse=True)\ndef name_must_be_in(cls, v: str) -&gt; str:\n\"\"\"\n    Status validator\n\n    Validate status is a supported one\n\n    Args:\n        v (str): User defined status\n\n    Raises:\n        ValueError: If status is unsupported\n\n    Returns:\n        str: status value\n    \"\"\"\n    if v not in RESULT_OPTIONS:\n        raise ValueError(f\"must be one of {RESULT_OPTIONS}\")\n    return v\n</code></pre>"},{"location":"api/result_manager_models/#listresult","title":"ListResult","text":"<p>         Bases: <code>BaseModel</code></p> <p>List result for all tests on all devices.</p> <p>Attributes:</p> Name Type Description <code>__root__</code> <code>List[TestResult]</code> <p>A list of TestResult objects.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>class ListResult(BaseModel):\n\"\"\"\n    List result for all tests on all devices.\n\n    Attributes:\n        __root__ (List[TestResult]): A list of TestResult objects.\n    \"\"\"\n\n    # pylint: disable=R0801\n\n    __root__: List[TestResult] = []\n\n    def extend(self, values: List[TestResult]) -&gt; None:\n\"\"\"Add support for extend method.\"\"\"\n        self.__root__.extend(values)\n\n    def append(self, value: TestResult) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n        self.__root__.append(value)\n\n    def __iter__(self) -&gt; Iterator[TestResult]:\n\"\"\"Use custom iter method.\"\"\"\n        # TODO - mypy is not happy because we overwrite BaseModel.__iter__\n        # return type and are breaking Liskov Substitution Principle.\n        return iter(self.__root__)\n\n    def __getitem__(self, item: int) -&gt; TestResult:\n\"\"\"Use custom getitem method.\"\"\"\n        return self.__root__[item]\n\n    def __len__(self) -&gt; int:\n\"\"\"Support for length of __root__\"\"\"\n        return len(self.__root__)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Use custom getitem method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def __getitem__(self, item: int) -&gt; TestResult:\n\"\"\"Use custom getitem method.\"\"\"\n    return self.__root__[item]\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.__iter__","title":"<code>__iter__()</code>","text":"<p>Use custom iter method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def __iter__(self) -&gt; Iterator[TestResult]:\n\"\"\"Use custom iter method.\"\"\"\n    # TODO - mypy is not happy because we overwrite BaseModel.__iter__\n    # return type and are breaking Liskov Substitution Principle.\n    return iter(self.__root__)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.__len__","title":"<code>__len__()</code>","text":"<p>Support for length of root</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def __len__(self) -&gt; int:\n\"\"\"Support for length of __root__\"\"\"\n    return len(self.__root__)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.append","title":"<code>append(value)</code>","text":"<p>Add support for append method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def append(self, value: TestResult) -&gt; None:\n\"\"\"Add support for append method.\"\"\"\n    self.__root__.append(value)\n</code></pre>"},{"location":"api/result_manager_models/#anta.result_manager.models.ListResult.extend","title":"<code>extend(values)</code>","text":"<p>Add support for extend method.</p> Source code in <code>anta/result_manager/models.py</code> <pre><code>def extend(self, values: List[TestResult]) -&gt; None:\n\"\"\"Add support for extend method.\"\"\"\n    self.__root__.extend(values)\n</code></pre>"},{"location":"api/tests.aaa/","title":"AAA","text":""},{"location":"api/tests.aaa/#anta-catalog-for-aaa-tests","title":"ANTA catalog for AAA tests","text":"<p>Test functions related to the EOS various AAA settings</p>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods","title":"<code>VerifyAcctConsoleMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.</li> <li>skipped: The test will be skipped if the AAA accounting console method list or accounting type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctConsoleMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting console method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting console method list is NOT matching in the configured accounting types.\n        * skipped: The test will be skipped if the AAA accounting console method list or accounting type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAcctConsoleMethods\"\n    description = \"Verifies the AAA accounting console method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaTestCommand(command=\"show aaa methods accounting\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAcctConsoleMethods validation.\n\n        Args:\n            methods: List of AAA accounting console methods. Methods should be in the right order.\n            auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        not_matching = []\n        not_configured = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AcctMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if not command_output[auth_type_key][method_key].get(\"consoleAction\"):\n                not_configured.append(auth_type)\n\n            if command_output[auth_type_key][method_key][\"consoleMethods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not_configured:\n            self.result.is_failure(f\"AAA console accounting is not configured for {not_configured}\")\n            return\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting console methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctConsoleMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAcctConsoleMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA accounting console methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of accounting types to verify. List elements must be: commands, exec, system, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAcctConsoleMethods validation.\n\n    Args:\n        methods: List of AAA accounting console methods. Methods should be in the right order.\n        auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    not_matching = []\n    not_configured = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AcctMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if not command_output[auth_type_key][method_key].get(\"consoleAction\"):\n            not_configured.append(auth_type)\n\n        if command_output[auth_type_key][method_key][\"consoleMethods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not_configured:\n        self.result.is_failure(f\"AAA console accounting is not configured for {not_configured}\")\n        return\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA accounting console methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods","title":"<code>VerifyAcctDefaultMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.</li> <li>failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.</li> <li>skipped: The test will be skipped if the AAA accounting default method list or accounting type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAcctDefaultMethods(AntaTest):\n\"\"\"\n    Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA accounting default method list is matching in the configured accounting types.\n        * failure: The test will fail if the provided AAA accounting default method list is NOT matching in the configured accounting types.\n        * skipped: The test will be skipped if the AAA accounting default method list or accounting type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAcctDefaultMethods\"\n    description = \"Verifies the AAA accounting default method lists for different accounting types (system, exec, commands, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaTestCommand(command=\"show aaa methods accounting\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAcctDefaultMethods validation.\n\n        Args:\n            methods: List of AAA accounting default methods. Methods should be in the right order.\n            auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        not_matching = []\n        not_configured = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AcctMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if not command_output[auth_type_key][method_key].get(\"defaultAction\"):\n                not_configured.append(auth_type)\n\n            if command_output[auth_type_key][method_key][\"defaultMethods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not_configured:\n            self.result.is_failure(f\"AAA default accounting is not configured for {not_configured}\")\n            return\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA accounting default methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAcctDefaultMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAcctDefaultMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA accounting default methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of accounting types to verify. List elements must be: commands, exec, system, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAcctDefaultMethods validation.\n\n    Args:\n        methods: List of AAA accounting default methods. Methods should be in the right order.\n        auth_types: List of accounting types to verify. List elements must be: commands, exec, system, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"system\", \"exec\", \"commands\", \"dot1x\"])\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    not_matching = []\n    not_configured = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AcctMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if not command_output[auth_type_key][method_key].get(\"defaultAction\"):\n            not_configured.append(auth_type)\n\n        if command_output[auth_type_key][method_key][\"defaultMethods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not_configured:\n        self.result.is_failure(f\"AAA default accounting is not configured for {not_configured}\")\n        return\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA accounting default methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods","title":"<code>VerifyAuthenMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.</li> <li>failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.</li> <li>skipped: The test will be skipped if the AAA authentication method list or authentication type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthenMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authentication method list is matching in the configured authentication types.\n        * failure: The test will fail if the provided AAA authentication method list is NOT matching in the configured authentication types.\n        * skipped: The test will be skipped if the AAA authentication method list or authentication type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAuthenMethods\"\n    description = \"Verifies the AAA authentication method lists for different authentication types (login, enable, dot1x).\"\n    categories = [\"aaa\"]\n    commands = [AntaTestCommand(command=\"show aaa methods authentication\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAuthenMethods validation.\n\n        Args:\n            methods: List of AAA authentication methods. Methods should be in the right order.\n            auth_types: List of authentication types to verify. List elements must be: login, enable, dot1x.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        methods_with_group = _check_group_methods(methods)\n\n        _check_auth_type(auth_types, [\"login\", \"enable\", \"dot1x\"])\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        not_matching = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AuthenMethods\"\n\n            if auth_type_key == \"loginAuthenMethods\":\n                if not command_output[auth_type_key].get(\"login\"):\n                    self.result.is_failure(\"AAA authentication methods are not configured for login console\")\n                    return\n\n                if command_output[auth_type_key][\"login\"][\"methods\"] != methods_with_group:\n                    self.result.is_failure(f\"AAA authentication methods {methods} are not matching for login console\")\n                    return\n\n            if command_output[auth_type_key][\"default\"][\"methods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authentication methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthenMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAuthenMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA authentication methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of authentication types to verify. List elements must be: login, enable, dot1x.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAuthenMethods validation.\n\n    Args:\n        methods: List of AAA authentication methods. Methods should be in the right order.\n        auth_types: List of authentication types to verify. List elements must be: login, enable, dot1x.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    methods_with_group = _check_group_methods(methods)\n\n    _check_auth_type(auth_types, [\"login\", \"enable\", \"dot1x\"])\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    not_matching = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AuthenMethods\"\n\n        if auth_type_key == \"loginAuthenMethods\":\n            if not command_output[auth_type_key].get(\"login\"):\n                self.result.is_failure(\"AAA authentication methods are not configured for login console\")\n                return\n\n            if command_output[auth_type_key][\"login\"][\"methods\"] != methods_with_group:\n                self.result.is_failure(f\"AAA authentication methods {methods} are not matching for login console\")\n                return\n\n        if command_output[auth_type_key][\"default\"][\"methods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA authentication methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods","title":"<code>VerifyAuthzMethods</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the AAA authorization method lists for different authorization types (commands, exec).</p> Expected Results <ul> <li>success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.</li> <li>failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.</li> <li>skipped: The test will be skipped if the AAA authentication method list or authorization type list are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyAuthzMethods(AntaTest):\n\"\"\"\n    Verifies the AAA authorization method lists for different authorization types (commands, exec).\n\n    Expected Results:\n        * success: The test will pass if the provided AAA authorization method list is matching in the configured authorization types.\n        * failure: The test will fail if the provided AAA authorization method list is NOT matching in the configured authorization types.\n        * skipped: The test will be skipped if the AAA authentication method list or authorization type list are not provided.\n    \"\"\"\n\n    name = \"VerifyAuthzMethods\"\n    description = \"Verifies the AAA authorization method lists for different authorization types (commands, exec).\"\n    categories = [\"aaa\"]\n    commands = [AntaTestCommand(command=\"show aaa methods authorization\")]\n\n    @AntaTest.anta_test\n    def test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyAuthzMethods validation.\n\n        Args:\n            methods: List of AAA authorization methods. Methods should be in the right order.\n            auth_types: List of authorization types to verify. List elements must be: commands, exec.\n        \"\"\"\n        if not methods or not auth_types:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n            return\n\n        _check_auth_type(auth_types, [\"commands\", \"exec\"])\n\n        methods_with_group = _check_group_methods(methods)\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        not_matching = []\n\n        for auth_type in auth_types:\n            auth_type_key = f\"{auth_type}AuthzMethods\"\n\n            method_key = list(command_output[auth_type_key].keys())[0]\n\n            if command_output[auth_type_key][method_key][\"methods\"] != methods_with_group:\n                not_matching.append(auth_type)\n\n        if not not_matching:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"AAA authorization methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyAuthzMethods.test","title":"<code>test(methods=None, auth_types=None)</code>","text":"<p>Run VerifyAuthzMethods validation.</p> <p>Parameters:</p> Name Type Description Default <code>methods</code> <code>Optional[List[str]]</code> <p>List of AAA authorization methods. Methods should be in the right order.</p> <code>None</code> <code>auth_types</code> <code>Optional[List[str]]</code> <p>List of authorization types to verify. List elements must be: commands, exec.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, methods: Optional[List[str]] = None, auth_types: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyAuthzMethods validation.\n\n    Args:\n        methods: List of AAA authorization methods. Methods should be in the right order.\n        auth_types: List of authorization types to verify. List elements must be: commands, exec.\n    \"\"\"\n    if not methods or not auth_types:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because methods or auth_types were not supplied\")\n        return\n\n    _check_auth_type(auth_types, [\"commands\", \"exec\"])\n\n    methods_with_group = _check_group_methods(methods)\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    not_matching = []\n\n    for auth_type in auth_types:\n        auth_type_key = f\"{auth_type}AuthzMethods\"\n\n        method_key = list(command_output[auth_type_key].keys())[0]\n\n        if command_output[auth_type_key][method_key][\"methods\"] != methods_with_group:\n            not_matching.append(auth_type)\n\n    if not not_matching:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"AAA authorization methods {methods} are not matching for {not_matching}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups","title":"<code>VerifyTacacsServerGroups</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the provided TACACS server group(s) are configured.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS server group(s) are configured.</li> <li>failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.</li> <li>skipped: The test will be skipped if TACACS server group(s) are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServerGroups(AntaTest):\n\"\"\"\n    Verifies if the provided TACACS server group(s) are configured.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS server group(s) are configured.\n        * failure: The test will fail if one or all the provided TACACS server group(s) are NOT configured.\n        * skipped: The test will be skipped if TACACS server group(s) are not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsServerGroups\"\n    description = \"Verifies if the provided TACACS server group(s) are configured.\"\n    categories = [\"aaa\"]\n    commands = [AntaTestCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, groups: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTacacsServerGroups validation.\n\n        Args:\n            groups: List of TACACS server group.\n        \"\"\"\n        if not groups:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because groups were not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        tacacs_groups = command_output[\"groups\"]\n\n        if not tacacs_groups:\n            self.result.is_failure(\"No TACACS server group(s) are configured\")\n            return\n\n        not_configured = [group for group in groups if group not in tacacs_groups]\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS server group(s) {not_configured} are not configured\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServerGroups.test","title":"<code>test(groups=None)</code>","text":"<p>Run VerifyTacacsServerGroups validation.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>Optional[List[str]]</code> <p>List of TACACS server group.</p> <code>None</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, groups: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTacacsServerGroups validation.\n\n    Args:\n        groups: List of TACACS server group.\n    \"\"\"\n    if not groups:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because groups were not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    tacacs_groups = command_output[\"groups\"]\n\n    if not tacacs_groups:\n        self.result.is_failure(\"No TACACS server group(s) are configured\")\n        return\n\n    not_configured = [group for group in groups if group not in tacacs_groups]\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"TACACS server group(s) {not_configured} are not configured\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers","title":"<code>VerifyTacacsServers</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies TACACS servers are configured for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if TACACS servers or VRF are not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsServers(AntaTest):\n\"\"\"\n    Verifies TACACS servers are configured for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS servers are configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS servers are NOT configured in the specified VRF.\n        * skipped: The test will be skipped if TACACS servers or VRF are not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsServers\"\n    description = \"Verifies TACACS servers are configured for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaTestCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, servers: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyTacacsServers validation.\n\n        Args:\n            servers: List of TACACS servers IP addresses.\n            vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n        \"\"\"\n        if not servers or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because servers or vrf were not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        tacacs_servers = command_output[\"tacacsServers\"]\n\n        if not tacacs_servers:\n            self.result.is_failure(\"No TACACS servers are configured\")\n            return\n\n        not_configured = [\n            server\n            for server in servers\n            if not any(server == tacacs_server[\"serverInfo\"][\"hostname\"] and vrf == tacacs_server[\"serverInfo\"][\"vrf\"] for tacacs_server in tacacs_servers)\n        ]\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"TACACS servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsServers.test","title":"<code>test(servers=None, vrf='default')</code>","text":"<p>Run VerifyTacacsServers validation.</p> <p>Parameters:</p> Name Type Description Default <code>servers</code> <code>Optional[List[str]]</code> <p>List of TACACS servers IP addresses.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport TACACS messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, servers: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyTacacsServers validation.\n\n    Args:\n        servers: List of TACACS servers IP addresses.\n        vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n    \"\"\"\n    if not servers or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because servers or vrf were not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    tacacs_servers = command_output[\"tacacsServers\"]\n\n    if not tacacs_servers:\n        self.result.is_failure(\"No TACACS servers are configured\")\n        return\n\n    not_configured = [\n        server\n        for server in servers\n        if not any(server == tacacs_server[\"serverInfo\"][\"hostname\"] and vrf == tacacs_server[\"serverInfo\"][\"vrf\"] for tacacs_server in tacacs_servers)\n    ]\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"TACACS servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf","title":"<code>VerifyTacacsSourceIntf</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies TACACS source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if source-interface or VRF is not provided.</li> </ul> Source code in <code>anta/tests/aaa.py</code> <pre><code>class VerifyTacacsSourceIntf(AntaTest):\n\"\"\"\n    Verifies TACACS source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided TACACS source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided TACACS source-interface is NOT configured in the specified VRF.\n        * skipped: The test will be skipped if source-interface or VRF is not provided.\n    \"\"\"\n\n    name = \"VerifyTacacsSourceIntf\"\n    description = \"Verifies TACACS source-interface for a specified VRF.\"\n    categories = [\"aaa\"]\n    commands = [AntaTestCommand(command=\"show tacacs\")]\n\n    @AntaTest.anta_test\n    def test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyTacacsSourceIntf validation.\n\n        Args:\n            intf: Source-interface to use as source IP of TACACS messages.\n            vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n        \"\"\"\n        if not intf or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        try:\n            if command_output[\"srcIntf\"][vrf] == intf:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"Wrong source-interface configured in VRF {vrf}\")\n\n        except KeyError:\n            self.result.is_failure(f\"Source-interface {intf} is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.aaa/#anta.tests.aaa.VerifyTacacsSourceIntf.test","title":"<code>test(intf=None, vrf='default')</code>","text":"<p>Run VerifyTacacsSourceIntf validation.</p> <p>Parameters:</p> Name Type Description Default <code>intf</code> <code>Optional[str]</code> <p>Source-interface to use as source IP of TACACS messages.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport TACACS messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/aaa.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyTacacsSourceIntf validation.\n\n    Args:\n        intf: Source-interface to use as source IP of TACACS messages.\n        vrf: The name of the VRF to transport TACACS messages. Defaults to 'default'.\n    \"\"\"\n    if not intf or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    try:\n        if command_output[\"srcIntf\"][vrf] == intf:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Wrong source-interface configured in VRF {vrf}\")\n\n    except KeyError:\n        self.result.is_failure(f\"Source-interface {intf} is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.configuration/","title":"Configuration","text":""},{"location":"api/tests.configuration/#anta-catalog-for-configuration-tests","title":"ANTA catalog for configuration tests","text":"<p>Test functions related to the device configuration</p>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyRunningConfigDiffs","title":"<code>VerifyRunningConfigDiffs</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no difference between the running-config and the startup-config.</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyRunningConfigDiffs(AntaTest):\n\"\"\"\n    Verifies there is no difference between the running-config and the startup-config.\n    \"\"\"\n\n    name = \"verify_running_config_diffs\"\n    description = \"\"\n    categories = [\"configuration\"]\n    commands = [AntaTestCommand(command=\"show running-config diffs\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyRunningConfigDiffs validation\"\"\"\n        self.logger.debug(f\"self.instance_commands is {self.instance_commands}\")\n        command_output = self.instance_commands[0].output\n        self.logger.debug(f\"command_output is {command_output}\")\n        if command_output is None or command_output == \"\":\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            self.result.is_failure(str(command_output))\n        self.logger.debug(f\"result is {self.result}\")\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyRunningConfigDiffs.test","title":"<code>test()</code>","text":"<p>Run VerifyRunningConfigDiffs validation</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyRunningConfigDiffs validation\"\"\"\n    self.logger.debug(f\"self.instance_commands is {self.instance_commands}\")\n    command_output = self.instance_commands[0].output\n    self.logger.debug(f\"command_output is {command_output}\")\n    if command_output is None or command_output == \"\":\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        self.result.is_failure(str(command_output))\n    self.logger.debug(f\"result is {self.result}\")\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyZeroTouch","title":"<code>VerifyZeroTouch</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies ZeroTouch is disabled.</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>class VerifyZeroTouch(AntaTest):\n\"\"\"\n    Verifies ZeroTouch is disabled.\n    \"\"\"\n\n    name = \"verify_zerotouch\"\n    description = \"Verifies ZeroTouch is disabled.\"\n    categories = [\"configuration\"]\n    commands = [AntaTestCommand(command=\"show zerotouch\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyZeroTouch validation\"\"\"\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = self.instance_commands[0].output\n        self.logger.debug(f\"dataset is: {command_output}\")\n        assert isinstance(command_output, dict)\n        if command_output[\"mode\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"ZTP is NOT disabled\")\n</code></pre>"},{"location":"api/tests.configuration/#anta.tests.configuration.VerifyZeroTouch.test","title":"<code>test()</code>","text":"<p>Run VerifyZeroTouch validation</p> Source code in <code>anta/tests/configuration.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyZeroTouch validation\"\"\"\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = self.instance_commands[0].output\n    self.logger.debug(f\"dataset is: {command_output}\")\n    assert isinstance(command_output, dict)\n    if command_output[\"mode\"] == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"ZTP is NOT disabled\")\n</code></pre>"},{"location":"api/tests.field_notices/","title":"Field Notices","text":""},{"location":"api/tests.field_notices/#anta-catalog-for-field-notices-tests","title":"ANTA catalog for Field Notices tests","text":"<p>Test functions to flag field notices</p>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice44Resolution","title":"<code>VerifyFieldNotice44Resolution</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization).</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice44Resolution(AntaTest):\n\"\"\"\n    Verifies the device is using an Aboot version that fix the bug discussed\n    in the field notice 44 (Aboot manages system settings prior to EOS initialization).\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/8756-field-notice-44\n    \"\"\"\n\n    name = \"VerifyFieldNotice44Resolution\"\n    description = (\n        \"Verifies the device is using an Aboot version that fix the bug discussed in the field notice 44 (Aboot manages system settings prior to EOS initialization)\"\n    )\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaTestCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice44Resolution validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        devices = [\n            \"DCS-7010T-48\",\n            \"DCS-7010T-48-DC\",\n            \"DCS-7050TX-48\",\n            \"DCS-7050TX-64\",\n            \"DCS-7050TX-72\",\n            \"DCS-7050TX-72Q\",\n            \"DCS-7050TX-96\",\n            \"DCS-7050TX2-128\",\n            \"DCS-7050SX-64\",\n            \"DCS-7050SX-72\",\n            \"DCS-7050SX-72Q\",\n            \"DCS-7050SX2-72Q\",\n            \"DCS-7050SX-96\",\n            \"DCS-7050SX2-128\",\n            \"DCS-7050QX-32S\",\n            \"DCS-7050QX2-32S\",\n            \"DCS-7050SX3-48YC12\",\n            \"DCS-7050CX3-32S\",\n            \"DCS-7060CX-32S\",\n            \"DCS-7060CX2-32S\",\n            \"DCS-7060SX2-48YC6\",\n            \"DCS-7160-48YC6\",\n            \"DCS-7160-48TC6\",\n            \"DCS-7160-32CQ\",\n            \"DCS-7280SE-64\",\n            \"DCS-7280SE-68\",\n            \"DCS-7280SE-72\",\n            \"DCS-7150SC-24-CLD\",\n            \"DCS-7150SC-64-CLD\",\n            \"DCS-7020TR-48\",\n            \"DCS-7020TRA-48\",\n            \"DCS-7020SR-24C2\",\n            \"DCS-7020SRG-24C2\",\n            \"DCS-7280TR-48C6\",\n            \"DCS-7280TRA-48C6\",\n            \"DCS-7280SR-48C6\",\n            \"DCS-7280SRA-48C6\",\n            \"DCS-7280SRAM-48C6\",\n            \"DCS-7280SR2K-48C6-M\",\n            \"DCS-7280SR2-48YC6\",\n            \"DCS-7280SR2A-48YC6\",\n            \"DCS-7280SRM-40CX2\",\n            \"DCS-7280QR-C36\",\n            \"DCS-7280QRA-C36S\",\n        ]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n\n        model = cast(str, command_output[\"modelName\"])\n        # TODO this list could be a regex\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"device is not impacted by FN044\")\n            return\n\n        for component in command_output[\"details\"][\"components\"]:\n            if component[\"name\"] == \"Aboot\":\n                aboot_version = component[\"version\"].split(\"-\")[2]\n        self.result.is_success()\n        if aboot_version.startswith(\"4.0.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"4.1.\") and int(aboot_version.split(\".\")[2]) &lt; 1:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.0.\") and int(aboot_version.split(\".\")[2]) &lt; 9:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n        elif aboot_version.startswith(\"6.1.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n            self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice44Resolution.test","title":"<code>test()</code>","text":"<p>Run VerifyFieldNotice44Resolution validation</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice44Resolution validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    devices = [\n        \"DCS-7010T-48\",\n        \"DCS-7010T-48-DC\",\n        \"DCS-7050TX-48\",\n        \"DCS-7050TX-64\",\n        \"DCS-7050TX-72\",\n        \"DCS-7050TX-72Q\",\n        \"DCS-7050TX-96\",\n        \"DCS-7050TX2-128\",\n        \"DCS-7050SX-64\",\n        \"DCS-7050SX-72\",\n        \"DCS-7050SX-72Q\",\n        \"DCS-7050SX2-72Q\",\n        \"DCS-7050SX-96\",\n        \"DCS-7050SX2-128\",\n        \"DCS-7050QX-32S\",\n        \"DCS-7050QX2-32S\",\n        \"DCS-7050SX3-48YC12\",\n        \"DCS-7050CX3-32S\",\n        \"DCS-7060CX-32S\",\n        \"DCS-7060CX2-32S\",\n        \"DCS-7060SX2-48YC6\",\n        \"DCS-7160-48YC6\",\n        \"DCS-7160-48TC6\",\n        \"DCS-7160-32CQ\",\n        \"DCS-7280SE-64\",\n        \"DCS-7280SE-68\",\n        \"DCS-7280SE-72\",\n        \"DCS-7150SC-24-CLD\",\n        \"DCS-7150SC-64-CLD\",\n        \"DCS-7020TR-48\",\n        \"DCS-7020TRA-48\",\n        \"DCS-7020SR-24C2\",\n        \"DCS-7020SRG-24C2\",\n        \"DCS-7280TR-48C6\",\n        \"DCS-7280TRA-48C6\",\n        \"DCS-7280SR-48C6\",\n        \"DCS-7280SRA-48C6\",\n        \"DCS-7280SRAM-48C6\",\n        \"DCS-7280SR2K-48C6-M\",\n        \"DCS-7280SR2-48YC6\",\n        \"DCS-7280SR2A-48YC6\",\n        \"DCS-7280SRM-40CX2\",\n        \"DCS-7280QR-C36\",\n        \"DCS-7280QRA-C36S\",\n    ]\n    variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n\n    model = cast(str, command_output[\"modelName\"])\n    # TODO this list could be a regex\n    for variant in variants:\n        model = model.replace(variant, \"\")\n    if model not in devices:\n        self.result.is_skipped(\"device is not impacted by FN044\")\n        return\n\n    for component in command_output[\"details\"][\"components\"]:\n        if component[\"name\"] == \"Aboot\":\n            aboot_version = component[\"version\"].split(\"-\")[2]\n    self.result.is_success()\n    if aboot_version.startswith(\"4.0.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"4.1.\") and int(aboot_version.split(\".\")[2]) &lt; 1:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"6.0.\") and int(aboot_version.split(\".\")[2]) &lt; 9:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n    elif aboot_version.startswith(\"6.1.\") and int(aboot_version.split(\".\")[2]) &lt; 7:\n        self.result.is_failure(f\"device is running incorrect version of aboot ({aboot_version})\")\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice72Resolution","title":"<code>VerifyFieldNotice72Resolution</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.</p> <p>https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>class VerifyFieldNotice72Resolution(AntaTest):\n\"\"\"\n    Checks if the device is potentially exposed to Field Notice 72, and if the issue has been mitigated.\n\n    https://www.arista.com/en/support/advisories-notices/field-notice/17410-field-notice-0072\n    \"\"\"\n\n    name = \"VerifyFieldNotice72Resolution\"\n    description = \"Verifies if the device has exposeure to FN72, and if the issue has been mitigated\"\n    categories = [\"field notices\", \"software\"]\n    commands = [AntaTestCommand(command=\"show version detail\")]\n\n    # TODO maybe implement ONLY ON PLATFORMS instead\n    @skip_on_platforms([\"cEOSLab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice72Resolution validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        devices = [\"DCS-7280SR3-48YC8\", \"DCS-7280SR3K-48YC8\"]\n        variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n        model = cast(str, command_output[\"modelName\"])\n\n        for variant in variants:\n            model = model.replace(variant, \"\")\n        if model not in devices:\n            self.result.is_skipped(\"Platform is not impacted by FN072\")\n            return\n\n        serial = command_output[\"serialNumber\"]\n        number = int(serial[3:7])\n\n        if \"JPE\" not in serial and \"JAS\" not in serial:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JPE\" in serial and number &gt;= 2131:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JPE\" in serial and number &gt;= 2134:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        if model == \"DCS-7280SR3K-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n            self.result.is_skipped(\"Device not exposed\")\n            return\n\n        # Because each of the if checks above will return if taken, we only run the long\n        # check if we get this far\n        for entry in command_output[\"details\"][\"components\"]:\n            if entry[\"name\"] == \"FixedSystemvrm1\":\n                if int(entry[\"version\"]) &lt; 7:\n                    self.result.is_failure(\"Device is exposed to FN72\")\n                else:\n                    self.result.is_success(\"FN72 is mitigated\")\n                return\n        # We should never hit this point\n        self.result.is_error(\"Error in running test - FixedSystemvrm1 not found\")\n        return\n</code></pre>"},{"location":"api/tests.field_notices/#anta.tests.field_notices.VerifyFieldNotice72Resolution.test","title":"<code>test()</code>","text":"<p>Run VerifyFieldNotice72Resolution validation</p> Source code in <code>anta/tests/field_notices.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyFieldNotice72Resolution validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    devices = [\"DCS-7280SR3-48YC8\", \"DCS-7280SR3K-48YC8\"]\n    variants = [\"-SSD-F\", \"-SSD-R\", \"-M-F\", \"-M-R\", \"-F\", \"-R\"]\n    model = cast(str, command_output[\"modelName\"])\n\n    for variant in variants:\n        model = model.replace(variant, \"\")\n    if model not in devices:\n        self.result.is_skipped(\"Platform is not impacted by FN072\")\n        return\n\n    serial = command_output[\"serialNumber\"]\n    number = int(serial[3:7])\n\n    if \"JPE\" not in serial and \"JAS\" not in serial:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3-48YC8\" and \"JPE\" in serial and number &gt;= 2131:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3K-48YC8\" and \"JPE\" in serial and number &gt;= 2134:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    if model == \"DCS-7280SR3K-48YC8\" and \"JAS\" in serial and number &gt;= 2041:\n        self.result.is_skipped(\"Device not exposed\")\n        return\n\n    # Because each of the if checks above will return if taken, we only run the long\n    # check if we get this far\n    for entry in command_output[\"details\"][\"components\"]:\n        if entry[\"name\"] == \"FixedSystemvrm1\":\n            if int(entry[\"version\"]) &lt; 7:\n                self.result.is_failure(\"Device is exposed to FN72\")\n            else:\n                self.result.is_success(\"FN72 is mitigated\")\n            return\n    # We should never hit this point\n    self.result.is_error(\"Error in running test - FixedSystemvrm1 not found\")\n    return\n</code></pre>"},{"location":"api/tests.hardware/","title":"Hardware","text":""},{"location":"api/tests.hardware/#anta-catalog-for-hardware-tests","title":"ANTA catalog for hardware tests","text":"<p>Test functions related to the hardware or environement</p>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyAdverseDrops","title":"<code>VerifyAdverseDrops</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no adverse drops on DCS7280E and DCS7500E.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyAdverseDrops(AntaTest):\n\"\"\"\n    Verifies there is no adverse drops on DCS7280E and DCS7500E.\n    \"\"\"\n\n    name = \"VerifyAdverseDrops\"\n    description = \"Verifies there is no adverse drops on DCS7280E and DCS7500E\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show hardware counter drop\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyAdverseDrops validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        total_adverse_drop = command_output[\"totalAdverseDrops\"] if \"totalAdverseDrops\" in command_output.keys() else \"\"\n        if total_adverse_drop == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device TotalAdverseDrops counter is {total_adverse_drop}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyAdverseDrops.test","title":"<code>test()</code>","text":"<p>Run VerifyAdverseDrops validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyAdverseDrops validation\"\"\"\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    total_adverse_drop = command_output[\"totalAdverseDrops\"] if \"totalAdverseDrops\" in command_output.keys() else \"\"\n    if total_adverse_drop == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device TotalAdverseDrops counter is {total_adverse_drop}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling","title":"<code>VerifyEnvironmentCooling</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the fans status is in the accepted states list.</p> <p>Default accepted states list is [\u2018ok\u2019]</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentCooling(AntaTest):\n\"\"\"\n    Verifies the fans status is in the accepted states list.\n\n    Default accepted states list is ['ok']\n    \"\"\"\n\n    name = \"VerifyEnvironmentCooling\"\n    description = \"Verifies the fans status is OK for fans\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n        if accepted_states is None:\n            accepted_states = [\"ok\"]\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        self.result.is_success()\n        # First go through power supplies fans\n        for power_supply in command_output.get(\"powerSupplySlots\", []):\n            for fan in power_supply.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in accepted_states:\n                    if self.result.result == \"success\":\n                        self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                    self.result.is_failure(f\"Fan {fan['label']} on PowerSupply {power_supply['label']} has state '{state}'.\")\n        # Then go through Fan Trays\n        for fan_tray in command_output.get(\"fanTraySlots\", []):\n            for fan in fan_tray.get(\"fans\", []):\n                if (state := fan[\"status\"]) not in accepted_states:\n                    if self.result.result == \"success\":\n                        self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                    self.result.is_failure(f\"Fan {fan['label']} on Fan Tray {fan_tray['label']} has state '{state}'.\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentCooling.test","title":"<code>test(accepted_states=None)</code>","text":"<p>Run VerifyEnvironmentCooling validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n    if accepted_states is None:\n        accepted_states = [\"ok\"]\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    self.result.is_success()\n    # First go through power supplies fans\n    for power_supply in command_output.get(\"powerSupplySlots\", []):\n        for fan in power_supply.get(\"fans\", []):\n            if (state := fan[\"status\"]) not in accepted_states:\n                if self.result.result == \"success\":\n                    self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                self.result.is_failure(f\"Fan {fan['label']} on PowerSupply {power_supply['label']} has state '{state}'.\")\n    # Then go through Fan Trays\n    for fan_tray in command_output.get(\"fanTraySlots\", []):\n        for fan in fan_tray.get(\"fans\", []):\n            if (state := fan[\"status\"]) not in accepted_states:\n                if self.result.result == \"success\":\n                    self.result.is_failure(f\"Some fans state are not in the accepted list: {accepted_states}.\")\n                self.result.is_failure(f\"Fan {fan['label']} on Fan Tray {fan_tray['label']} has state '{state}'.\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower","title":"<code>VerifyEnvironmentPower</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the power supplied status is in the accepted states list</p> <p>The default accepted states list is [\u2018ok\u2019]</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentPower(AntaTest):\n\"\"\"\n    Verifies the power supplied status is in the accepted states list\n\n    The default accepted states list is ['ok']\n    \"\"\"\n\n    name = \"VerifyEnvironmentPower\"\n    description = \"Verifies the power supplied status is OK\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show system environment power\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyEnvironmentPower validation\"\"\"\n        if accepted_states is None:\n            accepted_states = [\"ok\"]\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        power_supplies = command_output[\"powerSupplies\"] if \"powerSupplies\" in command_output.keys() else \"{}\"\n        wrong_power_supplies = {\n            powersupply: {\"state\": value[\"state\"]} for powersupply, value in dict(power_supplies).items() if value[\"state\"] not in accepted_states\n        }\n        if not wrong_power_supplies:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following power supplies states are not in the accepted_states list {accepted_states}\")\n            self.result.messages.append(str(wrong_power_supplies))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentPower.test","title":"<code>test(accepted_states=None)</code>","text":"<p>Run VerifyEnvironmentPower validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, accepted_states: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyEnvironmentPower validation\"\"\"\n    if accepted_states is None:\n        accepted_states = [\"ok\"]\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    power_supplies = command_output[\"powerSupplies\"] if \"powerSupplies\" in command_output.keys() else \"{}\"\n    wrong_power_supplies = {\n        powersupply: {\"state\": value[\"state\"]} for powersupply, value in dict(power_supplies).items() if value[\"state\"] not in accepted_states\n    }\n    if not wrong_power_supplies:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following power supplies states are not in the accepted_states list {accepted_states}\")\n        self.result.messages.append(str(wrong_power_supplies))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentSystemCooling","title":"<code>VerifyEnvironmentSystemCooling</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the System Cooling is ok.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyEnvironmentSystemCooling(AntaTest):\n\"\"\"\n    Verifies the System Cooling is ok.\n    \"\"\"\n\n    name = \"VerifyEnvironmentSystemCooling\"\n    description = \"Verifies the fans status is OK for fans\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show system environment cooling\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        sys_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n\n        self.result.is_success()\n        if sys_status != \"coolingOk\":\n            self.result.is_failure(f\"Device System cooling is not OK: {sys_status}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyEnvironmentSystemCooling.test","title":"<code>test()</code>","text":"<p>Run VerifyEnvironmentCooling validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyEnvironmentCooling validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    sys_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n\n    self.result.is_success()\n    if sys_status != \"coolingOk\":\n        self.result.is_failure(f\"Device System cooling is not OK: {sys_status}\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTemperature","title":"<code>VerifyTemperature</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies device temparture is currently OK (temperatureOK).</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTemperature(AntaTest):\n\"\"\"\n    Verifies device temparture is currently OK (temperatureOK).\n    \"\"\"\n\n    name = \"VerifyTemperature\"\n    description = \"Verifies device temparture is currently OK (temperatureOK)\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show system environment temperature\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n        if temperature_status == \"temperatureOk\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTemperature.test","title":"<code>test()</code>","text":"<p>Run VerifyTemperature validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyTemperature validation\"\"\"\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    temperature_status = command_output[\"systemStatus\"] if \"systemStatus\" in command_output.keys() else \"\"\n    if temperature_status == \"temperatureOk\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Device temperature is not OK, systemStatus: {temperature_status }\")\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers","title":"<code>VerifyTransceiversManufacturers</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies Manufacturers of all Transceivers.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversManufacturers(AntaTest):\n\"\"\"\n    Verifies Manufacturers of all Transceivers.\n    \"\"\"\n\n    name = \"verify_transceivers_manufacturers\"\n    description = \"\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show inventory\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyTransceiversManufacturers validation\"\"\"\n        if not manufacturers:\n            self.result.is_skipped(f\"{self.__class__.name} was not run as no manufacturers were given\")\n        else:\n            command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n            wrong_manufacturers = {interface: value[\"mfgName\"] for interface, value in command_output[\"xcvrSlots\"].items() if value[\"mfgName\"] not in manufacturers}\n            if not wrong_manufacturers:\n                self.result.is_success()\n            else:\n                self.result.is_failure(\"The following interfaces have transceivers from unauthorized manufacturers\")\n                self.result.messages.append(str(wrong_manufacturers))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversManufacturers.test","title":"<code>test(manufacturers=None)</code>","text":"<p>Run VerifyTransceiversManufacturers validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self, manufacturers: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyTransceiversManufacturers validation\"\"\"\n    if not manufacturers:\n        self.result.is_skipped(f\"{self.__class__.name} was not run as no manufacturers were given\")\n    else:\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        wrong_manufacturers = {interface: value[\"mfgName\"] for interface, value in command_output[\"xcvrSlots\"].items() if value[\"mfgName\"] not in manufacturers}\n        if not wrong_manufacturers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following interfaces have transceivers from unauthorized manufacturers\")\n            self.result.messages.append(str(wrong_manufacturers))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversTemperature","title":"<code>VerifyTransceiversTemperature</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies Transceivers temperature is currently OK.</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>class VerifyTransceiversTemperature(AntaTest):\n\"\"\"\n    Verifies Transceivers temperature is currently OK.\n    \"\"\"\n\n    name = \"VerifyTransceiversTemperature\"\n    description = \"Verifies Transceivers temperature is currently OK\"\n    categories = [\"hardware\"]\n    commands = [AntaTestCommand(command=\"show system environment temperature transceiver\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyTransceiversTemperature validation\"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        sensors = command_output[\"tempSensors\"] if \"tempSensors\" in command_output.keys() else \"\"\n        wrong_sensors = {\n            sensor[\"name\"]: {\n                \"hwStatus\": sensor[\"hwStatus\"],\n                \"alertCount\": sensor[\"alertCount\"],\n            }\n            for sensor in sensors\n            if sensor[\"hwStatus\"] != \"ok\" or sensor[\"alertCount\"] != 0\n        }\n        if not wrong_sensors:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following sensors do not have the correct temperature or had alarms in the past:\")\n            self.result.messages.append(str(wrong_sensors))\n</code></pre>"},{"location":"api/tests.hardware/#anta.tests.hardware.VerifyTransceiversTemperature.test","title":"<code>test()</code>","text":"<p>Run VerifyTransceiversTemperature validation</p> Source code in <code>anta/tests/hardware.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyTransceiversTemperature validation\"\"\"\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    sensors = command_output[\"tempSensors\"] if \"tempSensors\" in command_output.keys() else \"\"\n    wrong_sensors = {\n        sensor[\"name\"]: {\n            \"hwStatus\": sensor[\"hwStatus\"],\n            \"alertCount\": sensor[\"alertCount\"],\n        }\n        for sensor in sensors\n        if sensor[\"hwStatus\"] != \"ok\" or sensor[\"alertCount\"] != 0\n    }\n    if not wrong_sensors:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"The following sensors do not have the correct temperature or had alarms in the past:\")\n        self.result.messages.append(str(wrong_sensors))\n</code></pre>"},{"location":"api/tests.interfaces/","title":"Interfaces","text":""},{"location":"api/tests.interfaces/#anta-catalog-for-interfaces-tests","title":"ANTA catalog for interfaces tests","text":"<p>Test functions related to the device interfaces</p>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIllegalLACP","title":"<code>VerifyIllegalLACP</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no illegal LACP packets received.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyIllegalLACP(AntaTest):\n\"\"\"\n    Verifies there is no illegal LACP packets received.\n    \"\"\"\n\n    name = \"VerifyIllegalLACP\"\n    description = \"Verifies there is no illegal LACP packets received.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show lacp counters all-ports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyIllegalLACP validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        po_with_illegal_lacp: List[Dict[str, Dict[str, int]]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            po_with_illegal_lacp.extend(\n                {portchannel: interface} for interface, interface_dict in portchannel_dict[\"interfaces\"].items() if interface_dict[\"illegalRxCount\"] != 0\n            )\n\n        if not po_with_illegal_lacp:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"The following port-channels have recieved illegal lacp packets on the \" f\"following ports: {po_with_illegal_lacp}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyIllegalLACP.test","title":"<code>test()</code>","text":"<p>Run VerifyIllegalLACP validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyIllegalLACP validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    po_with_illegal_lacp: List[Dict[str, Dict[str, int]]] = []\n    for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n        po_with_illegal_lacp.extend(\n            {portchannel: interface} for interface, interface_dict in portchannel_dict[\"interfaces\"].items() if interface_dict[\"illegalRxCount\"] != 0\n        )\n\n    if not po_with_illegal_lacp:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"The following port-channels have recieved illegal lacp packets on the \" f\"following ports: {po_with_illegal_lacp}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceDiscards","title":"<code>VerifyInterfaceDiscards</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies interfaces packet discard counters are equal to zero.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceDiscards(AntaTest):\n\"\"\"\n    Verifies interfaces packet discard counters are equal to zero.\n    \"\"\"\n\n    name = \"VerifyInterfaceDiscards\"\n    description = \"Verifies interfaces packet discard counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show interfaces counters discards\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceDiscards validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n\n        for interface, outer_v in command_output[\"interfaces\"].items():\n            wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have non 0 discard counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceDiscards.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceDiscards validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceDiscards validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n\n    for interface, outer_v in command_output[\"interfaces\"].items():\n        wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have non 0 discard counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrDisabled","title":"<code>VerifyInterfaceErrDisabled</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no interface in error disable state.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrDisabled(AntaTest):\n\"\"\"\n    Verifies there is no interface in error disable state.\n    \"\"\"\n\n    name = \"VerifyInterfaceErrDisabled\"\n    description = \"Verifies there is no interface in error disable state.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show interfaces status\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceErrDisabled validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        errdisabled_interfaces = [interface for interface, value in command_output[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n\n        if errdisabled_interfaces:\n            self.result.is_failure(f\"The following interfaces are in error disabled state: {errdisabled_interfaces}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrDisabled.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceErrDisabled validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceErrDisabled validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    errdisabled_interfaces = [interface for interface, value in command_output[\"interfaceStatuses\"].items() if value[\"linkStatus\"] == \"errdisabled\"]\n\n    if errdisabled_interfaces:\n        self.result.is_failure(f\"The following interfaces are in error disabled state: {errdisabled_interfaces}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrors","title":"<code>VerifyInterfaceErrors</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies interfaces error counters are equal to zero.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceErrors(AntaTest):\n\"\"\"\n    Verifies interfaces error counters are equal to zero.\n    \"\"\"\n\n    name = \"verify_interface_errors\"\n    description = \"Verifies interfaces error counters are equal to zero.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show interfaces counters errors\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n        for interface, outer_v in command_output[\"interfaceErrorCounters\"].items():\n            wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have non 0 error counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceErrors.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceUtilization validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    wrong_interfaces: List[Dict[str, Dict[str, int]]] = []\n    for interface, outer_v in command_output[\"interfaceErrorCounters\"].items():\n        wrong_interfaces.extend({interface: outer_v} for counter, value in outer_v.items() if value &gt; 0)\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have non 0 error counter(s): {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceUtilization","title":"<code>VerifyInterfaceUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies interfaces utilization is below 75%.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfaceUtilization(AntaTest):\n\"\"\"\n    Verifies interfaces utilization is below 75%.\n    \"\"\"\n\n    name = \"verify_interface_utilization\"\n    description = \"Verifies interfaces utilization is below 75%.\"\n    categories = [\"interfaces\"]\n    # TODO - move from text to json if possible\n    commands = [AntaTestCommand(command=\"show interfaces counters rates\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(str, self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        wrong_interfaces = {}\n        for line in command_output.split(\"\\n\")[1:]:\n            if len(line) &gt; 0:\n                if line.split()[-5] == \"-\" or line.split()[-2] == \"-\":\n                    pass\n                elif float(line.split()[-5].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-5]\n                elif float(line.split()[-2].replace(\"%\", \"\")) &gt; 75.0:\n                    wrong_interfaces[line.split()[0]] = line.split()[-2]\n\n        if not wrong_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have a usage &gt; 75%: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfaceUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyInterfaceUtilization validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyInterfaceUtilization validation\"\"\"\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(str, self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    wrong_interfaces = {}\n    for line in command_output.split(\"\\n\")[1:]:\n        if len(line) &gt; 0:\n            if line.split()[-5] == \"-\" or line.split()[-2] == \"-\":\n                pass\n            elif float(line.split()[-5].replace(\"%\", \"\")) &gt; 75.0:\n                wrong_interfaces[line.split()[0]] = line.split()[-5]\n            elif float(line.split()[-2].replace(\"%\", \"\")) &gt; 75.0:\n                wrong_interfaces[line.split()[0]] = line.split()[-2]\n\n    if not wrong_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have a usage &gt; 75%: {wrong_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus","title":"<code>VerifyInterfacesStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyInterfacesStatus(AntaTest):\n\"\"\"\n    Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.\n    \"\"\"\n\n    name = \"VerifyInterfacesStatus\"\n    description = \"Verifies the number of Ethernet interfaces up/up on the device is higher or equal than a value.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show interfaces description\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: int = -1) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyInterfacesStatus validation\"\"\"\n\n        if minimum is None or minimum &lt; 0:\n            self.result.is_skipped(f\"VerifyInterfacesStatus was not run as an invalid minimum value was given {minimum}.\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        count_up_up = 0\n        other_ethernet_interfaces = []\n\n        for interface in command_output[\"interfaceDescriptions\"]:\n            interface_dict = command_output[\"interfaceDescriptions\"][interface]\n            if \"Ethernet\" in interface:\n                if re.match(r\"connected|up\", interface_dict[\"lineProtocolStatus\"]) and re.match(r\"connected|up\", interface_dict[\"interfaceStatus\"]):\n                    count_up_up += 1\n                else:\n                    other_ethernet_interfaces.append(interface)\n\n        if count_up_up &gt;= minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Only {count_up_up}, less than {minimum} Ethernet interfaces are UP/UP\")\n            self.result.messages.append(f\"The following Ethernet interfaces are not UP/UP: {other_ethernet_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyInterfacesStatus.test","title":"<code>test(minimum=-1)</code>","text":"<p>Run VerifyInterfacesStatus validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: int = -1) -&gt; None:  # type: ignore[override]\n\"\"\"Run VerifyInterfacesStatus validation\"\"\"\n\n    if minimum is None or minimum &lt; 0:\n        self.result.is_skipped(f\"VerifyInterfacesStatus was not run as an invalid minimum value was given {minimum}.\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    count_up_up = 0\n    other_ethernet_interfaces = []\n\n    for interface in command_output[\"interfaceDescriptions\"]:\n        interface_dict = command_output[\"interfaceDescriptions\"][interface]\n        if \"Ethernet\" in interface:\n            if re.match(r\"connected|up\", interface_dict[\"lineProtocolStatus\"]) and re.match(r\"connected|up\", interface_dict[\"interfaceStatus\"]):\n                count_up_up += 1\n            else:\n                other_ethernet_interfaces.append(interface)\n\n    if count_up_up &gt;= minimum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Only {count_up_up}, less than {minimum} Ethernet interfaces are UP/UP\")\n        self.result.messages.append(f\"The following Ethernet interfaces are not UP/UP: {other_ethernet_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount","title":"<code>VerifyLoopbackCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyLoopbackCount(AntaTest):\n\"\"\"\n    Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\n    \"\"\"\n\n    name = \"VerifyLoopbackCount\"\n    description = \"Verifies the number of loopback interfaces on the device is the one we expect and if none of the loopback is down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show ip interface brief\")]\n\n    @AntaTest.anta_test\n    def test(self, number: int = -1) -&gt; None:\n\"\"\"Run VerifyLoopbackCount validation\"\"\"\n\n        if number is None or number &lt; 0:\n            self.result.is_skipped(\"VerifyLoopbackCount was not run as no number value was given.\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        loopback_count = 0\n        down_loopback_interfaces = []\n\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Loopback\" in interface:\n                loopback_count += 1\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_loopback_interfaces.append(interface)\n\n        if loopback_count == number and len(down_loopback_interfaces) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if loopback_count != number:\n                self.result.is_failure(f\"Found {loopback_count} Loopbacks when expecting {number}\")\n            elif len(down_loopback_interfaces) != 0:\n                self.result.is_failure(f\"The following Loopbacks are not up: {down_loopback_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyLoopbackCount.test","title":"<code>test(number=-1)</code>","text":"<p>Run VerifyLoopbackCount validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: int = -1) -&gt; None:\n\"\"\"Run VerifyLoopbackCount validation\"\"\"\n\n    if number is None or number &lt; 0:\n        self.result.is_skipped(\"VerifyLoopbackCount was not run as no number value was given.\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    loopback_count = 0\n    down_loopback_interfaces = []\n\n    for interface in command_output[\"interfaces\"]:\n        interface_dict = command_output[\"interfaces\"][interface]\n        if \"Loopback\" in interface:\n            loopback_count += 1\n            if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                down_loopback_interfaces.append(interface)\n\n    if loopback_count == number and len(down_loopback_interfaces) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if loopback_count != number:\n            self.result.is_failure(f\"Found {loopback_count} Loopbacks when expecting {number}\")\n        elif len(down_loopback_interfaces) != 0:\n            self.result.is_failure(f\"The following Loopbacks are not up: {down_loopback_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyPortChannels","title":"<code>VerifyPortChannels</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no inactive port in port channels.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyPortChannels(AntaTest):\n\"\"\"\n    Verifies there is no inactive port in port channels.\n    \"\"\"\n\n    name = \"VerifyPortChannels\"\n    description = \"Verifies there is no inactive port in port channels.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show port-channel\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyPortChannels validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        po_with_invactive_ports: List[Dict[str, str]] = []\n        for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n            if len(portchannel_dict[\"inactivePorts\"]) != 0:\n                po_with_invactive_ports.extend({portchannel: portchannel_dict[\"inactivePorts\"]})\n\n        if not po_with_invactive_ports:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following port-channels have inactive port(s): {po_with_invactive_ports}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyPortChannels.test","title":"<code>test()</code>","text":"<p>Run VerifyPortChannels validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyPortChannels validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    po_with_invactive_ports: List[Dict[str, str]] = []\n    for portchannel, portchannel_dict in command_output[\"portChannels\"].items():\n        if len(portchannel_dict[\"inactivePorts\"]) != 0:\n            po_with_invactive_ports.extend({portchannel: portchannel_dict[\"inactivePorts\"]})\n\n    if not po_with_invactive_ports:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following port-channels have inactive port(s): {po_with_invactive_ports}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySVI","title":"<code>VerifySVI</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no interface vlan down.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifySVI(AntaTest):\n\"\"\"\n    Verifies there is no interface vlan down.\n    \"\"\"\n\n    name = \"VerifySVI\"\n    description = \"Verifies there is no interface vlan down.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show ip interface brief\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifySVI validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        down_svis = []\n\n        for interface in command_output[\"interfaces\"]:\n            interface_dict = command_output[\"interfaces\"][interface]\n            if \"Vlan\" in interface:\n                if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                    down_svis.append(interface)\n\n        if len(down_svis) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following SVIs are not up: {down_svis}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySVI.test","title":"<code>test()</code>","text":"<p>Run VerifySVI validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifySVI validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    down_svis = []\n\n    for interface in command_output[\"interfaces\"]:\n        interface_dict = command_output[\"interfaces\"][interface]\n        if \"Vlan\" in interface:\n            if not (interface_dict[\"lineProtocolStatus\"] == \"up\" and interface_dict[\"interfaceStatus\"] == \"connected\"):\n                down_svis.append(interface)\n\n    if len(down_svis) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following SVIs are not up: {down_svis}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySpanningTreeBlockedPorts","title":"<code>VerifySpanningTreeBlockedPorts</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no spanning-tree blocked ports.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifySpanningTreeBlockedPorts(AntaTest):\n\"\"\"\n    Verifies there is no spanning-tree blocked ports.\n    \"\"\"\n\n    name = \"VerifySpanningTreeBlockedPorts\"\n    description = \"Verifies there is no spanning-tree blocked ports.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show spanning-tree blockedports\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifySpanningTreeBlockedPorts validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        if len(command_output[\"spanningTreeInstances\"]) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            # TODO: a bit lazy would need a real output for this\n            self.result.messages.append(f\"The following ports are spanning-tree blocked {command_output['spanningTreeInstances']}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifySpanningTreeBlockedPorts.test","title":"<code>test()</code>","text":"<p>Run VerifySpanningTreeBlockedPorts validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifySpanningTreeBlockedPorts validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    if len(command_output[\"spanningTreeInstances\"]) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        # TODO: a bit lazy would need a real output for this\n        self.result.messages.append(f\"The following ports are spanning-tree blocked {command_output['spanningTreeInstances']}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyStormControlDrops","title":"<code>VerifyStormControlDrops</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device did not drop packets due its to storm-control configuration.</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>class VerifyStormControlDrops(AntaTest):\n\"\"\"\n    Verifies the device did not drop packets due its to storm-control configuration.\n    \"\"\"\n\n    name = \"VerifyStormControlDrops\"\n    description = \"Verifies the device did not drop packets due its to storm-control configuration.\"\n    categories = [\"interfaces\"]\n    commands = [AntaTestCommand(command=\"show storm-control\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyStormControlDrops validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        storm_controlled_interfaces: Dict[str, Dict[str, Any]] = {}\n        for interface, interface_dict in command_output[\"interfaces\"].items():\n            for traffic_type, traffic_type_dict in interface_dict[\"trafficTypes\"].items():\n                if \"drop\" in traffic_type_dict and traffic_type_dict[\"drop\"] != 0:\n                    storm_controlled_interface_dict = storm_controlled_interfaces.setdefault(interface, {})\n                    storm_controlled_interface_dict.update({traffic_type: traffic_type_dict[\"drop\"]})\n\n        if not storm_controlled_interfaces:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following interfaces have none 0 storm-control drop counters {storm_controlled_interfaces}\")\n</code></pre>"},{"location":"api/tests.interfaces/#anta.tests.interfaces.VerifyStormControlDrops.test","title":"<code>test()</code>","text":"<p>Run VerifyStormControlDrops validation</p> Source code in <code>anta/tests/interfaces.py</code> <pre><code>@skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyStormControlDrops validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    storm_controlled_interfaces: Dict[str, Dict[str, Any]] = {}\n    for interface, interface_dict in command_output[\"interfaces\"].items():\n        for traffic_type, traffic_type_dict in interface_dict[\"trafficTypes\"].items():\n            if \"drop\" in traffic_type_dict and traffic_type_dict[\"drop\"] != 0:\n                storm_controlled_interface_dict = storm_controlled_interfaces.setdefault(interface, {})\n                storm_controlled_interface_dict.update({traffic_type: traffic_type_dict[\"drop\"]})\n\n    if not storm_controlled_interfaces:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following interfaces have none 0 storm-control drop counters {storm_controlled_interfaces}\")\n</code></pre>"},{"location":"api/tests.logging/","title":"Logging","text":""},{"location":"api/tests.logging/#anta-catalog-for-logging-tests","title":"ANTA catalog for logging tests","text":"<p>Test functions related to the EOS various logging settings</p> <p>NOTE: \u2018show logging\u2019 does not support json output yet</p>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingAccounting","title":"<code>VerifyLoggingAccounting</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if AAA accounting logs are generated.</p> Expected Results <ul> <li>success: The test will pass if AAA accounting logs are generated.</li> <li>failure: The test will fail if AAA accounting logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingAccounting(AntaTest):\n\"\"\"\n    Verifies if AAA accounting logs are generated.\n\n    Expected Results:\n        * success: The test will pass if AAA accounting logs are generated.\n        * failure: The test will fail if AAA accounting logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingAccounting\"\n    description = \"Verifies if AAA accounting logs are generated.\"\n    categories = [\"logging\"]\n    commands = [AntaTestCommand(command=\"show aaa accounting logs | tail\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingAccountingvalidation.\n        \"\"\"\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(str, self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        pattern = r\"cmd=show aaa accounting logs\"\n\n        if re.search(pattern, command_output):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"AAA accounting logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingAccounting.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingAccountingvalidation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingAccountingvalidation.\n    \"\"\"\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(str, self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    pattern = r\"cmd=show aaa accounting logs\"\n\n    if re.search(pattern, command_output):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"AAA accounting logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHostname","title":"<code>VerifyLoggingHostname</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the device FQDN.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the device FQDN.</li> <li>failure: The test will fail if logs are NOT generated with the device FQDN.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHostname(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the device FQDN.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the device FQDN.\n        * failure: The test will fail if logs are NOT generated with the device FQDN.\n    \"\"\"\n\n    name = \"VerifyLoggingHostname\"\n    description = \"Verifies if logs are generated with the device FQDN.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaTestCommand(command=\"show hostname\"),\n        AntaTestCommand(command=\"send log level informational message ANTA VerifyLoggingHostname validation\"),\n        AntaTestCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingHostname validation.\n        \"\"\"\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        hostname_output = cast(Dict[str, str], self.instance_commands[0].output)\n        log_output = cast(str, self.instance_commands[2].output)\n        self.logger.debug(f\"dataset of hostname_output is: {hostname_output}\")\n        self.logger.debug(f\"dataset of log_output is: {log_output}\")\n\n        fqdn = hostname_output[\"fqdn\"]\n\n        log_pattern = r\"ANTA VerifyLoggingHostname validation\"\n\n        lines = log_output.strip().split(\"\\n\")[::-1]\n\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n\n        if fqdn in last_line_with_pattern:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the device FQDN\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHostname.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingHostname validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingHostname validation.\n    \"\"\"\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    hostname_output = cast(Dict[str, str], self.instance_commands[0].output)\n    log_output = cast(str, self.instance_commands[2].output)\n    self.logger.debug(f\"dataset of hostname_output is: {hostname_output}\")\n    self.logger.debug(f\"dataset of log_output is: {log_output}\")\n\n    fqdn = hostname_output[\"fqdn\"]\n\n    log_pattern = r\"ANTA VerifyLoggingHostname validation\"\n\n    lines = log_output.strip().split(\"\\n\")[::-1]\n\n    last_line_with_pattern = \"\"\n    for line in lines:\n        if re.search(log_pattern, line):\n            last_line_with_pattern = line\n            break\n\n    if fqdn in last_line_with_pattern:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Logs are not generated with the device FQDN\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts","title":"<code>VerifyLoggingHosts</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies logging hosts (syslog servers) for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided syslog servers are configured in the specified VRF.</li> <li>failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if syslog servers or VRF are not provided.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingHosts(AntaTest):\n\"\"\"\n    Verifies logging hosts (syslog servers) for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided syslog servers are configured in the specified VRF.\n        * failure: The test will fail if the provided syslog servers are NOT configured in the specified VRF.\n        * skipped: The test will be skipped if syslog servers or VRF are not provided.\n    \"\"\"\n\n    name = \"VerifyLoggingHosts\"\n    description = \"Verifies logging hosts (syslog servers) for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaTestCommand(command=\"show logging | awk '/Trap logging/,/Sequence numbers/{if(/Sequence numbers/) exit; print}'\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self, hosts: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyLoggingHosts validation.\n\n        Args:\n            hosts: List of hosts (syslog servers) IP addresses.\n            vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n        \"\"\"\n        if not hosts or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because hosts or vrf were not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(str, self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        not_configured = []\n\n        for host in hosts:\n            pattern = rf\"Logging to '{host}'.*VRF {vrf}\"\n            if not re.search(pattern, command_output):\n                not_configured.append(host)\n\n        if not not_configured:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Syslog servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingHosts.test","title":"<code>test(hosts=None, vrf='default')</code>","text":"<p>Run VerifyLoggingHosts validation.</p> <p>Parameters:</p> Name Type Description Default <code>hosts</code> <code>Optional[List[str]]</code> <p>List of hosts (syslog servers) IP addresses.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport log messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, hosts: Optional[List[str]] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyLoggingHosts validation.\n\n    Args:\n        hosts: List of hosts (syslog servers) IP addresses.\n        vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n    \"\"\"\n    if not hosts or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because hosts or vrf were not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(str, self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    not_configured = []\n\n    for host in hosts:\n        pattern = rf\"Logging to '{host}'.*VRF {vrf}\"\n        if not re.search(pattern, command_output):\n            not_configured.append(host)\n\n    if not not_configured:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Syslog servers {not_configured} are not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingLogsGeneration","title":"<code>VerifyLoggingLogsGeneration</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated.</p> Expected Results <ul> <li>success: The test will pass if logs are generated.</li> <li>failure: The test will fail if logs are NOT generated.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingLogsGeneration(AntaTest):\n\"\"\"\n    Verifies if logs are generated.\n\n    Expected Results:\n        * success: The test will pass if logs are generated.\n        * failure: The test will fail if logs are NOT generated.\n    \"\"\"\n\n    name = \"VerifyLoggingLogsGeneration\"\n    description = \"Verifies if logs are generated.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaTestCommand(command=\"send log level informational message ANTA VerifyLoggingLogsGeneration validation\"),\n        AntaTestCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingLogs validation.\n        \"\"\"\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(str, self.instance_commands[1].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        log_pattern = r\"ANTA VerifyLoggingLogsGeneration validation\"\n\n        lines = command_output.strip().split(\"\\n\")[::-1]\n\n        for line in lines:\n            if re.search(log_pattern, line):\n                self.result.is_success()\n                return\n\n        self.result.is_failure(\"Logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingLogsGeneration.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingLogs validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingLogs validation.\n    \"\"\"\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(str, self.instance_commands[1].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    log_pattern = r\"ANTA VerifyLoggingLogsGeneration validation\"\n\n    lines = command_output.strip().split(\"\\n\")[::-1]\n\n    for line in lines:\n        if re.search(log_pattern, line):\n            self.result.is_success()\n            return\n\n    self.result.is_failure(\"Logs are not generated\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingPersistent","title":"<code>VerifyLoggingPersistent</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logging persistent is enabled and logs are saved in flash.</p> Expected Results <ul> <li>success: The test will pass if logging persistent is enabled and logs are in flash.</li> <li>failure: The test will fail if logging persistent is disabled or no logs are saved in flash.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingPersistent(AntaTest):\n\"\"\"\n    Verifies if logging persistent is enabled and logs are saved in flash.\n\n    Expected Results:\n        * success: The test will pass if logging persistent is enabled and logs are in flash.\n        * failure: The test will fail if logging persistent is disabled or no logs are saved in flash.\n    \"\"\"\n\n    name = \"VerifyLoggingPersistent\"\n    description = \"Verifies if logging persistent is enabled and logs are saved in flash.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaTestCommand(command=\"show logging | awk 'NR==4 {print; exit}'\", ofmt=\"text\"),\n        AntaTestCommand(command=\"dir flash:/persist/messages\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingPersistent validation.\n        \"\"\"\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        log_output = cast(str, self.instance_commands[0].output)\n        dir_flash_output = cast(str, self.instance_commands[1].output)\n        self.logger.debug(f\"dataset of log_output command is: {log_output}\")\n        self.logger.debug(f\"dataset of dir_flash_output command is: {dir_flash_output}\")\n\n        pattern = r\"-rw-\\s+(\\d+)\"\n        match = re.search(pattern, dir_flash_output)\n\n        self.result.is_success()\n\n        if \"disabled\" in log_output:\n            self.result.is_failure(\"Persistent logging is disabled\")\n            return\n\n        if not match or int(match.group(1)) == 0:\n            self.result.is_failure(\"No persistent logs are saved in flash\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingPersistent.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingPersistent validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingPersistent validation.\n    \"\"\"\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    log_output = cast(str, self.instance_commands[0].output)\n    dir_flash_output = cast(str, self.instance_commands[1].output)\n    self.logger.debug(f\"dataset of log_output command is: {log_output}\")\n    self.logger.debug(f\"dataset of dir_flash_output command is: {dir_flash_output}\")\n\n    pattern = r\"-rw-\\s+(\\d+)\"\n    match = re.search(pattern, dir_flash_output)\n\n    self.result.is_success()\n\n    if \"disabled\" in log_output:\n        self.result.is_failure(\"Persistent logging is disabled\")\n        return\n\n    if not match or int(match.group(1)) == 0:\n        self.result.is_failure(\"No persistent logs are saved in flash\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf","title":"<code>VerifyLoggingSourceIntf</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies logging source-interface for a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the provided logging source-interface is configured in the specified VRF.</li> <li>failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.</li> <li>skipped: The test will be skipped if source-interface or VRF is not provided.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingSourceIntf(AntaTest):\n\"\"\"\n    Verifies logging source-interface for a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the provided logging source-interface is configured in the specified VRF.\n        * failure: The test will fail if the provided logging source-interface is NOT configured in the specified VRF.\n        * skipped: The test will be skipped if source-interface or VRF is not provided.\n    \"\"\"\n\n    name = \"VerifyLoggingSourceInt\"\n    description = \"Verifies logging source-interface for a specified VRF.\"\n    categories = [\"logging\"]\n    commands = [AntaTestCommand(command=\"show logging | awk '/Trap logging/,/Sequence numbers/{if(/Sequence numbers/) exit; print}'\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyLoggingSrcDst validation.\n\n        Args:\n            intf: Source-interface to use as source IP of log messages.\n            vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n        \"\"\"\n        if not intf or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(str, self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        pattern = rf\"Logging source-interface '{intf}'.*VRF {vrf}\"\n\n        if re.search(pattern, command_output):\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Source-interface '{intf}' is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingSourceIntf.test","title":"<code>test(intf=None, vrf='default')</code>","text":"<p>Run VerifyLoggingSrcDst validation.</p> <p>Parameters:</p> Name Type Description Default <code>intf</code> <code>Optional[str]</code> <p>Source-interface to use as source IP of log messages.</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF to transport log messages. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, intf: Optional[str] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyLoggingSrcDst validation.\n\n    Args:\n        intf: Source-interface to use as source IP of log messages.\n        vrf: The name of the VRF to transport log messages. Defaults to 'default'.\n    \"\"\"\n    if not intf or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because intf or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(str, self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    pattern = rf\"Logging source-interface '{intf}'.*VRF {vrf}\"\n\n    if re.search(pattern, command_output):\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Source-interface '{intf}' is not configured in VRF {vrf}\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingTimestamp","title":"<code>VerifyLoggingTimestamp</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if logs are generated with the approprate timestamp.</p> Expected Results <ul> <li>success: The test will pass if logs are generated with the appropriated timestamp.</li> <li>failure: The test will fail if logs are NOT generated with the appropriated timestamp.</li> </ul> Source code in <code>anta/tests/logging.py</code> <pre><code>class VerifyLoggingTimestamp(AntaTest):\n\"\"\"\n    Verifies if logs are generated with the approprate timestamp.\n\n    Expected Results:\n        * success: The test will pass if logs are generated with the appropriated timestamp.\n        * failure: The test will fail if logs are NOT generated with the appropriated timestamp.\n    \"\"\"\n\n    name = \"VerifyLoggingTimestamp\"\n    description = \"Verifies if logs are generated with the appropriate timestamp.\"\n    categories = [\"logging\"]\n    commands = [\n        AntaTestCommand(command=\"send log level informational message ANTA VerifyLoggingTimestamp validation\"),\n        AntaTestCommand(command=\"show logging informational last 30 seconds | grep ANTA\", ofmt=\"text\"),\n    ]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyLoggingTimestamp validation.\n        \"\"\"\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(str, self.instance_commands[1].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        log_pattern = r\"ANTA VerifyLoggingTimestamp validation\"\n        timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}-\\d{2}:\\d{2}\"\n\n        lines = command_output.strip().split(\"\\n\")[::-1]\n\n        last_line_with_pattern = \"\"\n        for line in lines:\n            if re.search(log_pattern, line):\n                last_line_with_pattern = line\n                break\n\n        if re.search(timestamp_pattern, last_line_with_pattern):\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Logs are not generated with the appropriate timestamp format\")\n</code></pre>"},{"location":"api/tests.logging/#anta.tests.logging.VerifyLoggingTimestamp.test","title":"<code>test()</code>","text":"<p>Run VerifyLoggingTimestamp validation.</p> Source code in <code>anta/tests/logging.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyLoggingTimestamp validation.\n    \"\"\"\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(str, self.instance_commands[1].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    log_pattern = r\"ANTA VerifyLoggingTimestamp validation\"\n    timestamp_pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6}-\\d{2}:\\d{2}\"\n\n    lines = command_output.strip().split(\"\\n\")[::-1]\n\n    last_line_with_pattern = \"\"\n    for line in lines:\n        if re.search(log_pattern, line):\n            last_line_with_pattern = line\n            break\n\n    if re.search(timestamp_pattern, last_line_with_pattern):\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Logs are not generated with the appropriate timestamp format\")\n</code></pre>"},{"location":"api/tests/","title":"Overview","text":""},{"location":"api/tests/#anta-tests-landing-page","title":"ANTA Tests landing page","text":"<p>This section describes all the available tests provided by ANTA package.</p> <ul> <li>Configuration</li> <li>Hardware</li> <li>interfaces</li> <li>MLAG</li> <li>Multicast</li> <li>Profiles</li> <li>System</li> <li>Software</li> <li>Routing Generic</li> <li>Routing BGP</li> <li>Routing OSPF</li> </ul> <p>All these tests can be imported in a catalog to be used by the anta cli or in your own framework</p>"},{"location":"api/tests.mlag/","title":"MLAG","text":""},{"location":"api/tests.mlag/#anta-catalog-for-mlag-tests","title":"ANTA catalog for mlag tests","text":"<p>Test functions related to Multi-Chassis LAG</p>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagConfigSanity","title":"<code>VerifyMlagConfigSanity</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there are no MLAG config-sanity inconsistencies.</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagConfigSanity(AntaTest):\n\"\"\"\n    Verifies there are no MLAG config-sanity inconsistencies.\n    \"\"\"\n\n    name = \"verify_mlag_config_sanity\"\n    description = \"Verifies there are no MLAG config-sanity inconsistencies.\"\n    categories = [\"mlag\"]\n    commands = [AntaTestCommand(command=\"show mlag config-sanity\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyMlagConfigSanity validation\"\"\"\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        if \"mlagActive\" not in command_output.keys():\n            self.result.is_error(\"Incorrect JSON response - mlagActive state not found\")\n        elif command_output[\"mlagActive\"] is False:\n            self.result.is_skipped(\"MLAG is disabled\")\n        elif len(command_output[\"globalConfiguration\"]) &gt; 0 or len(command_output[\"interfaceConfiguration\"]) &gt; 0:\n            self.result.is_failure()\n            if len(command_output[\"globalConfiguration\"]) &gt; 0:\n                self.result.is_failure(\"MLAG config-sanity returned Global inconsistancies: \" f\"{command_output['globalConfiguration']}\")\n            if len(command_output[\"interfaceConfiguration\"]) &gt; 0:\n                self.result.is_failure(\"MLAG config-sanity returned Interface inconsistancies: \" f\"{command_output['interfaceConfiguration']}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagConfigSanity.test","title":"<code>test()</code>","text":"<p>Run VerifyMlagConfigSanity validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyMlagConfigSanity validation\"\"\"\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    if \"mlagActive\" not in command_output.keys():\n        self.result.is_error(\"Incorrect JSON response - mlagActive state not found\")\n    elif command_output[\"mlagActive\"] is False:\n        self.result.is_skipped(\"MLAG is disabled\")\n    elif len(command_output[\"globalConfiguration\"]) &gt; 0 or len(command_output[\"interfaceConfiguration\"]) &gt; 0:\n        self.result.is_failure()\n        if len(command_output[\"globalConfiguration\"]) &gt; 0:\n            self.result.is_failure(\"MLAG config-sanity returned Global inconsistancies: \" f\"{command_output['globalConfiguration']}\")\n        if len(command_output[\"interfaceConfiguration\"]) &gt; 0:\n            self.result.is_failure(\"MLAG config-sanity returned Interface inconsistancies: \" f\"{command_output['interfaceConfiguration']}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagInterfaces","title":"<code>VerifyMlagInterfaces</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there are no inactive or active-partial MLAG interfaces.</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagInterfaces(AntaTest):\n\"\"\"\n    Verifies there are no inactive or active-partial MLAG interfaces.\n    \"\"\"\n\n    name = \"verify_mlag_interfaces\"\n    description = \"Verifies there are no inactive or active-partial MLAG interfaces.\"\n    categories = [\"mlag\"]\n    commands = [AntaTestCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyMlagInterfaces validation\"\"\"\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n        elif command_output[\"mlagPorts\"][\"Inactive\"] != 0 or command_output[\"mlagPorts\"][\"Active-partial\"] != 0:\n            self.result.is_failure(f\"MLAG status is not OK: {command_output['mlagPorts']}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagInterfaces.test","title":"<code>test()</code>","text":"<p>Run VerifyMlagInterfaces validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyMlagInterfaces validation\"\"\"\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n    elif command_output[\"mlagPorts\"][\"Inactive\"] != 0 or command_output[\"mlagPorts\"][\"Active-partial\"] != 0:\n        self.result.is_failure(f\"MLAG status is not OK: {command_output['mlagPorts']}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagStatus","title":"<code>VerifyMlagStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if MLAG us running, and if the status is good state is active, negotiation status is connected, local int is up, peer link is up.</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>class VerifyMlagStatus(AntaTest):\n\"\"\"\n    Verifies if MLAG us running, and if the status is good\n    state is active, negotiation status is connected, local int is up, peer link is up.\n    \"\"\"\n\n    name = \"verify_mlag_status\"\n    description = \"Verifies MLAG status\"\n    categories = [\"mlag\"]\n    commands = [AntaTestCommand(command=\"show mlag\", ofmt=\"json\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyMlagStatus validation\"\"\"\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        if command_output[\"state\"] == \"disabled\":\n            self.result.is_skipped(\"MLAG is disabled\")\n        elif (\n            command_output[\"state\"] != \"active\"\n            or command_output[\"negStatus\"] != \"connected\"\n            or command_output[\"localIntfStatus\"] != \"up\"\n            or command_output[\"peerLinkStatus\"] != \"up\"\n        ):\n            self.result.is_failure(f\"MLAG status is not OK: {command_output}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.mlag/#anta.tests.mlag.VerifyMlagStatus.test","title":"<code>test()</code>","text":"<p>Run VerifyMlagStatus validation</p> Source code in <code>anta/tests/mlag.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyMlagStatus validation\"\"\"\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    if command_output[\"state\"] == \"disabled\":\n        self.result.is_skipped(\"MLAG is disabled\")\n    elif (\n        command_output[\"state\"] != \"active\"\n        or command_output[\"negStatus\"] != \"connected\"\n        or command_output[\"localIntfStatus\"] != \"up\"\n        or command_output[\"peerLinkStatus\"] != \"up\"\n    ):\n        self.result.is_failure(f\"MLAG status is not OK: {command_output}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.multicast/","title":"Multicast","text":""},{"location":"api/tests.multicast/#anta-catalog-for-multicast-tests","title":"ANTA catalog for multicast tests","text":"<p>Test functions related to multicast</p>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal","title":"<code>VerifyIGMPSnoopingGlobal</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping global configuration.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>str</code> <p>Expected global IGMP snooping configuration (enabled or disabled).</p> required Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingGlobal(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping global configuration.\n\n    Args:\n        configuration (str): Expected global IGMP snooping configuration (enabled or disabled).\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingGlobal\"\n    description = \"Verifies the IGMP snooping global configuration.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaTestCommand(command=\"show ip igmp snooping\")]\n\n    @AntaTest.anta_test\n    def test(self, configuration: str = \"\") -&gt; None:\n\"\"\"Run VerifyIGMPSnoopingGlobal validation\"\"\"\n\n        if not configuration:\n            self.result.is_skipped(\"VerifyIGMPSnoopingGlobal was not run as no configuration was given\")\n            return\n\n        if configuration not in [\"enabled\", \"disabled\"]:\n            self.result.is_error(f\"VerifyIGMPSnoopingGlobal was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        logger.debug(f\"query self.result is: {command_output}\")\n\n        self.result.is_success()\n        if (igmp_state := command_output[\"igmpSnoopingState\"]) != configuration:\n            self.result.is_failure(f\"IGMP state is not valid: {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingGlobal.test","title":"<code>test(configuration='')</code>","text":"<p>Run VerifyIGMPSnoopingGlobal validation</p> Source code in <code>anta/tests/multicast.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, configuration: str = \"\") -&gt; None:\n\"\"\"Run VerifyIGMPSnoopingGlobal validation\"\"\"\n\n    if not configuration:\n        self.result.is_skipped(\"VerifyIGMPSnoopingGlobal was not run as no configuration was given\")\n        return\n\n    if configuration not in [\"enabled\", \"disabled\"]:\n        self.result.is_error(f\"VerifyIGMPSnoopingGlobal was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    logger.debug(f\"query self.result is: {command_output}\")\n\n    self.result.is_success()\n    if (igmp_state := command_output[\"igmpSnoopingState\"]) != configuration:\n        self.result.is_failure(f\"IGMP state is not valid: {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans","title":"<code>VerifyIGMPSnoopingVlans</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the IGMP snooping configuration for some VLANs.</p> <p>Parameters:</p> Name Type Description Default <code>vlans</code> <code>List[str]</code> <p>A list of VLANs</p> required <code>configuration</code> <code>str</code> <p>Expected IGMP snooping configuration (enabled or disabled) for these VLANs.</p> required Source code in <code>anta/tests/multicast.py</code> <pre><code>class VerifyIGMPSnoopingVlans(AntaTest):\n\"\"\"\n    Verifies the IGMP snooping configuration for some VLANs.\n\n    Args:\n        vlans (List[str]): A list of VLANs\n        configuration (str): Expected IGMP snooping configuration (enabled or disabled) for these VLANs.\n    \"\"\"\n\n    name = \"VerifyIGMPSnoopingVlans\"\n    description = \"Verifies the IGMP snooping configuration for some VLANs.\"\n    categories = [\"multicast\", \"igmp\"]\n    commands = [AntaTestCommand(command=\"show ip igmp snooping\")]\n\n    @AntaTest.anta_test\n    def test(self, vlans: Optional[List[str]] = None, configuration: str = \"\") -&gt; None:\n\"\"\"Run VerifyIGMPSnoopingVlans validation\"\"\"\n\n        if not vlans or not configuration:\n            self.result.is_skipped(\"VerifyIGMPSnoopingVlans was not run as no vlans or configuration was given\")\n            return\n        if configuration not in [\"enabled\", \"disabled\"]:\n            self.result.is_error(f\"VerifyIGMPSnoopingVlans was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        logger.debug(f\"query self.result is: {command_output}\")\n\n        self.result.is_success()\n        for vlan in vlans:\n            if vlan not in command_output[\"vlans\"]:\n                self.result.is_failure(f\"Supplied vlan {vlan} is not present on the device.\")\n                continue\n\n            igmp_state = command_output[\"vlans\"][str(vlan)][\"igmpSnoopingState\"]\n            if igmp_state != configuration:\n                self.result.is_failure(f\"IGMP state for vlan {vlan} is {igmp_state}\")\n</code></pre>"},{"location":"api/tests.multicast/#anta.tests.multicast.VerifyIGMPSnoopingVlans.test","title":"<code>test(vlans=None, configuration='')</code>","text":"<p>Run VerifyIGMPSnoopingVlans validation</p> Source code in <code>anta/tests/multicast.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, vlans: Optional[List[str]] = None, configuration: str = \"\") -&gt; None:\n\"\"\"Run VerifyIGMPSnoopingVlans validation\"\"\"\n\n    if not vlans or not configuration:\n        self.result.is_skipped(\"VerifyIGMPSnoopingVlans was not run as no vlans or configuration was given\")\n        return\n    if configuration not in [\"enabled\", \"disabled\"]:\n        self.result.is_error(f\"VerifyIGMPSnoopingVlans was not run as 'configuration': {configuration} is not in the allowed values: ['enabled', 'disabled'])\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    logger.debug(f\"query self.result is: {command_output}\")\n\n    self.result.is_success()\n    for vlan in vlans:\n        if vlan not in command_output[\"vlans\"]:\n            self.result.is_failure(f\"Supplied vlan {vlan} is not present on the device.\")\n            continue\n\n        igmp_state = command_output[\"vlans\"][str(vlan)][\"igmpSnoopingState\"]\n        if igmp_state != configuration:\n            self.result.is_failure(f\"IGMP state for vlan {vlan} is {igmp_state}\")\n</code></pre>"},{"location":"api/tests.profiles/","title":"Profiles","text":""},{"location":"api/tests.profiles/#anta-catalog-for-profiles-tests","title":"ANTA catalog for profiles tests","text":"<p>Test functions related to ASIC profiles</p>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyTcamProfile","title":"<code>VerifyTcamProfile</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is using the configured TCAM profile.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyTcamProfile(AntaTest):\n\"\"\"\n    Verifies the device is using the configured TCAM profile.\n    \"\"\"\n\n    name = \"verify_tcam_profile\"\n    description = \"Verify that the assigned TCAM profile is actually running on the device\"\n    categories = [\"profiles\"]\n    commands = [AntaTestCommand(command=\"show hardware tcam profile\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, profile: Any = None) -&gt; None:\n        if not profile:\n            self.result.is_skipped(\"verify_tcam_profile was not run as no profile was given\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        if command_output[\"pmfProfiles\"][\"FixedSystem\"][\"status\"] == command_output[\"pmfProfiles\"][\"FixedSystem\"][\"config\"] == profile:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Incorrect profile running on device: {command_output['pmfProfiles']['FixedSystem']['status']}\")\n</code></pre>"},{"location":"api/tests.profiles/#anta.tests.profiles.VerifyUnifiedForwardingTableMode","title":"<code>VerifyUnifiedForwardingTableMode</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is using the expected Unified Forwarding Table mode.</p> Source code in <code>anta/tests/profiles.py</code> <pre><code>class VerifyUnifiedForwardingTableMode(AntaTest):\n\"\"\"\n    Verifies the device is using the expected Unified Forwarding Table mode.\n    \"\"\"\n\n    name = \"verify_unified_forwarding_table_mode\"\n    description = \"\"\n    categories = [\"profiles\"]\n    commands = [AntaTestCommand(command=\"show platform trident forwarding-table partition\", ofmt=\"json\")]\n\n    @skip_on_platforms([\"cEOSLab\", \"vEOS-lab\"])\n    @AntaTest.anta_test\n    def test(self, mode: Any = None) -&gt; None:\n        if not mode:\n            self.result.is_skipped(\"verify_unified_forwarding_table_mode was not run as no mode was given\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        if command_output[\"uftMode\"] == mode:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Device is not running correct UFT mode (expected: {mode} / running: {command_output['uftMode']})\")\n</code></pre>"},{"location":"api/tests.routing.bgp/","title":"BGP","text":""},{"location":"api/tests.routing.bgp/#anta-catalog-for-routing-bgp-tests","title":"ANTA catalog for routing-bgp tests","text":"<p>BGP test functions</p>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount","title":"<code>VerifyBGPEVPNCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are Established and if the actual                      number of BGP EVPN neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNCount(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF)\n    and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\n\n    * self.result = \"skipped\" if the `number` parameter is missing\n    * self.result = \"success\" if all EVPN BGP sessions are Established and if the actual\n                         number of BGP EVPN neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNCount\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF) and the actual number of BGP EVPN neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaTestCommand(command=\"show bgp evpn summary\")]\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyBGPEVPNCount validation\"\"\"\n        if not number:\n            self.result.is_skipped(\"VerifyBGPEVPNCount could not run because number was not supplied.\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers and len(peers) == number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP EVPN peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyBGPEVPNCount validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"evpn\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyBGPEVPNCount validation\"\"\"\n    if not number:\n        self.result.is_skipped(\"VerifyBGPEVPNCount could not run because number was not supplied.\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers and len(peers) == number:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP EVPN peers and got {len(peers)}\")\n        if non_established_peers:\n            self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNState","title":"<code>VerifyBGPEVPNState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all EVPN BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP EVPN peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all EVPN BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPEVPNState(AntaTest):\n\"\"\"\n    Verifies all EVPN BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP EVPN peers are returned by the device\n    * self.result = \"success\" if all EVPN BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPEVPNState\"\n    description = \"Verifies all EVPN BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaTestCommand(command=\"show bgp evpn summary\")]\n\n    @check_bgp_family_enable(\"evpn\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPEVPNState validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        bgp_vrfs = command_output[\"vrfs\"]\n\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPEVPNState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPEVPNState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"evpn\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPEVPNState validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    bgp_vrfs = command_output[\"vrfs\"]\n\n    peers = bgp_vrfs[\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following EVPN peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount","title":"<code>VerifyBGPIPv4UnicastCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established and all BGP messages queues for these sessions are empty and the actual number of BGP IPv4 unicast neighbors is the one we expect.</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> or <code>vrf</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established                      and if all BGP messages queues for these sessions are empty                      and if the actual number of BGP IPv4 unicast neighbors is equal to `number.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastCount(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established\n    and all BGP messages queues for these sessions are empty\n    and the actual number of BGP IPv4 unicast neighbors is the one we expect.\n\n    * self.result = \"skipped\" if the `number` or `vrf` parameter is missing\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established\n                         and if all BGP messages queues for these sessions are empty\n                         and if the actual number of BGP IPv4 unicast neighbors is equal to `number.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastCount\"\n    description = (\n        \"Verifies all IPv4 unicast BGP sessions are established and all their BGP messages queues are empty and \"\n        \" the actual number of BGP IPv4 unicast neighbors is the one we expect.\"\n    )\n    categories = [\"routing\", \"bgp\"]\n    template = AntaTestTemplate(template=\"show bgp ipv4 unicast summary vrf {vrf}\")\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastCount validation\"\"\"\n\n        if not number:\n            self.result.is_skipped(\"VerifyBGPIPv4UnicastCount could not run because number was not supplied\")\n            return\n\n        self.result.is_success()\n\n        for index, command in enumerate(self.instance_commands):\n            vrf = cast(Dict[str, str], command.template_params).get(\"vrf\")\n            command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[index].output)\n\n            peers = command_output[\"vrfs\"][vrf][\"peers\"]\n            state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP peer in vrf {vrf} and got {len(peers)}\")\n            if state_issue:\n                self.result.is_failure(f\"The following IPv4 peers are not established: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyBGPIPv4UnicastCount validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv4\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastCount validation\"\"\"\n\n    if not number:\n        self.result.is_skipped(\"VerifyBGPIPv4UnicastCount could not run because number was not supplied\")\n        return\n\n    self.result.is_success()\n\n    for index, command in enumerate(self.instance_commands):\n        vrf = cast(Dict[str, str], command.template_params).get(\"vrf\")\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[index].output)\n\n        peers = command_output[\"vrfs\"][vrf][\"peers\"]\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP peer in vrf {vrf} and got {len(peers)}\")\n        if state_issue:\n            self.result.is_failure(f\"The following IPv4 peers are not established: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastState","title":"<code>VerifyBGPIPv4UnicastState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv4 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv4UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv4 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv4 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv4UnicastState\"\n    description = \"Verifies all IPv4 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaTestCommand(command=\"show bgp ipv4 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv4\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastState validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv4UnicastState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPIPv4UnicastState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv4\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv4UnicastState validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n    if not state_issue:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv6UnicastState","title":"<code>VerifyBGPIPv6UnicastState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP vrf are returned by the device</li> <li>self.result = \u201csuccess\u201d if all IPv6 unicast BGP sessions are established (for all VRF)                      and all BGP messages queues for these sessions are empty (for all VRF).</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPIPv6UnicastState(AntaTest):\n\"\"\"\n    Verifies all IPv6 unicast BGP sessions are established (for all VRF)\n    and all BGP messages queues for these sessions are empty (for all VRF).\n\n    * self.result = \"skipped\" if no BGP vrf are returned by the device\n    * self.result = \"success\" if all IPv6 unicast BGP sessions are established (for all VRF)\n                         and all BGP messages queues for these sessions are empty (for all VRF).\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPIPv6UnicastState\"\n    description = \"Verifies all IPv6 unicast BGP sessions are established (for all VRF) and all BGP messages queues for these sessions are empty (for all VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaTestCommand(command=\"show bgp ipv6 unicast summary vrf all\")]\n\n    @check_bgp_family_enable(\"ipv6\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv6UnicastState validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n        if not state_issue:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPIPv6UnicastState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPIPv6UnicastState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"ipv6\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPIPv6UnicastState validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    state_issue = _check_bgp_vrfs(command_output[\"vrfs\"])\n\n    if not state_issue:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Some IPv4 Unicast BGP Peer are not up: {state_issue}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount","title":"<code>VerifyBGPRTCCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if the <code>number</code> parameter is missing</li> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are Established and if the actual                      number of BGP RTC neighbors is the one we expect.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCCount(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF)\n    and the actual number of BGP RTC neighbors is the one we expect (default VRF).\n\n    * self.result = \"skipped\" if the `number` parameter is missing\n    * self.result = \"success\" if all RTC BGP sessions are Established and if the actual\n                         number of BGP RTC neighbors is the one we expect.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCCount\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF) and the actual number of BGP RTC neighbors is the one we expect (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaTestCommand(command=\"show bgp rt-membership summary\")]\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyBGPRTCCount validation\"\"\"\n        if not number:\n            self.result.is_skipped(\"VerifyBGPRTCCount could not run because number was not supplied\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers and len(peers) == number:\n            self.result.is_success()\n        else:\n            self.result.is_failure()\n            if len(peers) != number:\n                self.result.is_failure(f\"Expecting {number} BGP RTC peers and got {len(peers)}\")\n            if non_established_peers:\n                self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyBGPRTCCount validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"rtc\")\n@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyBGPRTCCount validation\"\"\"\n    if not number:\n        self.result.is_skipped(\"VerifyBGPRTCCount could not run because number was not supplied\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    peers = command_output[\"vrfs\"][\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers and len(peers) == number:\n        self.result.is_success()\n    else:\n        self.result.is_failure()\n        if len(peers) != number:\n            self.result.is_failure(f\"Expecting {number} BGP RTC peers and got {len(peers)}\")\n        if non_established_peers:\n            self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCState","title":"<code>VerifyBGPRTCState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all RTC BGP sessions are established (default VRF).</p> <ul> <li>self.result = \u201cskipped\u201d if no BGP RTC peers are returned by the device</li> <li>self.result = \u201csuccess\u201d if all RTC BGP sessions are established.</li> <li>self.result = \u201cfailure\u201d otherwise.</li> </ul> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>class VerifyBGPRTCState(AntaTest):\n\"\"\"\n    Verifies all RTC BGP sessions are established (default VRF).\n\n    * self.result = \"skipped\" if no BGP RTC peers are returned by the device\n    * self.result = \"success\" if all RTC BGP sessions are established.\n    * self.result = \"failure\" otherwise.\n    \"\"\"\n\n    name = \"VerifyBGPRTCState\"\n    description = \"Verifies all RTC BGP sessions are established (default VRF).\"\n    categories = [\"routing\", \"bgp\"]\n    commands = [AntaTestCommand(command=\"show bgp rt-membership summary\")]\n\n    @check_bgp_family_enable(\"rtc\")\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBGPRTCState validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        bgp_vrfs = command_output[\"vrfs\"]\n\n        peers = bgp_vrfs[\"default\"][\"peers\"]\n        non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n        if not non_established_peers:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.bgp/#anta.tests.routing.bgp.VerifyBGPRTCState.test","title":"<code>test()</code>","text":"<p>Run VerifyBGPRTCState validation</p> Source code in <code>anta/tests/routing/bgp.py</code> <pre><code>@check_bgp_family_enable(\"rtc\")\n@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBGPRTCState validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    bgp_vrfs = command_output[\"vrfs\"]\n\n    peers = bgp_vrfs[\"default\"][\"peers\"]\n    non_established_peers = [peer for peer, peer_dict in peers.items() if peer_dict[\"peerState\"] != \"Established\"]\n\n    if not non_established_peers:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"The following RTC peers are not established: {non_established_peers}\")\n</code></pre>"},{"location":"api/tests.routing.generic/","title":"Generic","text":""},{"location":"api/tests.routing.generic/#anta-catalog-for-routing-generic-tests","title":"ANTA catalog for routing-generic tests","text":"<p>Generic routing test functions</p>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyBFD","title":"<code>VerifyBFD</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyBFD(AntaTest):\n\"\"\"\n    Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\n    \"\"\"\n\n    name = \"VerifyBFD\"\n    description = \"Verifies there is no BFD peer in down state (all VRF, IPv4 neighbors).\"\n    categories = [\"routing\", \"generic\"]\n    # revision 1 as later revision introduce additional nesting for type\n    commands = [AntaTestCommand(command=\"show bfd peers\", version=1)]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyBFD validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        self.result.is_success()\n\n        for _, vrf_data in command_output[\"vrfs\"].items():\n            for _, neighbor_data in vrf_data[\"ipv4Neighbors\"].items():\n                for peer, peer_data in neighbor_data[\"peerStats\"].items():\n                    if (peer_status := peer_data[\"status\"]) != \"up\":\n                        failure_message = f\"bfd state for peer '{peer}' is {peer_status} (expected up).\"\n                        if (peer_l3intf := peer_data.get(\"l3intf\")) is not None and peer_l3intf != \"\":\n                            failure_message += f\" Interface: {peer_l3intf}.\"\n                        self.result.is_failure(failure_message)\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyBFD.test","title":"<code>test()</code>","text":"<p>Run VerifyBFD validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyBFD validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    self.result.is_success()\n\n    for _, vrf_data in command_output[\"vrfs\"].items():\n        for _, neighbor_data in vrf_data[\"ipv4Neighbors\"].items():\n            for peer, peer_data in neighbor_data[\"peerStats\"].items():\n                if (peer_status := peer_data[\"status\"]) != \"up\":\n                    failure_message = f\"bfd state for peer '{peer}' is {peer_status} (expected up).\"\n                    if (peer_l3intf := peer_data.get(\"l3intf\")) is not None and peer_l3intf != \"\":\n                        failure_message += f\" Interface: {peer_l3intf}.\"\n                    self.result.is_failure(failure_message)\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel","title":"<code>VerifyRoutingProtocolModel</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the configured routing protocol model is the one we expect. And if there is no mismatch between the configured and operating routing protocol model.</p> <pre><code>model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent\n</code></pre> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingProtocolModel(AntaTest):\n\"\"\"\n    Verifies the configured routing protocol model is the one we expect.\n    And if there is no mismatch between the configured and operating routing protocol model.\n\n        model(str): Expected routing protocol model (multi-agent or ribd). Default is multi-agent\n    \"\"\"\n\n    name = \"VerifyRoutingProtocolModel\"\n    description = (\n        \"Verifies the configured routing protocol model is the expected one and if there is no mismatch between the configured and operating routing protocol model.\"\n    )\n    categories = [\"routing\", \"generic\"]\n    # \"revision\": 3\n    commands = [AntaTestCommand(command=\"show ip route summary\")]\n\n    @AntaTest.anta_test\n    def test(self, model: Optional[str] = \"multi-agent\") -&gt; None:\n\"\"\"Run VerifyRoutingProtocolModel validation\"\"\"\n\n        if not model:\n            self.result.is_skipped(\"VerifyRoutingProtocolModel was not run as no model was given\")\n            return\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        configured_model = command_output[\"protoModelStatus\"][\"configuredProtoModel\"]\n        operating_model = command_output[\"protoModelStatus\"][\"operatingProtoModel\"]\n        if configured_model == operating_model == model:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing model is misconfigured: configured: {configured_model} - operating: {operating_model} - expected: {model}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingProtocolModel.test","title":"<code>test(model='multi-agent')</code>","text":"<p>Run VerifyRoutingProtocolModel validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, model: Optional[str] = \"multi-agent\") -&gt; None:\n\"\"\"Run VerifyRoutingProtocolModel validation\"\"\"\n\n    if not model:\n        self.result.is_skipped(\"VerifyRoutingProtocolModel was not run as no model was given\")\n        return\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    configured_model = command_output[\"protoModelStatus\"][\"configuredProtoModel\"]\n    operating_model = command_output[\"protoModelStatus\"][\"operatingProtoModel\"]\n    if configured_model == operating_model == model:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"routing model is misconfigured: configured: {configured_model} - operating: {operating_model} - expected: {model}\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize","title":"<code>VerifyRoutingTableSize</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>minimum(int)</code> <p>Expected minimum routing table (default VRF) size.</p> required <code>maximum(int)</code> <p>Expected maximum routing table (default VRF) size.</p> required Source code in <code>anta/tests/routing/generic.py</code> <pre><code>class VerifyRoutingTableSize(AntaTest):\n\"\"\"\n    Verifies the size of the IP routing table (default VRF).\n    Should be between the two provided thresholds.\n\n    Args:\n        minimum(int): Expected minimum routing table (default VRF) size.\n        maximum(int): Expected maximum routing table (default VRF) size.\n    \"\"\"\n\n    name = \"VerifyRoutingTableSize\"\n    description = \"Verifies the size of the IP routing table (default VRF). Should be between the two provided thresholds.\"\n    categories = [\"routing\", \"generic\"]\n    # \"revision\": 3\n    commands = [AntaTestCommand(command=\"show ip route summary\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: Optional[int] = None, maximum: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyRoutingTableSize validation\"\"\"\n\n        if not minimum or not maximum:\n            self.result.is_skipped(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} was not provided\")\n            return\n        if not isinstance(minimum, int) or not isinstance(maximum, int):\n            self.result.is_error(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} is not a valid value (integer)\")\n            return\n        if maximum &lt; minimum:\n            self.result.is_error(f\"VerifyRoutingTableSize was not run as minimum {minimum} is greate than maximum {maximum}.\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        total_routes = int(command_output[\"vrfs\"][\"default\"][\"totalRoutes\"])\n        if minimum &lt;= total_routes &lt;= maximum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"routing-table has {total_routes} routes and not between min ({minimum}) and maximum ({maximum})\")\n</code></pre>"},{"location":"api/tests.routing.generic/#anta.tests.routing.generic.VerifyRoutingTableSize.test","title":"<code>test(minimum=None, maximum=None)</code>","text":"<p>Run VerifyRoutingTableSize validation</p> Source code in <code>anta/tests/routing/generic.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: Optional[int] = None, maximum: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyRoutingTableSize validation\"\"\"\n\n    if not minimum or not maximum:\n        self.result.is_skipped(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} was not provided\")\n        return\n    if not isinstance(minimum, int) or not isinstance(maximum, int):\n        self.result.is_error(f\"VerifyRoutingTableSize was not run as either minimum {minimum} or maximum {maximum} is not a valid value (integer)\")\n        return\n    if maximum &lt; minimum:\n        self.result.is_error(f\"VerifyRoutingTableSize was not run as minimum {minimum} is greate than maximum {maximum}.\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    total_routes = int(command_output[\"vrfs\"][\"default\"][\"totalRoutes\"])\n    if minimum &lt;= total_routes &lt;= maximum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"routing-table has {total_routes} routes and not between min ({minimum}) and maximum ({maximum})\")\n</code></pre>"},{"location":"api/tests.routing.ospf/","title":"OSPF","text":""},{"location":"api/tests.routing.ospf/#anta-catalog-for-routing-ospf-tests","title":"ANTA catalog for routing-ospf tests","text":"<p>OSPF test functions</p>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount","title":"<code>VerifyOSPFNeighborCount</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the number of OSPF neighbors in FULL state is the one we expect.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The expected number of OSPF neighbors in FULL state.</p> required Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborCount(AntaTest):\n\"\"\"\n    Verifies the number of OSPF neighbors in FULL state is the one we expect.\n\n    Args:\n        number (int): The expected number of OSPF neighbors in FULL state.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborCount\"\n    description = \"Verifies the number of OSPF neighbors in FULL state is the one we expect.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaTestCommand(command=\"show ip ospf neighbor\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborCount validation\"\"\"\n        if not (isinstance(number, int) and number &gt;= 0):\n            self.result.is_skipped(f\"VerifyOSPFNeighborCount was not run as the number given '{number}' is not a valid value.\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        if (neighbor_count := _count_ospf_neighbor(command_output)) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n\n        self.result.is_success()\n\n        if neighbor_count != number:\n            self.result.is_failure(f\"device has {neighbor_count} neighbors (expected {number})\")\n\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        print(not_full_neighbors)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborCount.test","title":"<code>test(number=None)</code>","text":"<p>Run VerifyOSPFNeighborCount validation</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborCount validation\"\"\"\n    if not (isinstance(number, int) and number &gt;= 0):\n        self.result.is_skipped(f\"VerifyOSPFNeighborCount was not run as the number given '{number}' is not a valid value.\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    if (neighbor_count := _count_ospf_neighbor(command_output)) == 0:\n        self.result.is_skipped(\"no OSPF neighbor found\")\n        return\n\n    self.result.is_success()\n\n    if neighbor_count != number:\n        self.result.is_failure(f\"device has {neighbor_count} neighbors (expected {number})\")\n\n    not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n    print(not_full_neighbors)\n    if not_full_neighbors:\n        self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborState","title":"<code>VerifyOSPFNeighborState</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all OSPF neighbors are in FULL state.</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>class VerifyOSPFNeighborState(AntaTest):\n\"\"\"\n    Verifies all OSPF neighbors are in FULL state.\n    \"\"\"\n\n    name = \"VerifyOSPFNeighborState\"\n    description = \"Verifies all OSPF neighbors are in FULL state.\"\n    categories = [\"routing\", \"ospf\"]\n    commands = [AntaTestCommand(command=\"show ip ospf neighbor\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborState validation\"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        if _count_ospf_neighbor(command_output) == 0:\n            self.result.is_skipped(\"no OSPF neighbor found\")\n            return\n\n        self.result.is_success()\n\n        not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n        if not_full_neighbors:\n            self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.routing.ospf/#anta.tests.routing.ospf.VerifyOSPFNeighborState.test","title":"<code>test()</code>","text":"<p>Run VerifyOSPFNeighborState validation</p> Source code in <code>anta/tests/routing/ospf.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyOSPFNeighborState validation\"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    if _count_ospf_neighbor(command_output) == 0:\n        self.result.is_skipped(\"no OSPF neighbor found\")\n        return\n\n    self.result.is_success()\n\n    not_full_neighbors = _get_not_full_ospf_neighbors(command_output)\n    if not_full_neighbors:\n        self.result.is_failure(f\"Some neighbors are not correctly configured: {not_full_neighbors}.\")\n</code></pre>"},{"location":"api/tests.security/","title":"Security","text":""},{"location":"api/tests.security/#anta-catalog-for-security-tests","title":"ANTA catalog for security tests","text":"<p>Test functions related to the EOS various security settings</p>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpStatus","title":"<code>VerifyAPIHttpStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTP server is disabled globally.</p> Expected Results <ul> <li>success: The test will pass if eAPI HTTP server is disabled globally.</li> <li>failure: The test will fail if eAPI HTTP server is NOT disabled globally.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpStatus(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTP server is disabled globally.\n\n    Expected Results:\n        * success: The test will pass if eAPI HTTP server is disabled globally.\n        * failure: The test will fail if eAPI HTTP server is NOT disabled globally.\n    \"\"\"\n\n    name = \"VerifyAPIHttpStatus\"\n    description = \"Verifies if eAPI HTTP server is disabled globally.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management api http-commands\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyAPIHTTPStatus validation.\n        \"\"\"\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        if command_output[\"enabled\"] and not command_output[\"httpServer\"][\"running\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"eAPI HTTP server is enabled globally\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpStatus.test","title":"<code>test()</code>","text":"<p>Run VerifyAPIHTTPStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyAPIHTTPStatus validation.\n    \"\"\"\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    if command_output[\"enabled\"] and not command_output[\"httpServer\"][\"running\"]:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"eAPI HTTP server is enabled globally\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL","title":"<code>VerifyAPIHttpsSSL</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI HTTPS server SSL profile is configured and valid.</p> Expected results <ul> <li>success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.</li> <li>failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.</li> <li>skipped: The test will be skipped if the SSL profile is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIHttpsSSL(AntaTest):\n\"\"\"\n    Verifies if eAPI HTTPS server SSL profile is configured and valid.\n\n    Expected results:\n        * success: The test will pass if the eAPI HTTPS server SSL profile is configured and valid.\n        * failure: The test will fail if the eAPI HTTPS server SSL profile is NOT configured, misconfigured or invalid.\n        * skipped: The test will be skipped if the SSL profile is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIHttpsSSL\"\n    description = \"Verifies if eAPI HTTPS server SSL profile is configured and valid.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management api http-commands\")]\n\n    @AntaTest.anta_test\n    def test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n        Run VerifyAPIHttpsSSL validation.\n\n        Args:\n            profile: SSL profile to verify.\n        \"\"\"\n        if not profile:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because profile was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        try:\n            if command_output[\"sslProfile\"][\"name\"] == profile and command_output[\"sslProfile\"][\"state\"] == \"valid\":\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is misconfigured or invalid\")\n\n        except KeyError:\n            self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is not configured\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIHttpsSSL.test","title":"<code>test(profile=None)</code>","text":"<p>Run VerifyAPIHttpsSSL validation.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>Optional[str]</code> <p>SSL profile to verify.</p> <code>None</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, profile: Optional[str] = None) -&gt; None:\n\"\"\"\n    Run VerifyAPIHttpsSSL validation.\n\n    Args:\n        profile: SSL profile to verify.\n    \"\"\"\n    if not profile:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because profile was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    try:\n        if command_output[\"sslProfile\"][\"name\"] == profile and command_output[\"sslProfile\"][\"state\"] == \"valid\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is misconfigured or invalid\")\n\n    except KeyError:\n        self.result.is_failure(f\"eAPI HTTPS server SSL profile ({profile}) is not configured\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl","title":"<code>VerifyAPIIPv4Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIIPv4Acl\"\n    description = \"Verifies if eAPI has the right number IPv4 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management api http-commands ip access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyAPIIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} eAPI IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv4Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifyAPIIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for eAPI. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyAPIIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} eAPI IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"eAPI IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl","title":"<code>VerifyAPIIPv6Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyAPIIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if eAPI has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if eAPI has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifyAPIIPv6Acl\"\n    description = \"Verifies if eAPI has the right number IPv6 ACL(s) configured for a specified VRF.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management api http-commands ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifyAPIIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} eAPI IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"eAPI IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyAPIIPv6Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifyAPIIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for eAPI. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifyAPIIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for eAPI. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} eAPI IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"eAPI IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl","title":"<code>VerifySSHIPv4Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySSHIPv4Acl\"\n    description = \"Verifies if the SSHD agent has IPv4 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management ssh ip access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySSHIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SSH IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv4Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySSHIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SSHD agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySSHIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SSH IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SSH IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl","title":"<code>VerifySSHIPv6Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SSHD agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SSHD agent has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySSHIPv6Acl\"\n    description = \"Verifies if the SSHD agent has IPv6 ACL(s) configured.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management ssh ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySSHIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SSH IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SSH IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHIPv6Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySSHIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SSHD agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySSHIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for the SSHD agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SSH IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SSH IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHStatus","title":"<code>VerifySSHStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SSHD agent is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if the SSHD agent is disabled in the default VRF.</li> <li>failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifySSHStatus(AntaTest):\n\"\"\"\n    Verifies if the SSHD agent is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if the SSHD agent is disabled in the default VRF.\n        * failure: The test will fail if the SSHD agent is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifySSHStatus\"\n    description = \"Verifies if the SSHD agent is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management ssh\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySSHStatus validation.\n        \"\"\"\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(str, self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        line = [line for line in command_output.split(\"\\n\") if line.startswith(\"SSHD status\")][0]\n        status = line.split(\"is \")[1]\n\n        if status == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(line)\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifySSHStatus.test","title":"<code>test()</code>","text":"<p>Run VerifySSHStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySSHStatus validation.\n    \"\"\"\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(str, self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    line = [line for line in command_output.split(\"\\n\") if line.startswith(\"SSHD status\")][0]\n    status = line.split(\"is \")[1]\n\n    if status == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(line)\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyTelnetStatus","title":"<code>VerifyTelnetStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if Telnet is disabled in the default VRF.</p> Expected Results <ul> <li>success: The test will pass if Telnet is disabled in the default VRF.</li> <li>failure: The test will fail if Telnet is NOT disabled in the default VRF.</li> </ul> Source code in <code>anta/tests/security.py</code> <pre><code>class VerifyTelnetStatus(AntaTest):\n\"\"\"\n    Verifies if Telnet is disabled in the default VRF.\n\n    Expected Results:\n        * success: The test will pass if Telnet is disabled in the default VRF.\n        * failure: The test will fail if Telnet is NOT disabled in the default VRF.\n    \"\"\"\n\n    name = \"VerifyTelnetStatus\"\n    description = \"Verifies if Telnet is disabled in the default VRF.\"\n    categories = [\"security\"]\n    commands = [AntaTestCommand(command=\"show management telnet\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyTelnetStatus validation.\n        \"\"\"\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        if command_output[\"serverState\"] == \"disabled\":\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Telnet status for Default VRF is enabled\")\n</code></pre>"},{"location":"api/tests.security/#anta.tests.security.VerifyTelnetStatus.test","title":"<code>test()</code>","text":"<p>Run VerifyTelnetStatus validation.</p> Source code in <code>anta/tests/security.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyTelnetStatus validation.\n    \"\"\"\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Any], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    if command_output[\"serverState\"] == \"disabled\":\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Telnet status for Default VRF is enabled\")\n</code></pre>"},{"location":"api/tests.snmp/","title":"SNMP","text":""},{"location":"api/tests.snmp/#anta-catalog-for-snmp-tests","title":"ANTA catalog for SNMP tests","text":"<p>Test functions related to the EOS various SNMP settings</p>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl","title":"<code>VerifySnmpIPv4Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv4Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv4 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv4 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv4 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv4 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpIPv4Acl\"\n    description = \"Verifies if the SNMP agent has IPv4 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaTestCommand(command=\"show snmp ipv4 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpIPv4Acl validation.\n\n        Args:\n            number: The number of expected IPv4 ACL(s).\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n        ipv4_acl_number = len(ipv4_acl_list)\n        not_configured_acl_list = []\n\n        if ipv4_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SNMP IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n            return\n\n        for ipv4_acl in ipv4_acl_list:\n            if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv4Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySnmpIPv4Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv4 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpIPv4Acl validation.\n\n    Args:\n        number: The number of expected IPv4 ACL(s).\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    ipv4_acl_list = command_output[\"ipAclList\"][\"aclList\"]\n    ipv4_acl_number = len(ipv4_acl_list)\n    not_configured_acl_list = []\n\n    if ipv4_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SNMP IPv4 ACL(s) in vrf {vrf} but got {ipv4_acl_number}\")\n        return\n\n    for ipv4_acl in ipv4_acl_list:\n        if vrf not in ipv4_acl[\"configuredVrfs\"] or vrf not in ipv4_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv4_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SNMP IPv4 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl","title":"<code>VerifySnmpIPv6Acl</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.</p> Expected results <ul> <li>success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.</li> <li>skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpIPv6Acl(AntaTest):\n\"\"\"\n    Verifies if the SNMP agent has the right number IPv6 ACL(s) configured for a specified VRF.\n\n    Expected results:\n        * success: The test will pass if the SNMP agent has the provided number of IPv6 ACL(s) in the specified VRF.\n        * failure: The test will fail if the SNMP agent has not the right number of IPv6 ACL(s) in the specified VRF.\n        * skipped: The test will be skipped if the number of IPv6 ACL(s) or VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpIPv6Acl\"\n    description = \"Verifies if the SNMP agent has IPv6 ACL(s) configured.\"\n    categories = [\"snmp\"]\n    commands = [AntaTestCommand(command=\"show snmp ipv6 access-list summary\")]\n\n    @AntaTest.anta_test\n    def test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpIPv6Acl validation.\n\n        Args:\n            number: The number of expected IPv6 ACL(s).\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not number or not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n            return\n\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n        ipv6_acl_number = len(ipv6_acl_list)\n        not_configured_acl_list = []\n\n        if ipv6_acl_number != number:\n            self.result.is_failure(f\"Expected {number} SNMP IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n            return\n\n        for ipv6_acl in ipv6_acl_list:\n            if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n                not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n        if not_configured_acl_list:\n            self.result.is_failure(f\"SNMP IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n        else:\n            self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpIPv6Acl.test","title":"<code>test(number=None, vrf='default')</code>","text":"<p>Run VerifySnmpIPv6Acl validation.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>Optional[int]</code> <p>The number of expected IPv6 ACL(s).</p> <code>None</code> <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, number: Optional[int] = None, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpIPv6Acl validation.\n\n    Args:\n        number: The number of expected IPv6 ACL(s).\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not number or not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because number or vrf was not supplied\")\n        return\n\n    self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n    command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n    self.logger.debug(f\"dataset is: {command_output}\")\n\n    ipv6_acl_list = command_output[\"ipv6AclList\"][\"aclList\"]\n    ipv6_acl_number = len(ipv6_acl_list)\n    not_configured_acl_list = []\n\n    if ipv6_acl_number != number:\n        self.result.is_failure(f\"Expected {number} SNMP IPv6 ACL(s) in vrf {vrf} but got {ipv6_acl_number}\")\n        return\n\n    for ipv6_acl in ipv6_acl_list:\n        if vrf not in ipv6_acl[\"configuredVrfs\"] or vrf not in ipv6_acl[\"activeVrfs\"]:\n            not_configured_acl_list.append(ipv6_acl[\"name\"])\n\n    if not_configured_acl_list:\n        self.result.is_failure(f\"SNMP IPv6 ACL(s) not configured or active in vrf {vrf}: {not_configured_acl_list}\")\n    else:\n        self.result.is_success()\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus","title":"<code>VerifySnmpStatus</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies whether the SNMP agent is enabled in a specified VRF.</p> Expected Results <ul> <li>success: The test will pass if the SNMP agent is enabled in the specified VRF.</li> <li>failure: The test will fail if the SNMP agent is disabled in the specified VRF.</li> <li>skipped: The test will be skipped if the VRF parameter is not provided.</li> </ul> Source code in <code>anta/tests/snmp.py</code> <pre><code>class VerifySnmpStatus(AntaTest):\n\"\"\"\n    Verifies whether the SNMP agent is enabled in a specified VRF.\n\n    Expected Results:\n        * success: The test will pass if the SNMP agent is enabled in the specified VRF.\n        * failure: The test will fail if the SNMP agent is disabled in the specified VRF.\n        * skipped: The test will be skipped if the VRF parameter is not provided.\n    \"\"\"\n\n    name = \"VerifySnmpStatus\"\n    description = \"Verifies if the SNMP agent is enabled.\"\n    categories = [\"snmp\"]\n    commands = [AntaTestCommand(command=\"show snmp\")]\n\n    @AntaTest.anta_test\n    def test(self, vrf: str = \"default\") -&gt; None:\n\"\"\"\n        Run VerifySnmpStatus validation.\n\n        Args:\n            vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n        \"\"\"\n        if not vrf:\n            self.result.is_skipped(f\"{self.__class__.name} did not run because vrf was not supplied\")\n        else:\n            self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n            command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n            self.logger.debug(f\"dataset is: {command_output}\")\n\n            if command_output[\"enabled\"] and vrf in command_output[\"vrfs\"][\"snmpVrfs\"]:\n                self.result.is_success()\n            else:\n                self.result.is_failure(f\"SNMP agent disabled in vrf {vrf}\")\n</code></pre>"},{"location":"api/tests.snmp/#anta.tests.snmp.VerifySnmpStatus.test","title":"<code>test(vrf='default')</code>","text":"<p>Run VerifySnmpStatus validation.</p> <p>Parameters:</p> Name Type Description Default <code>vrf</code> <code>str</code> <p>The name of the VRF in which to check for the SNMP agent. Defaults to \u2018default\u2019.</p> <code>'default'</code> Source code in <code>anta/tests/snmp.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, vrf: str = \"default\") -&gt; None:\n\"\"\"\n    Run VerifySnmpStatus validation.\n\n    Args:\n        vrf: The name of the VRF in which to check for the SNMP agent. Defaults to 'default'.\n    \"\"\"\n    if not vrf:\n        self.result.is_skipped(f\"{self.__class__.name} did not run because vrf was not supplied\")\n    else:\n        self.logger.debug(f\"self.instance_commands is: {self.instance_commands}\")\n        command_output = cast(Dict[str, Dict[str, Any]], self.instance_commands[0].output)\n        self.logger.debug(f\"dataset is: {command_output}\")\n\n        if command_output[\"enabled\"] and vrf in command_output[\"vrfs\"][\"snmpVrfs\"]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"SNMP agent disabled in vrf {vrf}\")\n</code></pre>"},{"location":"api/tests.software/","title":"Software","text":""},{"location":"api/tests.software/#anta-catalog-for-software-tests","title":"ANTA catalog for software tests","text":"<p>Test functions related to the EOS software</p>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSExtensions","title":"<code>VerifyEOSExtensions</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies all EOS extensions installed on the device are enabled for boot persistence.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSExtensions(AntaTest):\n\"\"\"\n    Verifies all EOS extensions installed on the device are enabled for boot persistence.\n    \"\"\"\n\n    name = \"VerifyEOSExtensions\"\n    description = \"Verifies all EOS extensions installed on the device are enabled for boot persistence.\"\n    categories = [\"software\"]\n    commands = [AntaTestCommand(command=\"show extensions\"), AntaTestCommand(command=\"show boot-extensions\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"Run VerifyEOSExtensions validation\"\"\"\n\n        boot_extensions = []\n\n        show_extensions_command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        show_boot_extensions_command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[1].output)\n\n        installed_extensions = [\n            extension for extension, extension_data in show_extensions_command_output[\"extensions\"].items() if extension_data[\"status\"] == \"installed\"\n        ]\n\n        for extension in show_boot_extensions_command_output[\"extensions\"]:\n            extension = extension.strip(\"\\n\")\n            if extension != \"\":\n                boot_extensions.append(extension)\n\n        installed_extensions.sort()\n        boot_extensions.sort()\n        if installed_extensions == boot_extensions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Missing EOS extensions: installed {installed_extensions} / configured: {boot_extensions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSExtensions.test","title":"<code>test()</code>","text":"<p>Run VerifyEOSExtensions validation</p> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"Run VerifyEOSExtensions validation\"\"\"\n\n    boot_extensions = []\n\n    show_extensions_command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    show_boot_extensions_command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[1].output)\n\n    installed_extensions = [\n        extension for extension, extension_data in show_extensions_command_output[\"extensions\"].items() if extension_data[\"status\"] == \"installed\"\n    ]\n\n    for extension in show_boot_extensions_command_output[\"extensions\"]:\n        extension = extension.strip(\"\\n\")\n        if extension != \"\":\n            boot_extensions.append(extension)\n\n    installed_extensions.sort()\n    boot_extensions.sort()\n    if installed_extensions == boot_extensions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Missing EOS extensions: installed {installed_extensions} / configured: {boot_extensions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion","title":"<code>VerifyEOSVersion</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed EOS version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyEOSVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed EOS version.\n    \"\"\"\n\n    name = \"VerifyEOSVersion\"\n    description = \"Verifies the device is running one of the allowed EOS version.\"\n    categories = [\"software\"]\n    commands = [AntaTestCommand(command=\"show version\")]\n\n    @AntaTest.anta_test\n    def test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyEOSVersion validation\n        versions (list): List of allowed EOS versions.\"\"\"\n        if not versions:\n            self.result.is_skipped(\"VerifyEOSVersion was not run as no versions were given\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        if command_output[\"version\"] in versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f'device is running version {command_output[\"version\"]} not in expected versions: {versions}')\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyEOSVersion.test","title":"<code>test(versions=None)</code>","text":"<p>Run VerifyEOSVersion validation versions (list): List of allowed EOS versions.</p> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"Run VerifyEOSVersion validation\n    versions (list): List of allowed EOS versions.\"\"\"\n    if not versions:\n        self.result.is_skipped(\"VerifyEOSVersion was not run as no versions were given\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    if command_output[\"version\"] in versions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f'device is running version {command_output[\"version\"]} not in expected versions: {versions}')\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion","title":"<code>VerifyTerminAttrVersion</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device is running one of the allowed TerminAttr version.</p> Source code in <code>anta/tests/software.py</code> <pre><code>class VerifyTerminAttrVersion(AntaTest):\n\"\"\"\n    Verifies the device is running one of the allowed TerminAttr version.\n    \"\"\"\n\n    name = \"VerifyTerminAttrVersion\"\n    description = \"Verifies the device is running one of the allowed TerminAttr version.\"\n    categories = [\"software\"]\n    commands = [AntaTestCommand(command=\"show version detail\")]\n\n    @AntaTest.anta_test\n    def test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n        Run VerifyTerminAttrVersion validation\n                versions (list): List of allowed TerminAttr versions.\n        \"\"\"\n\n        if not versions:\n            self.result.is_skipped(\"VerifyTerminAttrVersion was not run as no versions were given\")\n            return\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        command_output_data = command_output[\"details\"][\"packages\"][\"TerminAttr-core\"][\"version\"]\n        if command_output_data in versions:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device is running TerminAttr version {command_output_data} and is not in the allowed list: {versions}\")\n</code></pre>"},{"location":"api/tests.software/#anta.tests.software.VerifyTerminAttrVersion.test","title":"<code>test(versions=None)</code>","text":"<p>Run VerifyTerminAttrVersion validation         versions (list): List of allowed TerminAttr versions.</p> Source code in <code>anta/tests/software.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, versions: Optional[List[str]] = None) -&gt; None:\n\"\"\"\n    Run VerifyTerminAttrVersion validation\n            versions (list): List of allowed TerminAttr versions.\n    \"\"\"\n\n    if not versions:\n        self.result.is_skipped(\"VerifyTerminAttrVersion was not run as no versions were given\")\n        return\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    command_output_data = command_output[\"details\"][\"packages\"][\"TerminAttr-core\"][\"version\"]\n    if command_output_data in versions:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device is running TerminAttr version {command_output_data} and is not in the allowed list: {versions}\")\n</code></pre>"},{"location":"api/tests.system/","title":"System","text":""},{"location":"api/tests.system/#anta-catalog-for-system-tests","title":"ANTA catalog for system tests","text":"<p>Test functions related to system-level features and protocols</p>"},{"location":"api/tests.system/#anta.tests.system.VerifyAgentLogs","title":"<code>VerifyAgentLogs</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no agent crash reported on the device.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyAgentLogs(AntaTest):\n\"\"\"\n    Verifies there is no agent crash reported on the device.\n    \"\"\"\n\n    name = \"VerifyAgentLogs\"\n    description = \"Verifies there is no agent crash reported on the device.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"show agent logs crash\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyAgentLogs validation\n        \"\"\"\n        command_output = cast(str, self.instance_commands[0].output)\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device reported some agent crashes: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyAgentLogs.test","title":"<code>test()</code>","text":"<p>Run VerifyAgentLogs validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyAgentLogs validation\n    \"\"\"\n    command_output = cast(str, self.instance_commands[0].output)\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device reported some agent crashes: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCPUUtilization","title":"<code>VerifyCPUUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the CPU utilization is less than 75%.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCPUUtilization(AntaTest):\n\"\"\"\n    Verifies the CPU utilization is less than 75%.\n    \"\"\"\n\n    name = \"VerifyCPUUtilization\"\n    description = \"Verifies the CPU utilization is less than 75%.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"show processes top once\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyCPUUtilization validation\n        \"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n        command_output_data = command_output[\"cpuInfo\"][\"%Cpu(s)\"][\"idle\"]\n\n        if command_output_data &gt; 25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device reported a high CPU utilization ({100 - command_output_data}%)\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCPUUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyCPUUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyCPUUtilization validation\n    \"\"\"\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n    command_output_data = command_output[\"cpuInfo\"][\"%Cpu(s)\"][\"idle\"]\n\n    if command_output_data &gt; 25:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device reported a high CPU utilization ({100 - command_output_data}%)\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCoredump","title":"<code>VerifyCoredump</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies there is no core file.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyCoredump(AntaTest):\n\"\"\"\n    Verifies there is no core file.\n    \"\"\"\n\n    name = \"VerifyCoredump\"\n    description = \"Verifies there is no core file.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"bash timeout 10 ls /var/core\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyCoredump validation\n        \"\"\"\n        command_output = cast(str, self.instance_commands[0].output)\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Core-dump(s) have been found: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyCoredump.test","title":"<code>test()</code>","text":"<p>Run VerifyCoredump validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyCoredump validation\n    \"\"\"\n    command_output = cast(str, self.instance_commands[0].output)\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Core-dump(s) have been found: {command_output}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyFileSystemUtilization","title":"<code>VerifyFileSystemUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies each partition on the disk is used less than 75%.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyFileSystemUtilization(AntaTest):\n\"\"\"\n    Verifies each partition on the disk is used less than 75%.\n    \"\"\"\n\n    name = \"VerifyFileSystemUtilization\"\n    description = \"Verifies each partition on the disk is used less than 75%.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"bash timeout 10 df -h\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyFileSystemUtilization validation\n        \"\"\"\n        command_output = cast(str, self.instance_commands[0].output)\n\n        self.result.is_success()\n\n        for line in command_output.split(\"\\n\")[1:]:\n            if \"loop\" not in line and len(line) &gt; 0 and (percentage := int(line.split()[4].replace(\"%\", \"\"))) &gt; 75:\n                self.result.is_failure(f\"mount point {line} is higher than 75% (reported {percentage})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyFileSystemUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyFileSystemUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyFileSystemUtilization validation\n    \"\"\"\n    command_output = cast(str, self.instance_commands[0].output)\n\n    self.result.is_success()\n\n    for line in command_output.split(\"\\n\")[1:]:\n        if \"loop\" not in line and len(line) &gt; 0 and (percentage := int(line.split()[4].replace(\"%\", \"\"))) &gt; 75:\n            self.result.is_failure(f\"mount point {line} is higher than 75% (reported {percentage})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyMemoryUtilization","title":"<code>VerifyMemoryUtilization</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the Memory utilization is less than 75%.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyMemoryUtilization(AntaTest):\n\"\"\"\n    Verifies the Memory utilization is less than 75%.\n    \"\"\"\n\n    name = \"VerifyMemoryUtilization\"\n    description = \"Verifies the Memory utilization is less than 75%.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"show version\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyMemoryUtilization validation\n        \"\"\"\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        memory_usage = float(cast(float, command_output[\"memFree\"])) / float(cast(float, command_output[\"memTotal\"]))\n        if memory_usage &gt; 0.25:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"device report a high memory usage: {(1 - memory_usage)*100:.2f}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyMemoryUtilization.test","title":"<code>test()</code>","text":"<p>Run VerifyMemoryUtilization validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyMemoryUtilization validation\n    \"\"\"\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    memory_usage = float(cast(float, command_output[\"memFree\"])) / float(cast(float, command_output[\"memTotal\"]))\n    if memory_usage &gt; 0.25:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"device report a high memory usage: {(1 - memory_usage)*100:.2f}%\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyNTP","title":"<code>VerifyNTP</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies NTP is synchronised.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyNTP(AntaTest):\n\"\"\"\n    Verifies NTP is synchronised.\n    \"\"\"\n\n    name = \"VerifyNTP\"\n    description = \"Verifies NTP is synchronised.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"show ntp status\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyNTP validation\n        \"\"\"\n        command_output = cast(str, self.instance_commands[0].output)\n\n        if command_output.split(\"\\n\")[0].split(\" \")[0] == \"synchronised\":\n            self.result.is_success()\n        else:\n            data = command_output.split(\"\\n\")[0]\n            self.result.is_failure(f\"not sync with NTP server ({data})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyNTP.test","title":"<code>test()</code>","text":"<p>Run VerifyNTP validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyNTP validation\n    \"\"\"\n    command_output = cast(str, self.instance_commands[0].output)\n\n    if command_output.split(\"\\n\")[0].split(\" \")[0] == \"synchronised\":\n        self.result.is_success()\n    else:\n        data = command_output.split(\"\\n\")[0]\n        self.result.is_failure(f\"not sync with NTP server ({data})\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyReloadCause","title":"<code>VerifyReloadCause</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the last reload of the device was requested by a user.</p> <p>Test considers the following messages as normal and will return success. Failure is for other messages * Reload requested by the user. * Reload requested after FPGA upgrade</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyReloadCause(AntaTest):\n\"\"\"\n    Verifies the last reload of the device was requested by a user.\n\n    Test considers the following messages as normal and will return success. Failure is for other messages\n    * Reload requested by the user.\n    * Reload requested after FPGA upgrade\n    \"\"\"\n\n    name = \"VerifyReloadCause\"\n    description = \"Verifies the device uptime is higher than a value.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"show reload cause\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifyReloadCause validation\n        \"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        if \"resetCauses\" not in command_output.keys():\n            self.result.is_error(\"no reload cause available\")\n            return\n\n        if len(command_output[\"resetCauses\"]) == 0:\n            # No reload causes\n            self.result.is_success()\n            return\n\n        reset_causes = cast(List[Dict[str, Any]], command_output[\"resetCauses\"])\n        command_output_data = reset_causes[0].get(\"description\")\n        if command_output_data in [\n            \"Reload requested by the user.\",\n            \"Reload requested after FPGA upgrade\",\n        ]:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Reload cause is {command_output_data}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyReloadCause.test","title":"<code>test()</code>","text":"<p>Run VerifyReloadCause validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifyReloadCause validation\n    \"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    if \"resetCauses\" not in command_output.keys():\n        self.result.is_error(\"no reload cause available\")\n        return\n\n    if len(command_output[\"resetCauses\"]) == 0:\n        # No reload causes\n        self.result.is_success()\n        return\n\n    reset_causes = cast(List[Dict[str, Any]], command_output[\"resetCauses\"])\n    command_output_data = reset_causes[0].get(\"description\")\n    if command_output_data in [\n        \"Reload requested by the user.\",\n        \"Reload requested after FPGA upgrade\",\n    ]:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Reload cause is {command_output_data}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifySyslog","title":"<code>VerifySyslog</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifySyslog(AntaTest):\n\"\"\"\n    Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days.\n    \"\"\"\n\n    name = \"VerifySyslog\"\n    description = \"Verifies the device had no syslog message with a severity of warning (or a more severe message) during the last 7 days.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"show logging last 7 days threshold warnings\", ofmt=\"text\")]\n\n    @AntaTest.anta_test\n    def test(self) -&gt; None:\n\"\"\"\n        Run VerifySyslog validation\n        \"\"\"\n        command_output = cast(str, self.instance_commands[0].output)\n\n        if len(command_output) == 0:\n            self.result.is_success()\n        else:\n            self.result.is_failure(\"Device has some log messages with a severity WARNING or higher\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifySyslog.test","title":"<code>test()</code>","text":"<p>Run VerifySyslog validation</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self) -&gt; None:\n\"\"\"\n    Run VerifySyslog validation\n    \"\"\"\n    command_output = cast(str, self.instance_commands[0].output)\n\n    if len(command_output) == 0:\n        self.result.is_success()\n    else:\n        self.result.is_failure(\"Device has some log messages with a severity WARNING or higher\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime","title":"<code>VerifyUptime</code>","text":"<p>         Bases: <code>AntaTest</code></p> <p>Verifies the device uptime is higher than a value.</p> Source code in <code>anta/tests/system.py</code> <pre><code>class VerifyUptime(AntaTest):\n\"\"\"\n    Verifies the device uptime is higher than a value.\n    \"\"\"\n\n    name = \"VerifyUptime\"\n    description = \"Verifies the device uptime is higher than a value.\"\n    categories = [\"system\"]\n    commands = [AntaTestCommand(command=\"show uptime\")]\n\n    @AntaTest.anta_test\n    def test(self, minimum: int = -1) -&gt; None:\n\"\"\"\n        Run VerifyUptime validation\n        minimum (int): Minimum uptime in seconds.\n        \"\"\"\n\n        command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n        if not (isinstance(minimum, (int, float))) or minimum &lt; 0:\n            self.result.is_skipped(\"VerifyUptime was not run as no minimum uptime was given\")\n            return\n\n        if cast(float, command_output[\"upTime\"]) &gt; minimum:\n            self.result.is_success()\n        else:\n            self.result.is_failure(f\"Uptime is {command_output['upTime']}\")\n</code></pre>"},{"location":"api/tests.system/#anta.tests.system.VerifyUptime.test","title":"<code>test(minimum=-1)</code>","text":"<p>Run VerifyUptime validation minimum (int): Minimum uptime in seconds.</p> Source code in <code>anta/tests/system.py</code> <pre><code>@AntaTest.anta_test\ndef test(self, minimum: int = -1) -&gt; None:\n\"\"\"\n    Run VerifyUptime validation\n    minimum (int): Minimum uptime in seconds.\n    \"\"\"\n\n    command_output = cast(Dict[str, Dict[Any, Any]], self.instance_commands[0].output)\n\n    if not (isinstance(minimum, (int, float))) or minimum &lt; 0:\n        self.result.is_skipped(\"VerifyUptime was not run as no minimum uptime was given\")\n        return\n\n    if cast(float, command_output[\"upTime\"]) &gt; minimum:\n        self.result.is_success()\n    else:\n        self.result.is_failure(f\"Uptime is {command_output['upTime']}\")\n</code></pre>"},{"location":"cli/debug/","title":"Helpers","text":""},{"location":"cli/debug/#anta-debug-commands","title":"ANTA debug commands","text":"<p>ANTA CLI also provides a set of entrypoints to help building ANTA content. We call it debug and it provides different options:</p> <ul> <li>Run a command on a device from your inventory and expose a result from AntaTestCommand</li> <li>Run a templated command and expose the result</li> </ul> <p>Both are extremly useful to build your test since you have a visual access to the output you have to test. It also helps to extract content to use for unit test as descirbed in our contribution guide.</p> <p>Use your inventory</p> <p>Because it is based on ANTA cli, all your commands use an ANTA inventory and require to get a valid one.</p>"},{"location":"cli/debug/#get-result-of-an-eos-command","title":"Get result of an EOS command","text":"<p>To run a command, you can leverage <code>run-cmd</code> entrypoint with following options:</p> <pre><code>$ anta debug run-cmd --help\nUsage: anta debug run-cmd [OPTIONS]\n\nRun arbitrary command to an EOS device and get result using eAPI\n\nOptions:\n  -c, --command TEXT             Command to run on EOS using eAPI  [required]\n--ofmt [text|json]             eAPI format to use. can be text or json\n  --api-version, --version TEXT  Version of the command through eAPI\n  -d, --device TEXT              Device from inventory to use  [required]\n--log-level, --log TEXT        Logging level of the command\n--help                         Show this message and exit.\n</code></pre> <p>In practice, this command is very simple to use. Here is an example using <code>show interfaces description</code> with a <code>JSON</code> format:</p> <pre><code>anta debug run-cmd -c \"show interfaces description\" --device ptt015\nrun command show interfaces description on ptt015\n{\n'interfaceDescriptions': {\n'Ethernet8': {'interfaceStatus': 'adminDown', 'description': '', 'lineProtocolStatus': 'down'},\n        'Ethernet9': {'interfaceStatus': 'adminDown', 'description': '', 'lineProtocolStatus': 'down'},\n        'Ethernet12': {'interfaceStatus': 'adminDown', 'description': '', 'lineProtocolStatus': 'down'},\n    ...\n}\n</code></pre>"},{"location":"cli/debug/#get-result-of-an-eos-command-using-templates","title":"Get result of an EOS command using templates","text":"<p>This command allows user to provide an <code>f-string</code> and a list of dictionary to run a command dynamically. Idea is to help building output for test using such approach.</p> <pre><code>$ anta debug run-template --help\nUsage: anta debug run-template [OPTIONS]\n\nRun arbitrary command to an EOS device and get result using eAPI\n\nOptions:\n  -t, --template TEXT            Command template to run on EOS using eAPI\n  -p, --params TEXT              Command parameters to use with template. Must\n                                 be a JSON string for a list of dict\n                                 [required]\n--ofmt [text|json]             eAPI format to use. can be text or json\n  --api-version, --version TEXT  Version of the command through eAPI\n  -d, --device TEXT              Device from inventory to use  [required]\n--log-level, --log TEXT        Logging level of the command\n--help                         Show this message and exit.\n</code></pre> <p>In practice, this command is very simple to use. Here is an example using <code>show lldp neighbors</code> with a <code>JSON</code> format for only 2 interfaces: Ethernet1 and Ethernet2</p> <pre><code>anta debug run-template \\\n--params \"[{\"ifd\": \"Ethernet1\"}, {\"ifd\":\"Ethernet2\"}]\" \\\n--template \"show lldp neighbors {ifd}\" \\\n--device ptt015\n\nrun dynmic command show lldp neighbors {ifd} with [{\"ifd\": \"Ethernet1\"}, {\"ifd\":\"Ethernet2\"}] on ptt015\nrun_command = show lldp neighbors Ethernet1 ptt015\n{\n\"tablesLastChangeTime\": 1682498936.0082116,\n  \"tablesAgeOuts\": 0,\n  \"tablesInserts\": 1,\n  \"lldpNeighbors\": [],\n  \"tablesDeletes\": 0,\n  \"tablesDrops\": 0\n}\nrun_command = show lldp neighbors Ethernet2 ptt015\n{\n\"tablesLastChangeTime\": 1682498936.008321,\n  \"tablesAgeOuts\": 0,\n  \"tablesInserts\": 1,\n  \"lldpNeighbors\": [],\n  \"tablesDeletes\": 0,\n  \"tablesDrops\": 0\n}\n</code></pre>"},{"location":"cli/exec/","title":"Execute commands","text":""},{"location":"cli/exec/#execute-commands-on-devices","title":"Execute commands on devices","text":"<p>ANTA CLI also provides a set of entrypoints to execute commands remotely on EOS devices.</p>"},{"location":"cli/exec/#clear-interfaces-counters","title":"Clear interfaces counters","text":"<p>This command clear interfaces counters on EOS devices defined in your inventory</p> <pre><code>$ anta exec clear-counters --help\nUsage: anta exec clear-counters [OPTIONS]\n\nClear counter statistics on EOS devices\n\nOptions:\n  -t, --tags TEXT                 List of tags using comma as separator:\n                                  tag1,tag2,tag3\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre>"},{"location":"cli/exec/#collect-a-set-of-commands","title":"Collect a set of commands","text":"<p>This command collects all commands you defined in a catalog. It can be either <code>json</code> or <code>text</code>.</p> <pre><code>$ anta exec snapshot --help\nUsage: anta exec snapshot [OPTIONS]\n\nCollect commands output from devices in inventory\n\nOptions:\n  -t, --tags TEXT                 List of tags using comma as separator:\n                                  tag1,tag2,tag3\n  -c, --commands-list PATH        File with list of commands to grab  [env\n                                  var: ANTA_EXEC_SNAPSHOT_COMMANDS_LIST]\n-outut, -o, --output-directory PATH\n                                  Path where to save commands output  [env\n                                  var: ANTA_EXEC_SNAPSHOT_OUTPUT_DIRECTORY]\n--log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre> <p>And structure of your catalog file should be:</p> <pre><code>json_format:\n- show version\ntext_format:\n- show agent logs crash\n- show bfd peers\n- show bgp evpn\n</code></pre>"},{"location":"cli/exec/#get-scheduled-tech-support","title":"Get Scheduled tech-support","text":"<p>EOS comes with a feature that generates tech-support archive every 1 hour by default and save this archive under <code>/mnt/flash/schedule/tech-support</code></p> <pre><code>leaf1#show schedule summary\nMaximum concurrent jobs  1\nPrepend host name to logfile: Yes\nName                 At Time       Last        Interval       Timeout        Max        Max     Logfile Location                  Status\n                                   Time         (mins)        (mins)         Log        Logs\n                                                                            Files       Size\n----------------- ------------- ----------- -------------- ------------- ----------- ---------- --------------------------------- ------\ntech-support           now         08:37          60            30           100         -      flash:schedule/tech-support/      Success\n\n\nleaf1#bash ls /mnt/flash/schedule/tech-support\nleaf1_tech-support_2023-03-09.1337.log.gz  leaf1_tech-support_2023-03-10.0837.log.gz  leaf1_tech-support_2023-03-11.0337.log.gz  ...\n</code></pre> <p>As it can be useful for an NRFU to save a very complete state report before a go live, ANTA has implemented a CLI that retrieves these files very easily:</p> <pre><code>\u276f anta exec collect-tech-support --help\n\nUsage: anta exec collect-tech-support [OPTIONS]\n\nCollect scheduled tech-support from eos devices.\n\nOptions:\n  -o, --output PATH               Path for tests catalog  [default: ./tech-\n                                  support]\n-ssh, --ssh-port INTEGER        SSH port to use for connection  [default:\n                                  22]\n--insecure / --secure           Disable SSH Host Key validation  [default:\n                                  secure]\n--latest INTEGER                Number of scheduled show-tech to retrieve\n  --configure / --not-configure   Ensure device has 'aaa authorization exec\n                                  default local' configured (required for SCP)\n[default: not-configure]\n-t, --tags TEXT                 List of tags using coma as separator:\n                                  tag1,tag2,tag3\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command  [default:\n                                  info]\n--help                          Show this message and exit.\n</code></pre> <p>When you run this command, it will retrieve tech-support files and download it locally in a folder and a subfolder per device. You can change the default output folder with the <code>--output</code> option. ANTA download files from the devices using SCP, all SSH Host Key devices must be trusted prior to run the command, otherwise use the <code>--insecure</code> option. In order to use SCP with EOS, the configuration <code>aaa authorization exec default local</code> must be present on the devices. By default, ANTA will not configure this automatically, unless <code>--configure</code> is specified. It is possible to retrieve only the latest tech-support files using the <code>--latest</code> option.</p> <pre><code>\u276f anta exec collect-tech-support --insecure\n[15:27:19] INFO     Connecting to devices...\nINFO     Copying '/mnt/flash/schedule/tech-support/spine1_tech-support_2023-06-09.1315.log.gz' from device spine1 to 'tech-support/spine1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf3_tech-support_2023-06-09.1315.log.gz' from device leaf3 to 'tech-support/leaf3' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf1_tech-support_2023-06-09.1315.log.gz' from device leaf1 to 'tech-support/leaf1' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf2_tech-support_2023-06-09.1315.log.gz' from device leaf2 to 'tech-support/leaf2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/spine2_tech-support_2023-06-09.1315.log.gz' from device spine2 to 'tech-support/spine2' locally\nINFO     Copying '/mnt/flash/schedule/tech-support/leaf4_tech-support_2023-06-09.1315.log.gz' from device leaf4 to 'tech-support/leaf4' locally\nINFO     Collected 1 scheduled tech-support from leaf2\nINFO     Collected 1 scheduled tech-support from spine2\nINFO     Collected 1 scheduled tech-support from leaf3\nINFO     Collected 1 scheduled tech-support from spine1\nINFO     Collected 1 scheduled tech-support from leaf1\nINFO     Collected 1 scheduled tech-support from leaf4\n</code></pre> <p>The output folder will look like this:</p> <pre><code>\u276f tree tech-support/\ntech-support/\n\u251c\u2500\u2500 leaf1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf1_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf2\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf2_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf3\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf3_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 leaf4\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 leaf4_tech-support_2023-06-09.1315.log.gz\n\u251c\u2500\u2500 spine1\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 spine1_tech-support_2023-06-09.1315.log.gz\n\u2514\u2500\u2500 spine2\n    \u2514\u2500\u2500 spine2_tech-support_2023-06-09.1315.log.gz\n\n6 directories, 6 files\n</code></pre>"},{"location":"cli/get-inventory-information/","title":"Get Inventory Information","text":""},{"location":"cli/get-inventory-information/#get-inventory-information","title":"Get Inventory Information","text":"<p>ANTA CLI provides a set of entrypoints to get data from your local inventory.</p>"},{"location":"cli/get-inventory-information/#get-all-configured-tags","title":"Get all configured tags","text":"<p>Since most commands in anta support tags filtering, this command helps you list all available tags configured in your inventory.</p>"},{"location":"cli/get-inventory-information/#command-overview","title":"Command overview","text":"<pre><code>anta get tags --help\nUsage: anta get tags [OPTIONS]\n\nGet list of configured tags in user inventory.\n\nOptions:\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre>"},{"location":"cli/get-inventory-information/#example","title":"Example","text":"<p>Let\u2019s consider the following inventory:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>To get the list of all configured tags in your CLI, run the following command:</p> <pre><code>$ anta get tags\nTags found:\n[\n\"all\",\n  \"fabric\",\n  \"leaf\",\n  \"spine\"\n]\nNone\n\n* note that tag all has been added by anta\n</code></pre> <p>Tip</p> <p>As you can see, the tag <code>all</code> has been added even if not explicitely configued in your inventory. This tag is the default tag added to all your devices to run commands against your inventory when you do not provide any specific tag.</p>"},{"location":"cli/get-inventory-information/#list-devices-in-inventory","title":"List devices in inventory","text":""},{"location":"cli/get-inventory-information/#command-overview_1","title":"Command overview","text":"<p>To get a list of all devices available in your inventory with ANTA, use the following command</p> <pre><code>anta get inventory --help\nUsage: anta get inventory [OPTIONS]\n\nShow inventory loaded in ANTA.\n\nOptions:\n  -t, --tags TEXT                 List of tags using comma as separator:\n                                  tag1,tag2,tag3\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--connected / --not-connected   Display inventory after connection has been\n                                  created\n  --help                          Show this message and exit.\n</code></pre> <p>It will give you all information loaded in ANTA inventory from your inventory file.</p> <p>Tip</p> <p>By default only information not based on device connection is available. If you want to get information based on connection such as hardware model, you should use the <code>--connected</code> option.</p>"},{"location":"cli/get-inventory-information/#example_1","title":"Example","text":"<p>Considering the following inventory file:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.10\nname: spine01\ntags: ['fabric', 'spine']\n- host: 192.168.0.11\nname: spine02\ntags: ['fabric', 'spine']\n- host: 192.168.0.12\nname: leaf01\ntags: ['fabric', 'leaf']\n- host: 192.168.0.13\nname: leaf02\ntags: ['fabric', 'leaf']\n- host: 192.168.0.14\nname: leaf03\ntags: ['fabric', 'leaf']\n- host: 192.168.0.15\nname: leaf04\ntags: ['fabric', 'leaf']\n</code></pre> <p>You can get ANTA inventory with the command:</p> <pre><code>$ anta --username ansible --password ansible get inventory --tags spine\nCurrent inventory content is:\n[\n{\n\"name\": \"spine01\",\n    \"host\": \"192.168.0.10\",\n    \"username\": \"ansible\",\n    \"password\": \"ansible\",\n    \"port\": \"443\",\n    \"enable_password\": \"None\",\n    \"session\": \"&lt;aioeapi.device.Device object at 0x7fa98d0a2d30&gt;\",\n    \"hw_model\": \"unset\",\n    \"tags\": \"['fabric', 'spine', 'all']\",\n    \"timeout\": \"10.0\",\n    \"established\": \"False\",\n    \"is_online\": \"False\"\n},\n  {\n\"name\": \"spine02\",\n    \"host\": \"192.168.0.11\",\n    \"username\": \"ansible\",\n    \"password\": \"ansible\",\n    \"port\": \"443\",\n    \"enable_password\": \"None\",\n    \"session\": \"&lt;aioeapi.device.Device object at 0x7fa98d0a2ac0&gt;\",\n    \"hw_model\": \"unset\",\n    \"tags\": \"['fabric', 'spine', 'all']\",\n    \"timeout\": \"10.0\",\n    \"established\": \"False\",\n    \"is_online\": \"False\"\n}\n]\nNone\n</code></pre>"},{"location":"cli/inv-from-cvp/","title":"Inventory from CVP","text":""},{"location":"cli/inv-from-cvp/#create-inventory-from-cloudvision","title":"Create inventory from CloudVision","text":"<p>In a large setup, it can be useful to create your inventory based on CloudVision inventory.</p> <pre><code>$ anta get from-cvp\nUsage: anta get from-cvp [OPTIONS]\n\nBuild ANTA inventory from Cloudvision\n\nOptions:\n  -ip, --cvp-ip TEXT              CVP IP Address\n  -u, --cvp-username TEXT         CVP Username\n  -p, --cvp-password TEXT         CVP Password / token\n  -c, --cvp-container TEXT        Container where devices are configured\n  -d, --inventory-directory PATH  Path to save inventory file\n  --log-level, --log [debug|info|warning|critical]\nLogging level of the command\n--help                          Show this message and exit.\n</code></pre> <p>Output is an inventory with the name of the container added as a tag for the host:</p> <pre><code>anta_inventory:\nhosts:\n- host: 192.168.0.13\nname: leaf2\ntags:\n- pod1\n- host: 192.168.0.15\nname: leaf4\ntags:\n- pod2\n</code></pre> <p>Warning</p> <p>Current implementation only takes devices directly attached to a specific container when using cli with <code>--cvp-container</code> option.</p> <p>If you want to build an inventory based on multiple containers, you can use a bash command as shown below and then manually concatenate files to create a single inventory file.</p> <pre><code>$ for container in pod01 pod02 spines; do anta get from-cvp -ip &lt;cvp-ip&gt; -u cvpadmin -p cvpadmin -c $container -d test-inventory; done\n\n[12:25:35] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:36] INFO     Creating inventory folder /home/tom/Projects/arista/network-test-automation/test-inventory\n           WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:37] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:38] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n\n[12:25:38] INFO     Getting auth token from cvp.as73.inetsix.net for user tom\n[12:25:39] WARNING  Using the new api_token parameter. This will override usage of the cvaas_token parameter if both are provided. This is because api_token and cvaas_token parameters\n                    are for the same use case and api_token is more generic\n           INFO     Connected to CVP cvp.as73.inetsix.net\n\n           INFO     Inventory file has been created in /home/tom/Projects/arista/network-test-automation/test-inventory/inventory-spines.yml\n</code></pre>"},{"location":"cli/nrfu/","title":"NRFU","text":""},{"location":"cli/nrfu/#execute-nrfu-testing","title":"Execute NRFU testing","text":"<p>All the NRFU testing commands are placed under <code>anta nrfu</code> and provide different rendering options:</p> <ul> <li>Table view</li> <li>JSON view</li> <li>Text view</li> <li>Custom template view</li> </ul> <pre><code>anta nrfu\nUsage: anta nrfu [OPTIONS] COMMAND [ARGS]...\n\n  Run NRFU against inventory devices\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  json        ANTA command to check network state with JSON result\n  table       ANTA command to check network states with table result\n  text        ANTA command to check network states with text result\n  tpl-report  ANTA command to check network state with templated report\n</code></pre> <p>All of these commands require the following input:</p> <ul> <li>A path to a catalog of tests to execute (<code>--catalog</code>)</li> <li>A list of tags if they are part of your inventory (<code>--tags</code>). List is comma separated</li> </ul>"},{"location":"cli/nrfu/#nrfu-with-text-rendering","title":"NRFU with text rendering","text":"<p>This rendering is a pure text report for every test run on all devices. It comes with some options:</p> <ul> <li>Search (<code>--search</code>) for a regexp pattern in hostname and test name</li> <li>Option to skip (<code>--skip-error</code>) tests in error (not failure) because of a connectivity issue or unsupported command</li> </ul> <p>Example output</p> <pre><code>$ anta nrfu text --tags pod1 --catalog nrfu/leaf.yml\nleaf2 :: VerifyMlagStatus :: SUCCESS\nleaf2 :: VerifyMlagInterface :: SUCCESS\nleaf2 :: VerifyMlagConfigSanity :: SUCCESS\nleaf2 :: VerifyInterfaceUtilization :: SUCCESS\nleaf2 :: VerifyInterfaceErrors :: SUCCESS\nleaf2 :: VerifyInterfaceDiscards :: SUCCESS\nleaf2 :: VerifyInterfaceErrDisabled :: SUCCESS\nleaf2 :: VerifyInterfaceStatus :: SUCCESS\nleaf2 :: VerifyStormControlDrop :: SKIPPED (VerifyStormControlDrop test is not supported on cEOSLab.)\nleaf2 :: VerifyPortChannel :: SUCCESS\nleaf2 :: VerifyIllegalLacp :: SUCCESS\nleaf2 :: VerifyLoopbackCount :: FAILURE (Found 3 Loopbacks when expecting 2)\nleaf2 :: VerifySvi :: SUCCESS\n[...]\n</code></pre>"},{"location":"cli/nrfu/#nrfu-with-table-report","title":"NRFU with table report","text":"<p>This rendering prints results in a nice table supporting grep filtering. It comes with its own set of options:</p> <ul> <li>Search (<code>--search</code>) for a pattern in hostname and test name.</li> <li>Option to group (<code>--group-by</code>) and summarize results. You can group by <code>host</code> or <code>test</code>.</li> </ul> <pre><code>$ anta check table -t pod1 -c nrfu/cudi.yml\n</code></pre> <p></p> <p>You can also group per host or per test to get a summary view in case of large setup</p> <p></p>"},{"location":"cli/nrfu/#nrfu-with-json-output","title":"NRFU with JSON output","text":"<p>This command is helpful to generate a JSON and then pass it to another tool for reporting for instance. Only one option is available to save output to a file (<code>--output</code>)</p> <pre><code>$ anta check json -t pod1 -c nrfu/leaf.yml\n[\n{\n\"name\": \"leaf01\",\n    \"test\": \"verify_zerotouch\",\n    \"test_category\": [\n\"configuration\"\n],\n    \"test_description\": \"Verifies ZeroTouch is disabled.\",\n    \"result\": \"success\",\n    \"messages\": []\n},\n  {\n\"name\": \"leaf01\",\n    \"test\": \"verify_running_config_diffs\",\n    \"test_category\": [\n\"configuration\"\n],\n    \"test_description\": \"\",\n    \"result\": \"success\",\n    \"messages\": []\n},\n]\n</code></pre>"},{"location":"cli/nrfu/#nrfu-with-your-own-report","title":"NRFU with your own report","text":"<p>Because you may want to have a specific report format, ANTA provides a CLI option to build report based on Jinja2 template.</p> <pre><code>$ anta nrfu tpl-report -c .personal/catalog-class.yml -tpl .personal/test_template.j2\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running check-devices with:                                \u2502\n\u2502               - Inventory: .personal/inventory_atd.yml     \u2502\n\u2502               - Tests catalog: .personal/catalog-class.yml \u2502\n\u2502               - Template: .personal/test_template.j2       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n* verify_zerotouch is SUCCESS for spine01\n* verify_running_config_diffs is SUCCESS for spine01\n* verify_interface_utilization is SUCCESS for spine01\n</code></pre> <p>And the template <code>.personal/test_template.j2</code> is a pure Jinja2 template:</p> <pre><code>$ cat .personal/test_template.j2\n{% for d in data %}\n* {{ d.test }} is [green]{{ d.result | upper}}[/green] for {{ d.name }}\n{% endfor %}\n</code></pre> <p>In this context, Jinja2 template can access to all <code>TestResult</code> elements with their values as described in this documentation.</p> <p>An option is available to save the generated report into a text file:</p> <pre><code># Run ANTA\n$ anta nrfu tpl-report -c .personal/catalog-class.yml -tpl .personal/test_template.j2 -o .personal/demo.txt\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Running check-devices with:                                \u2502\n\u2502               - Inventory: .personal/inventory_atd.yml     \u2502\n\u2502               - Tests catalog: .personal/catalog-class.yml \u2502\n\u2502               - Template: .personal/test_template.j2       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n* verify_zerotouch is SUCCESS for spine01\n* verify_running_config_diffs is SUCCESS for spine01\n* verify_interface_utilization is SUCCESS for spine01\n\n# Display saved report\n$ cat .personal/demo.txt\n* verify_zerotouch is [green]SUCCESS[/green] for spine01\n* verify_running_config_diffs is [green]SUCCESS[/green] for spine01\n* verify_interface_utilization is [green]SUCCESS[/green] for spine01\n</code></pre>"},{"location":"cli/overview/","title":"Overview","text":""},{"location":"cli/overview/#cli-overview","title":"CLI overview","text":"<p>ANTA comes with a CLI to execute all the supported actions. If you want to build your own tool, you should visit this page where we describe how to use ANTA as a python library</p> <p>To invoke anta, open a shell window and then enter <code>anta</code></p> <pre><code>$ anta\nUsage: anta [OPTIONS] COMMAND [ARGS]...\n\n  Arista Network Test CLI\n\nOptions:\n  --username TEXT         Username to connect to EOS  [env var: ANTA_USERNAME]\n--password TEXT         Password to connect to EOS  [env var: ANTA_PASSWORD]\n--timeout INTEGER       Connection timeout (default 5)  [env var: ANTA_TIMEOUT]\n--enable-password TEXT  Enable password if required to connect  [env var: ANTA_ENABLE_PASSWORD]\n-i, --inventory PATH    Path to your inventory file  [env var: ANTA_INVENTORY]\n--timeout INTEGER       Connection timeout (default 5)  [env var: ANTA_TIMEOUT]\n--help                  Show this message and exit.\n\nCommands:\n  exec  Execute commands to inventory devices\n  get   Get data from/to ANTA\n  nrfu  Run NRFU against inventory devices\n</code></pre>"},{"location":"cli/overview/#anta-parameters","title":"ANTA parameters","text":"<p>Some parameters are globally required and can be passed to anta via cli or via ENV VAR:</p> <pre><code>$ anta --username tom --password arista123 --inventory inventory.yml &lt;anta cli&gt;\n</code></pre> <p>Or if you prefer to set ENV VAR:</p> <pre><code># Save information for anta cli\n$ export ANTA_USERNAME=tom\n$ export ANTA_PASSWORD=arista123\n$ export ANTA_INVENTORY=inventory.yml\n\n# Run cli\n$ anta &lt;anta cli&gt;\n</code></pre>"},{"location":"cli/overview/#shell-completion","title":"Shell Completion","text":"<p>You can enable shell completion for the anta cli:</p> ZSHBASH <p>If you use ZSH shell, add the following line in your <code>~/.zshrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=zsh_source anta)\" &gt; /dev/null\n</code></pre> <p>With bash, add the following line in your <code>~/.bashrc</code>:</p> <pre><code>eval \"$(_ANTA_COMPLETE=bash_source anta)\" &gt; /dev/null\n</code></pre>"}]}